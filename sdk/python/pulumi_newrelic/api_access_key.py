# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = ['ApiAccessKeyArgs', 'ApiAccessKey']

@pulumi.input_type
class ApiAccessKeyArgs:
    def __init__(__self__, *,
                 key_type: pulumi.Input[_builtins.str],
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 ingest_type: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 notes: Optional[pulumi.Input[_builtins.str]] = None,
                 user_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The set of arguments for constructing a ApiAccessKey resource.
        :param pulumi.Input[_builtins.str] key_type: The type of API key to create. Valid options are `INGEST` or `USER` (case-sensitive).
               - If `key_type` is `INGEST`, then `ingest_type` must be specified.
               - If `key_type` is `USER`, then `user_id` must be specified.
        :param pulumi.Input[_builtins.str] account_id: The New Relic account ID where the API access key will be created.
        :param pulumi.Input[_builtins.str] ingest_type: Required if `key_type` is `INGEST`. Valid options are `BROWSER` or `LICENSE` (case-sensitive).
        :param pulumi.Input[_builtins.str] name: The name of the API key.
               - **Note**: While `name` is optional, it is <b style="color:red;">\\*\\*strongly recommended\\*\\*</b> to provide a meaningful name for easier identification and management of keys. If a `name` is not provided, the API will assign a default name when processing the request to create the API key, which may cause unexpected drift in your Terraform state. To prevent this, it is best practice to always specify a `name`.
        :param pulumi.Input[_builtins.str] notes: Additional notes about the API access key.
        :param pulumi.Input[_builtins.str] user_id: Required if `key_type` is `USER`. The New Relic user ID for which the API access key will be created.
        """
        pulumi.set(__self__, "key_type", key_type)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if ingest_type is not None:
            pulumi.set(__self__, "ingest_type", ingest_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="keyType")
    def key_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of API key to create. Valid options are `INGEST` or `USER` (case-sensitive).
        - If `key_type` is `INGEST`, then `ingest_type` must be specified.
        - If `key_type` is `USER`, then `user_id` must be specified.
        """
        return pulumi.get(self, "key_type")

    @key_type.setter
    def key_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_type", value)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The New Relic account ID where the API access key will be created.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter(name="ingestType")
    def ingest_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Required if `key_type` is `INGEST`. Valid options are `BROWSER` or `LICENSE` (case-sensitive).
        """
        return pulumi.get(self, "ingest_type")

    @ingest_type.setter
    def ingest_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ingest_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the API key.
        - **Note**: While `name` is optional, it is <b style="color:red;">\\*\\*strongly recommended\\*\\*</b> to provide a meaningful name for easier identification and management of keys. If a `name` is not provided, the API will assign a default name when processing the request to create the API key, which may cause unexpected drift in your Terraform state. To prevent this, it is best practice to always specify a `name`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def notes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional notes about the API access key.
        """
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notes", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Required if `key_type` is `USER`. The New Relic user ID for which the API access key will be created.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_id", value)


@pulumi.input_type
class _ApiAccessKeyState:
    def __init__(__self__, *,
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 ingest_type: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 key_type: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 notes: Optional[pulumi.Input[_builtins.str]] = None,
                 user_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Input properties used for looking up and filtering ApiAccessKey resources.
        :param pulumi.Input[_builtins.str] account_id: The New Relic account ID where the API access key will be created.
        :param pulumi.Input[_builtins.str] ingest_type: Required if `key_type` is `INGEST`. Valid options are `BROWSER` or `LICENSE` (case-sensitive).
        :param pulumi.Input[_builtins.str] key: The actual API key.
               - <span style="color:tomato;">It is important to exercise caution when exporting the value of `key`, as it is sensitive information</span>. Avoid logging or exposing it inappropriately.
        :param pulumi.Input[_builtins.str] key_type: The type of API key to create. Valid options are `INGEST` or `USER` (case-sensitive).
               - If `key_type` is `INGEST`, then `ingest_type` must be specified.
               - If `key_type` is `USER`, then `user_id` must be specified.
        :param pulumi.Input[_builtins.str] name: The name of the API key.
               - **Note**: While `name` is optional, it is <b style="color:red;">\\*\\*strongly recommended\\*\\*</b> to provide a meaningful name for easier identification and management of keys. If a `name` is not provided, the API will assign a default name when processing the request to create the API key, which may cause unexpected drift in your Terraform state. To prevent this, it is best practice to always specify a `name`.
        :param pulumi.Input[_builtins.str] notes: Additional notes about the API access key.
        :param pulumi.Input[_builtins.str] user_id: Required if `key_type` is `USER`. The New Relic user ID for which the API access key will be created.
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if ingest_type is not None:
            pulumi.set(__self__, "ingest_type", ingest_type)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if key_type is not None:
            pulumi.set(__self__, "key_type", key_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The New Relic account ID where the API access key will be created.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter(name="ingestType")
    def ingest_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Required if `key_type` is `INGEST`. Valid options are `BROWSER` or `LICENSE` (case-sensitive).
        """
        return pulumi.get(self, "ingest_type")

    @ingest_type.setter
    def ingest_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ingest_type", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The actual API key.
        - <span style="color:tomato;">It is important to exercise caution when exporting the value of `key`, as it is sensitive information</span>. Avoid logging or exposing it inappropriately.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="keyType")
    def key_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of API key to create. Valid options are `INGEST` or `USER` (case-sensitive).
        - If `key_type` is `INGEST`, then `ingest_type` must be specified.
        - If `key_type` is `USER`, then `user_id` must be specified.
        """
        return pulumi.get(self, "key_type")

    @key_type.setter
    def key_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the API key.
        - **Note**: While `name` is optional, it is <b style="color:red;">\\*\\*strongly recommended\\*\\*</b> to provide a meaningful name for easier identification and management of keys. If a `name` is not provided, the API will assign a default name when processing the request to create the API key, which may cause unexpected drift in your Terraform state. To prevent this, it is best practice to always specify a `name`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def notes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional notes about the API access key.
        """
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notes", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Required if `key_type` is `USER`. The New Relic user ID for which the API access key will be created.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_id", value)


@pulumi.type_token("newrelic:index/apiAccessKey:ApiAccessKey")
class ApiAccessKey(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 ingest_type: Optional[pulumi.Input[_builtins.str]] = None,
                 key_type: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 notes: Optional[pulumi.Input[_builtins.str]] = None,
                 user_id: Optional[pulumi.Input[_builtins.str]] = None,
                 __props__=None):
        """
        Use this resource to programmatically create and manage the following types of keys in New Relic:
        - [User API keys](https://docs.newrelic.com/docs/apis/get-started/intro-apis/types-new-relic-api-keys#user-api-key)
        - License (or ingest) keys, including:
          - General (Ingest) [license keys](https://docs.newrelic.com/docs/accounts/install-new-relic/account-setup/license-key) used for APM
          - [Browser license keys](https://docs.newrelic.com/docs/browser/new-relic-browser/configuration/copy-browser-monitoring-license-key-app-id)

        Refer to the New Relic article ['Use NerdGraph to manage license keys and User API keys'](https://docs.newrelic.com/docs/apis/nerdgraph/examples/use-nerdgraph-manage-license-keys-user-keys) for detailed information.

        > **WARNING:** When creating a User API key, if a <span style="color:tomato;">truncated API key</span> appears in the state after the first `pulumi up`, it is likely because the API key was created for a user other than the one running Terraform. This is a security measure by the New Relic API to _prevent exposing the full key value when an API key is created for another user_. See the Important Considerations section below for more details.

        ## Example Usage

        ### Example: Creating a User API Key
        ```python
        import pulumi
        import pulumi_newrelic as newrelic

        user_api_key = newrelic.ApiAccessKey("user_api_key",
            account_id="1234321",
            key_type="USER",
            user_id="1001111101",
            name="User API Key for Admin Access",
            notes="This key is used for managing user-level API access.")
        ```

        ### Example: Creating an Ingest License Key
        ```python
        import pulumi
        import pulumi_newrelic as newrelic

        ingest_license_key = newrelic.ApiAccessKey("ingest_license_key",
            account_id="1234321",
            key_type="INGEST",
            ingest_type="LICENSE",
            name="Ingest License Key for App Monitoring",
            notes="This key is used for APM and other ingest purposes.")
        ```

        ### Example: Creating an Ingest Browser Key
        ```python
        import pulumi
        import pulumi_newrelic as newrelic

        ingest_browser_key = newrelic.ApiAccessKey("ingest_browser_key",
            account_id="1234321",
            key_type="INGEST",
            ingest_type="BROWSER",
            name="Browser Monitoring Key",
            notes="This key is used for browser monitoring and analytics.")
        ```

        ## Important Considerations

        #### Updating Existing Keys
        - Only `name` and `notes` can be updated in place. Changes to other attributes will recreate the key (the `ApiAccessKey` resource), invalidating the existing one.

        #### Creating API Keys for Other Users
        - If an API key is created for a user other than the owner of the API key used to run Terraform, the full key value will not be returned by the API for security reasons. Instead, a truncated version of the key will be provided. To retrieve the full key, ensure the necessary capabilities and access management settings are applied to the user running Terraform. For more details, contact New Relic Support.

        #### Importing Existing Keys into Terraform State
        - A key may be imported with its ID using the syntax described in the Import section below. However, the actual value of the key _cannot be imported_ if the key being fetched was created by a user other than the one whose API key is being used to run Terraform. In such cases, the API returns a truncated key for security reasons. For more details, see [Use NerdGraph to manage license keys and User API keys](https://docs.newrelic.com/docs/apis/nerdgraph/examples/use-nerdgraph-manage-license-keys-user-keys/#query-keys).

        #### Account Type Restrictions for Ingest Keys
        - Creating `INGEST` keys requires a New Relic user with core or full platform access. See [user types](https://docs.newrelic.com/docs/accounts/accounts-billing/new-relic-one-user-management/user-type/#api-access).

        ## Import

        Existing API access keys can be imported using a composite ID of `<api_access_key_id>:<key_type>`, where `<key_type>` is either `INGEST` or `USER`. Refer to the considerations listed in the Important Considerations section above regarding limitations on importing the actual key value.

        For example:
        ```sh
        $ pulumi import newrelic:index/apiAccessKey:ApiAccessKey foobar "131313133A331313130B5F13DF01313FDB13B13133EE5E133D13EAAB3A3C13D3:INGEST"
        ```

        For customers using Terraform v1.5 and above, it is recommended to use the `import {}` block in your Terraform configuration. This allows Terraform to generate the resource configuration automatically during the import process by running a `pulumi preview -generate-config-out=<filename>.tf`, reducing manual effort and ensuring accuracy.

        For example:

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] account_id: The New Relic account ID where the API access key will be created.
        :param pulumi.Input[_builtins.str] ingest_type: Required if `key_type` is `INGEST`. Valid options are `BROWSER` or `LICENSE` (case-sensitive).
        :param pulumi.Input[_builtins.str] key_type: The type of API key to create. Valid options are `INGEST` or `USER` (case-sensitive).
               - If `key_type` is `INGEST`, then `ingest_type` must be specified.
               - If `key_type` is `USER`, then `user_id` must be specified.
        :param pulumi.Input[_builtins.str] name: The name of the API key.
               - **Note**: While `name` is optional, it is <b style="color:red;">\\*\\*strongly recommended\\*\\*</b> to provide a meaningful name for easier identification and management of keys. If a `name` is not provided, the API will assign a default name when processing the request to create the API key, which may cause unexpected drift in your Terraform state. To prevent this, it is best practice to always specify a `name`.
        :param pulumi.Input[_builtins.str] notes: Additional notes about the API access key.
        :param pulumi.Input[_builtins.str] user_id: Required if `key_type` is `USER`. The New Relic user ID for which the API access key will be created.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: ApiAccessKeyArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Use this resource to programmatically create and manage the following types of keys in New Relic:
        - [User API keys](https://docs.newrelic.com/docs/apis/get-started/intro-apis/types-new-relic-api-keys#user-api-key)
        - License (or ingest) keys, including:
          - General (Ingest) [license keys](https://docs.newrelic.com/docs/accounts/install-new-relic/account-setup/license-key) used for APM
          - [Browser license keys](https://docs.newrelic.com/docs/browser/new-relic-browser/configuration/copy-browser-monitoring-license-key-app-id)

        Refer to the New Relic article ['Use NerdGraph to manage license keys and User API keys'](https://docs.newrelic.com/docs/apis/nerdgraph/examples/use-nerdgraph-manage-license-keys-user-keys) for detailed information.

        > **WARNING:** When creating a User API key, if a <span style="color:tomato;">truncated API key</span> appears in the state after the first `pulumi up`, it is likely because the API key was created for a user other than the one running Terraform. This is a security measure by the New Relic API to _prevent exposing the full key value when an API key is created for another user_. See the Important Considerations section below for more details.

        ## Example Usage

        ### Example: Creating a User API Key
        ```python
        import pulumi
        import pulumi_newrelic as newrelic

        user_api_key = newrelic.ApiAccessKey("user_api_key",
            account_id="1234321",
            key_type="USER",
            user_id="1001111101",
            name="User API Key for Admin Access",
            notes="This key is used for managing user-level API access.")
        ```

        ### Example: Creating an Ingest License Key
        ```python
        import pulumi
        import pulumi_newrelic as newrelic

        ingest_license_key = newrelic.ApiAccessKey("ingest_license_key",
            account_id="1234321",
            key_type="INGEST",
            ingest_type="LICENSE",
            name="Ingest License Key for App Monitoring",
            notes="This key is used for APM and other ingest purposes.")
        ```

        ### Example: Creating an Ingest Browser Key
        ```python
        import pulumi
        import pulumi_newrelic as newrelic

        ingest_browser_key = newrelic.ApiAccessKey("ingest_browser_key",
            account_id="1234321",
            key_type="INGEST",
            ingest_type="BROWSER",
            name="Browser Monitoring Key",
            notes="This key is used for browser monitoring and analytics.")
        ```

        ## Important Considerations

        #### Updating Existing Keys
        - Only `name` and `notes` can be updated in place. Changes to other attributes will recreate the key (the `ApiAccessKey` resource), invalidating the existing one.

        #### Creating API Keys for Other Users
        - If an API key is created for a user other than the owner of the API key used to run Terraform, the full key value will not be returned by the API for security reasons. Instead, a truncated version of the key will be provided. To retrieve the full key, ensure the necessary capabilities and access management settings are applied to the user running Terraform. For more details, contact New Relic Support.

        #### Importing Existing Keys into Terraform State
        - A key may be imported with its ID using the syntax described in the Import section below. However, the actual value of the key _cannot be imported_ if the key being fetched was created by a user other than the one whose API key is being used to run Terraform. In such cases, the API returns a truncated key for security reasons. For more details, see [Use NerdGraph to manage license keys and User API keys](https://docs.newrelic.com/docs/apis/nerdgraph/examples/use-nerdgraph-manage-license-keys-user-keys/#query-keys).

        #### Account Type Restrictions for Ingest Keys
        - Creating `INGEST` keys requires a New Relic user with core or full platform access. See [user types](https://docs.newrelic.com/docs/accounts/accounts-billing/new-relic-one-user-management/user-type/#api-access).

        ## Import

        Existing API access keys can be imported using a composite ID of `<api_access_key_id>:<key_type>`, where `<key_type>` is either `INGEST` or `USER`. Refer to the considerations listed in the Important Considerations section above regarding limitations on importing the actual key value.

        For example:
        ```sh
        $ pulumi import newrelic:index/apiAccessKey:ApiAccessKey foobar "131313133A331313130B5F13DF01313FDB13B13133EE5E133D13EAAB3A3C13D3:INGEST"
        ```

        For customers using Terraform v1.5 and above, it is recommended to use the `import {}` block in your Terraform configuration. This allows Terraform to generate the resource configuration automatically during the import process by running a `pulumi preview -generate-config-out=<filename>.tf`, reducing manual effort and ensuring accuracy.

        For example:

        :param str resource_name: The name of the resource.
        :param ApiAccessKeyArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(ApiAccessKeyArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 ingest_type: Optional[pulumi.Input[_builtins.str]] = None,
                 key_type: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 notes: Optional[pulumi.Input[_builtins.str]] = None,
                 user_id: Optional[pulumi.Input[_builtins.str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = ApiAccessKeyArgs.__new__(ApiAccessKeyArgs)

            __props__.__dict__["account_id"] = account_id
            __props__.__dict__["ingest_type"] = ingest_type
            if key_type is None and not opts.urn:
                raise TypeError("Missing required property 'key_type'")
            __props__.__dict__["key_type"] = key_type
            __props__.__dict__["name"] = name
            __props__.__dict__["notes"] = notes
            __props__.__dict__["user_id"] = user_id
            __props__.__dict__["key"] = None
        super(ApiAccessKey, __self__).__init__(
            'newrelic:index/apiAccessKey:ApiAccessKey',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            account_id: Optional[pulumi.Input[_builtins.str]] = None,
            ingest_type: Optional[pulumi.Input[_builtins.str]] = None,
            key: Optional[pulumi.Input[_builtins.str]] = None,
            key_type: Optional[pulumi.Input[_builtins.str]] = None,
            name: Optional[pulumi.Input[_builtins.str]] = None,
            notes: Optional[pulumi.Input[_builtins.str]] = None,
            user_id: Optional[pulumi.Input[_builtins.str]] = None) -> 'ApiAccessKey':
        """
        Get an existing ApiAccessKey resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] account_id: The New Relic account ID where the API access key will be created.
        :param pulumi.Input[_builtins.str] ingest_type: Required if `key_type` is `INGEST`. Valid options are `BROWSER` or `LICENSE` (case-sensitive).
        :param pulumi.Input[_builtins.str] key: The actual API key.
               - <span style="color:tomato;">It is important to exercise caution when exporting the value of `key`, as it is sensitive information</span>. Avoid logging or exposing it inappropriately.
        :param pulumi.Input[_builtins.str] key_type: The type of API key to create. Valid options are `INGEST` or `USER` (case-sensitive).
               - If `key_type` is `INGEST`, then `ingest_type` must be specified.
               - If `key_type` is `USER`, then `user_id` must be specified.
        :param pulumi.Input[_builtins.str] name: The name of the API key.
               - **Note**: While `name` is optional, it is <b style="color:red;">\\*\\*strongly recommended\\*\\*</b> to provide a meaningful name for easier identification and management of keys. If a `name` is not provided, the API will assign a default name when processing the request to create the API key, which may cause unexpected drift in your Terraform state. To prevent this, it is best practice to always specify a `name`.
        :param pulumi.Input[_builtins.str] notes: Additional notes about the API access key.
        :param pulumi.Input[_builtins.str] user_id: Required if `key_type` is `USER`. The New Relic user ID for which the API access key will be created.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _ApiAccessKeyState.__new__(_ApiAccessKeyState)

        __props__.__dict__["account_id"] = account_id
        __props__.__dict__["ingest_type"] = ingest_type
        __props__.__dict__["key"] = key
        __props__.__dict__["key_type"] = key_type
        __props__.__dict__["name"] = name
        __props__.__dict__["notes"] = notes
        __props__.__dict__["user_id"] = user_id
        return ApiAccessKey(resource_name, opts=opts, __props__=__props__)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        The New Relic account ID where the API access key will be created.
        """
        return pulumi.get(self, "account_id")

    @_builtins.property
    @pulumi.getter(name="ingestType")
    def ingest_type(self) -> pulumi.Output[_builtins.str]:
        """
        Required if `key_type` is `INGEST`. Valid options are `BROWSER` or `LICENSE` (case-sensitive).
        """
        return pulumi.get(self, "ingest_type")

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Output[_builtins.str]:
        """
        The actual API key.
        - <span style="color:tomato;">It is important to exercise caution when exporting the value of `key`, as it is sensitive information</span>. Avoid logging or exposing it inappropriately.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="keyType")
    def key_type(self) -> pulumi.Output[_builtins.str]:
        """
        The type of API key to create. Valid options are `INGEST` or `USER` (case-sensitive).
        - If `key_type` is `INGEST`, then `ingest_type` must be specified.
        - If `key_type` is `USER`, then `user_id` must be specified.
        """
        return pulumi.get(self, "key_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Output[_builtins.str]:
        """
        The name of the API key.
        - **Note**: While `name` is optional, it is <b style="color:red;">\\*\\*strongly recommended\\*\\*</b> to provide a meaningful name for easier identification and management of keys. If a `name` is not provided, the API will assign a default name when processing the request to create the API key, which may cause unexpected drift in your Terraform state. To prevent this, it is best practice to always specify a `name`.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def notes(self) -> pulumi.Output[_builtins.str]:
        """
        Additional notes about the API access key.
        """
        return pulumi.get(self, "notes")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> pulumi.Output[_builtins.str]:
        """
        Required if `key_type` is `USER`. The New Relic user ID for which the API access key will be created.
        """
        return pulumi.get(self, "user_id")

