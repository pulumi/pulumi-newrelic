# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['AlertCompoundConditionArgs', 'AlertCompoundCondition']

@pulumi.input_type
class AlertCompoundConditionArgs:
    def __init__(__self__, *,
                 component_conditions: pulumi.Input[Sequence[pulumi.Input['AlertCompoundConditionComponentConditionArgs']]],
                 enabled: pulumi.Input[_builtins.bool],
                 policy_id: pulumi.Input[_builtins.str],
                 trigger_expression: pulumi.Input[_builtins.str],
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 facet_matching_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 runbook_url: Optional[pulumi.Input[_builtins.str]] = None,
                 threshold_duration: Optional[pulumi.Input[_builtins.int]] = None):
        """
        The set of arguments for constructing a AlertCompoundCondition resource.
        :param pulumi.Input[Sequence[pulumi.Input['AlertCompoundConditionComponentConditionArgs']]] component_conditions: The list of conditions to be combined. Each component condition must be enabled. Must include at least 2. See Component Conditions below for details.
        :param pulumi.Input[_builtins.bool] enabled: Whether or not the compound alert condition is enabled. Defaults to `true`.
        :param pulumi.Input[_builtins.str] policy_id: The ID of the policy where this alert compound condition should be used.
        :param pulumi.Input[_builtins.str] trigger_expression: Expression that defines how component condition evaluations are combined. Valid operators are 'AND', 'OR', 'NOT'. For more complex expressions, use parentheses. Use the aliases from `component_conditions` to build expressions like `"A AND B"`, `"A OR B"`, `"(A AND B) OR C"`, or `"A AND (B OR C) AND NOT (D AND E)"`.
        :param pulumi.Input[_builtins.str] account_id: The New Relic account ID for managing your compound alert conditions. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
        :param pulumi.Input[_builtins.str] facet_matching_behavior: How the compound condition will take into account the component conditions' facets during evaluation. Valid values are:
               - `FACETS_IGNORED` - (Default) Facets are not taken into consideration when determining when the compound alert condition activates
               - `FACETS_MATCH` - The compound alert condition will activate only when shared facets have matching values
        :param pulumi.Input[_builtins.str] name: The title of the compound alert condition.
        :param pulumi.Input[_builtins.str] runbook_url: Runbook URL to display in notifications.
        :param pulumi.Input[_builtins.int] threshold_duration: The duration, in seconds, that the trigger expression must be true before the compound alert condition will activate. Between 30-86400 seconds.
        """
        pulumi.set(__self__, "component_conditions", component_conditions)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "trigger_expression", trigger_expression)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if facet_matching_behavior is not None:
            pulumi.set(__self__, "facet_matching_behavior", facet_matching_behavior)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if runbook_url is not None:
            pulumi.set(__self__, "runbook_url", runbook_url)
        if threshold_duration is not None:
            pulumi.set(__self__, "threshold_duration", threshold_duration)

    @_builtins.property
    @pulumi.getter(name="componentConditions")
    def component_conditions(self) -> pulumi.Input[Sequence[pulumi.Input['AlertCompoundConditionComponentConditionArgs']]]:
        """
        The list of conditions to be combined. Each component condition must be enabled. Must include at least 2. See Component Conditions below for details.
        """
        return pulumi.get(self, "component_conditions")

    @component_conditions.setter
    def component_conditions(self, value: pulumi.Input[Sequence[pulumi.Input['AlertCompoundConditionComponentConditionArgs']]]):
        pulumi.set(self, "component_conditions", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether or not the compound alert condition is enabled. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the policy where this alert compound condition should be used.
        """
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "policy_id", value)

    @_builtins.property
    @pulumi.getter(name="triggerExpression")
    def trigger_expression(self) -> pulumi.Input[_builtins.str]:
        """
        Expression that defines how component condition evaluations are combined. Valid operators are 'AND', 'OR', 'NOT'. For more complex expressions, use parentheses. Use the aliases from `component_conditions` to build expressions like `"A AND B"`, `"A OR B"`, `"(A AND B) OR C"`, or `"A AND (B OR C) AND NOT (D AND E)"`.
        """
        return pulumi.get(self, "trigger_expression")

    @trigger_expression.setter
    def trigger_expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "trigger_expression", value)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The New Relic account ID for managing your compound alert conditions. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter(name="facetMatchingBehavior")
    def facet_matching_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How the compound condition will take into account the component conditions' facets during evaluation. Valid values are:
        - `FACETS_IGNORED` - (Default) Facets are not taken into consideration when determining when the compound alert condition activates
        - `FACETS_MATCH` - The compound alert condition will activate only when shared facets have matching values
        """
        return pulumi.get(self, "facet_matching_behavior")

    @facet_matching_behavior.setter
    def facet_matching_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "facet_matching_behavior", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The title of the compound alert condition.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="runbookUrl")
    def runbook_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Runbook URL to display in notifications.
        """
        return pulumi.get(self, "runbook_url")

    @runbook_url.setter
    def runbook_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "runbook_url", value)

    @_builtins.property
    @pulumi.getter(name="thresholdDuration")
    def threshold_duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The duration, in seconds, that the trigger expression must be true before the compound alert condition will activate. Between 30-86400 seconds.
        """
        return pulumi.get(self, "threshold_duration")

    @threshold_duration.setter
    def threshold_duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "threshold_duration", value)


@pulumi.input_type
class _AlertCompoundConditionState:
    def __init__(__self__, *,
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 component_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['AlertCompoundConditionComponentConditionArgs']]]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 facet_matching_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 runbook_url: Optional[pulumi.Input[_builtins.str]] = None,
                 threshold_duration: Optional[pulumi.Input[_builtins.int]] = None,
                 trigger_expression: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Input properties used for looking up and filtering AlertCompoundCondition resources.
        :param pulumi.Input[_builtins.str] account_id: The New Relic account ID for managing your compound alert conditions. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
        :param pulumi.Input[Sequence[pulumi.Input['AlertCompoundConditionComponentConditionArgs']]] component_conditions: The list of conditions to be combined. Each component condition must be enabled. Must include at least 2. See Component Conditions below for details.
        :param pulumi.Input[_builtins.bool] enabled: Whether or not the compound alert condition is enabled. Defaults to `true`.
        :param pulumi.Input[_builtins.str] facet_matching_behavior: How the compound condition will take into account the component conditions' facets during evaluation. Valid values are:
               - `FACETS_IGNORED` - (Default) Facets are not taken into consideration when determining when the compound alert condition activates
               - `FACETS_MATCH` - The compound alert condition will activate only when shared facets have matching values
        :param pulumi.Input[_builtins.str] name: The title of the compound alert condition.
        :param pulumi.Input[_builtins.str] policy_id: The ID of the policy where this alert compound condition should be used.
        :param pulumi.Input[_builtins.str] runbook_url: Runbook URL to display in notifications.
        :param pulumi.Input[_builtins.int] threshold_duration: The duration, in seconds, that the trigger expression must be true before the compound alert condition will activate. Between 30-86400 seconds.
        :param pulumi.Input[_builtins.str] trigger_expression: Expression that defines how component condition evaluations are combined. Valid operators are 'AND', 'OR', 'NOT'. For more complex expressions, use parentheses. Use the aliases from `component_conditions` to build expressions like `"A AND B"`, `"A OR B"`, `"(A AND B) OR C"`, or `"A AND (B OR C) AND NOT (D AND E)"`.
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if component_conditions is not None:
            pulumi.set(__self__, "component_conditions", component_conditions)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if facet_matching_behavior is not None:
            pulumi.set(__self__, "facet_matching_behavior", facet_matching_behavior)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if runbook_url is not None:
            pulumi.set(__self__, "runbook_url", runbook_url)
        if threshold_duration is not None:
            pulumi.set(__self__, "threshold_duration", threshold_duration)
        if trigger_expression is not None:
            pulumi.set(__self__, "trigger_expression", trigger_expression)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The New Relic account ID for managing your compound alert conditions. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter(name="componentConditions")
    def component_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertCompoundConditionComponentConditionArgs']]]]:
        """
        The list of conditions to be combined. Each component condition must be enabled. Must include at least 2. See Component Conditions below for details.
        """
        return pulumi.get(self, "component_conditions")

    @component_conditions.setter
    def component_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertCompoundConditionComponentConditionArgs']]]]):
        pulumi.set(self, "component_conditions", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not the compound alert condition is enabled. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="facetMatchingBehavior")
    def facet_matching_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How the compound condition will take into account the component conditions' facets during evaluation. Valid values are:
        - `FACETS_IGNORED` - (Default) Facets are not taken into consideration when determining when the compound alert condition activates
        - `FACETS_MATCH` - The compound alert condition will activate only when shared facets have matching values
        """
        return pulumi.get(self, "facet_matching_behavior")

    @facet_matching_behavior.setter
    def facet_matching_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "facet_matching_behavior", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The title of the compound alert condition.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the policy where this alert compound condition should be used.
        """
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy_id", value)

    @_builtins.property
    @pulumi.getter(name="runbookUrl")
    def runbook_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Runbook URL to display in notifications.
        """
        return pulumi.get(self, "runbook_url")

    @runbook_url.setter
    def runbook_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "runbook_url", value)

    @_builtins.property
    @pulumi.getter(name="thresholdDuration")
    def threshold_duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The duration, in seconds, that the trigger expression must be true before the compound alert condition will activate. Between 30-86400 seconds.
        """
        return pulumi.get(self, "threshold_duration")

    @threshold_duration.setter
    def threshold_duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "threshold_duration", value)

    @_builtins.property
    @pulumi.getter(name="triggerExpression")
    def trigger_expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Expression that defines how component condition evaluations are combined. Valid operators are 'AND', 'OR', 'NOT'. For more complex expressions, use parentheses. Use the aliases from `component_conditions` to build expressions like `"A AND B"`, `"A OR B"`, `"(A AND B) OR C"`, or `"A AND (B OR C) AND NOT (D AND E)"`.
        """
        return pulumi.get(self, "trigger_expression")

    @trigger_expression.setter
    def trigger_expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trigger_expression", value)


@pulumi.type_token("newrelic:index/alertCompoundCondition:AlertCompoundCondition")
class AlertCompoundCondition(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 component_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[Union['AlertCompoundConditionComponentConditionArgs', 'AlertCompoundConditionComponentConditionArgsDict']]]]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 facet_matching_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 runbook_url: Optional[pulumi.Input[_builtins.str]] = None,
                 threshold_duration: Optional[pulumi.Input[_builtins.int]] = None,
                 trigger_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 __props__=None):
        """
        Use this resource to create and manage compound alert conditions in New Relic. Compound conditions allow you to combine multiple alert conditions using logical expressions (AND, OR, NOT) to create more sophisticated alerting logic.

        ## Example Usage

        ### Basic Compound Condition (AND)

        ```python
        import pulumi
        import pulumi_newrelic as newrelic

        example = newrelic.AlertPolicy("example", name="my-policy")
        # Create component NRQL conditions
        high_response_time = newrelic.NrqlAlertCondition("high_response_time",
            policy_id=example.id,
            name="High Response Time",
            enabled=True,
            nrql={
                "query": "SELECT average(duration) FROM Transaction WHERE appName = 'MyApp'",
            },
            critical={
                "operator": "above",
                "threshold": 5,
                "threshold_duration": 300,
                "threshold_occurrences": "all",
            },
            violation_time_limit_seconds=3600)
        high_error_rate = newrelic.NrqlAlertCondition("high_error_rate",
            policy_id=example.id,
            name="High Error Rate",
            enabled=True,
            nrql={
                "query": "SELECT percentage(count(*), WHERE error IS true) FROM Transaction WHERE appName = 'MyApp'",
            },
            critical={
                "operator": "above",
                "threshold": 5,
                "threshold_duration": 300,
                "threshold_occurrences": "all",
            },
            violation_time_limit_seconds=3600)
        # Create alert compound condition combining both
        critical_service_health = newrelic.AlertCompoundCondition("critical_service_health",
            policy_id=example.id,
            name="Critical Service Health",
            enabled=True,
            trigger_expression="A AND B",
            runbook_url="https://example.com/runbooks/critical-health",
            threshold_duration=120,
            component_conditions=[
                {
                    "id": high_response_time.id,
                    "alias": "A",
                },
                {
                    "id": high_error_rate.id,
                    "alias": "B",
                },
            ],
            facet_matching_behavior="FACETS_IGNORED")
        ```

        ### Complex Condition with Three Components

        ```python
        import pulumi
        import pulumi_newrelic as newrelic

        high_cpu = newrelic.NrqlAlertCondition("high_cpu",
            policy_id=example["id"],
            name="High CPU",
            enabled=True,
            nrql={
                "query": "SELECT average(cpuPercent) FROM SystemSample WHERE hostname = 'myhost'",
            },
            critical={
                "operator": "above",
                "threshold": 80,
                "threshold_duration": 300,
                "threshold_occurrences": "all",
            },
            violation_time_limit_seconds=3600)
        high_memory = newrelic.NrqlAlertCondition("high_memory",
            policy_id=example["id"],
            name="High Memory",
            enabled=True,
            nrql={
                "query": "SELECT average(memoryUsedPercent) FROM SystemSample WHERE hostname = 'myhost'",
            },
            critical={
                "operator": "above",
                "threshold": 85,
                "threshold_duration": 300,
                "threshold_occurrences": "all",
            },
            violation_time_limit_seconds=3600)
        disk_full = newrelic.NrqlAlertCondition("disk_full",
            policy_id=example["id"],
            name="Disk Full",
            enabled=True,
            nrql={
                "query": "SELECT average(diskUsedPercent) FROM SystemSample WHERE hostname = 'myhost'",
            },
            critical={
                "operator": "above",
                "threshold": 90,
                "threshold_duration": 300,
                "threshold_occurrences": "all",
            },
            violation_time_limit_seconds=3600)
        complex = newrelic.AlertCompoundCondition("complex",
            policy_id=example["id"],
            name="Complex Infrastructure Alert",
            enabled=True,
            trigger_expression="(A AND B) OR C",
            component_conditions=[
                {
                    "id": high_cpu.id,
                    "alias": "A",
                },
                {
                    "id": high_memory.id,
                    "alias": "B",
                },
                {
                    "id": disk_full.id,
                    "alias": "C",
                },
            ])
        ```

        ### With Facet Matching

        ```python
        import pulumi
        import pulumi_newrelic as newrelic

        high_throughput_per_host = newrelic.NrqlAlertCondition("high_throughput_per_host",
            policy_id=example["id"],
            name="High Throughput Per Host",
            enabled=True,
            nrql={
                "query": "SELECT rate(count(*), 1 minute) FROM Transaction FACET host",
            },
            critical={
                "operator": "above",
                "threshold": 1000,
                "threshold_duration": 300,
                "threshold_occurrences": "all",
            },
            violation_time_limit_seconds=3600)
        high_error_rate_per_host = newrelic.NrqlAlertCondition("high_error_rate_per_host",
            policy_id=example["id"],
            name="High Error Rate Per Host",
            enabled=True,
            nrql={
                "query": "SELECT percentage(count(*), WHERE error IS true) FROM Transaction FACET host",
            },
            critical={
                "operator": "above",
                "threshold": 5,
                "threshold_duration": 300,
                "threshold_occurrences": "all",
            },
            violation_time_limit_seconds=3600)
        with_facets = newrelic.AlertCompoundCondition("with_facets",
            policy_id=example["id"],
            name="Host-Specific Alert",
            enabled=True,
            trigger_expression="A AND B",
            facet_matching_behavior="FACETS_MATCH",
            component_conditions=[
                {
                    "id": high_throughput_per_host.id,
                    "alias": "A",
                },
                {
                    "id": high_error_rate_per_host.id,
                    "alias": "B",
                },
            ])
        ```

        ## Additional Information

        ### Understanding Trigger Expressions

        Trigger expressions define the logical conditions under which your alert compound condition will activate. Valid operators are:

        - **AND** - Both conditions must be true
        - **OR** - Either condition must be true
        - **NOT** - Negates a condition
        - **Parentheses** - Group conditions for complex logic

        Examples:

        - `"A AND B"` - Activate when both A and B are in violation
        - `"A OR B"` - Activate when either A or B is in violation
        - `"A AND NOT B"` - Activate when A is in violation but B is not
        - `"(A AND B) OR C"` - Activate when both A and B are in violation, OR when C is in violation
        - `"A AND (B OR C) AND NOT D"` - Activate when A is in violation AND either B or C is in violation AND D is not in violation

        ### Facet Matching Behavior

        When your component NRQL conditions use FACET clauses:

        - **FACETS_IGNORED** (Default) - Facets are not taken into consideration when determining when the compound alert condition activates. If component conditions have violations (on any facet), the compound alert condition will activate based on the trigger expression.
        - **FACETS_MATCH** - The compound alert condition will activate only when shared facets have matching values. For example, if condition A fires for `host="server-1"` and condition B fires for `host="server-2"`, the compound alert condition will NOT activate because the facet values don't match.

        ### Threshold Duration

        The `threshold_duration` parameter controls how long the trigger expression must remain true before the compound alert condition will activate.

        ## Import

        Compound alert conditions can be imported using the condition ID, e.g.

        bash

        ```sh
        $ pulumi import newrelic:index/alertCompoundCondition:AlertCompoundCondition main 789012
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] account_id: The New Relic account ID for managing your compound alert conditions. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
        :param pulumi.Input[Sequence[pulumi.Input[Union['AlertCompoundConditionComponentConditionArgs', 'AlertCompoundConditionComponentConditionArgsDict']]]] component_conditions: The list of conditions to be combined. Each component condition must be enabled. Must include at least 2. See Component Conditions below for details.
        :param pulumi.Input[_builtins.bool] enabled: Whether or not the compound alert condition is enabled. Defaults to `true`.
        :param pulumi.Input[_builtins.str] facet_matching_behavior: How the compound condition will take into account the component conditions' facets during evaluation. Valid values are:
               - `FACETS_IGNORED` - (Default) Facets are not taken into consideration when determining when the compound alert condition activates
               - `FACETS_MATCH` - The compound alert condition will activate only when shared facets have matching values
        :param pulumi.Input[_builtins.str] name: The title of the compound alert condition.
        :param pulumi.Input[_builtins.str] policy_id: The ID of the policy where this alert compound condition should be used.
        :param pulumi.Input[_builtins.str] runbook_url: Runbook URL to display in notifications.
        :param pulumi.Input[_builtins.int] threshold_duration: The duration, in seconds, that the trigger expression must be true before the compound alert condition will activate. Between 30-86400 seconds.
        :param pulumi.Input[_builtins.str] trigger_expression: Expression that defines how component condition evaluations are combined. Valid operators are 'AND', 'OR', 'NOT'. For more complex expressions, use parentheses. Use the aliases from `component_conditions` to build expressions like `"A AND B"`, `"A OR B"`, `"(A AND B) OR C"`, or `"A AND (B OR C) AND NOT (D AND E)"`.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: AlertCompoundConditionArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Use this resource to create and manage compound alert conditions in New Relic. Compound conditions allow you to combine multiple alert conditions using logical expressions (AND, OR, NOT) to create more sophisticated alerting logic.

        ## Example Usage

        ### Basic Compound Condition (AND)

        ```python
        import pulumi
        import pulumi_newrelic as newrelic

        example = newrelic.AlertPolicy("example", name="my-policy")
        # Create component NRQL conditions
        high_response_time = newrelic.NrqlAlertCondition("high_response_time",
            policy_id=example.id,
            name="High Response Time",
            enabled=True,
            nrql={
                "query": "SELECT average(duration) FROM Transaction WHERE appName = 'MyApp'",
            },
            critical={
                "operator": "above",
                "threshold": 5,
                "threshold_duration": 300,
                "threshold_occurrences": "all",
            },
            violation_time_limit_seconds=3600)
        high_error_rate = newrelic.NrqlAlertCondition("high_error_rate",
            policy_id=example.id,
            name="High Error Rate",
            enabled=True,
            nrql={
                "query": "SELECT percentage(count(*), WHERE error IS true) FROM Transaction WHERE appName = 'MyApp'",
            },
            critical={
                "operator": "above",
                "threshold": 5,
                "threshold_duration": 300,
                "threshold_occurrences": "all",
            },
            violation_time_limit_seconds=3600)
        # Create alert compound condition combining both
        critical_service_health = newrelic.AlertCompoundCondition("critical_service_health",
            policy_id=example.id,
            name="Critical Service Health",
            enabled=True,
            trigger_expression="A AND B",
            runbook_url="https://example.com/runbooks/critical-health",
            threshold_duration=120,
            component_conditions=[
                {
                    "id": high_response_time.id,
                    "alias": "A",
                },
                {
                    "id": high_error_rate.id,
                    "alias": "B",
                },
            ],
            facet_matching_behavior="FACETS_IGNORED")
        ```

        ### Complex Condition with Three Components

        ```python
        import pulumi
        import pulumi_newrelic as newrelic

        high_cpu = newrelic.NrqlAlertCondition("high_cpu",
            policy_id=example["id"],
            name="High CPU",
            enabled=True,
            nrql={
                "query": "SELECT average(cpuPercent) FROM SystemSample WHERE hostname = 'myhost'",
            },
            critical={
                "operator": "above",
                "threshold": 80,
                "threshold_duration": 300,
                "threshold_occurrences": "all",
            },
            violation_time_limit_seconds=3600)
        high_memory = newrelic.NrqlAlertCondition("high_memory",
            policy_id=example["id"],
            name="High Memory",
            enabled=True,
            nrql={
                "query": "SELECT average(memoryUsedPercent) FROM SystemSample WHERE hostname = 'myhost'",
            },
            critical={
                "operator": "above",
                "threshold": 85,
                "threshold_duration": 300,
                "threshold_occurrences": "all",
            },
            violation_time_limit_seconds=3600)
        disk_full = newrelic.NrqlAlertCondition("disk_full",
            policy_id=example["id"],
            name="Disk Full",
            enabled=True,
            nrql={
                "query": "SELECT average(diskUsedPercent) FROM SystemSample WHERE hostname = 'myhost'",
            },
            critical={
                "operator": "above",
                "threshold": 90,
                "threshold_duration": 300,
                "threshold_occurrences": "all",
            },
            violation_time_limit_seconds=3600)
        complex = newrelic.AlertCompoundCondition("complex",
            policy_id=example["id"],
            name="Complex Infrastructure Alert",
            enabled=True,
            trigger_expression="(A AND B) OR C",
            component_conditions=[
                {
                    "id": high_cpu.id,
                    "alias": "A",
                },
                {
                    "id": high_memory.id,
                    "alias": "B",
                },
                {
                    "id": disk_full.id,
                    "alias": "C",
                },
            ])
        ```

        ### With Facet Matching

        ```python
        import pulumi
        import pulumi_newrelic as newrelic

        high_throughput_per_host = newrelic.NrqlAlertCondition("high_throughput_per_host",
            policy_id=example["id"],
            name="High Throughput Per Host",
            enabled=True,
            nrql={
                "query": "SELECT rate(count(*), 1 minute) FROM Transaction FACET host",
            },
            critical={
                "operator": "above",
                "threshold": 1000,
                "threshold_duration": 300,
                "threshold_occurrences": "all",
            },
            violation_time_limit_seconds=3600)
        high_error_rate_per_host = newrelic.NrqlAlertCondition("high_error_rate_per_host",
            policy_id=example["id"],
            name="High Error Rate Per Host",
            enabled=True,
            nrql={
                "query": "SELECT percentage(count(*), WHERE error IS true) FROM Transaction FACET host",
            },
            critical={
                "operator": "above",
                "threshold": 5,
                "threshold_duration": 300,
                "threshold_occurrences": "all",
            },
            violation_time_limit_seconds=3600)
        with_facets = newrelic.AlertCompoundCondition("with_facets",
            policy_id=example["id"],
            name="Host-Specific Alert",
            enabled=True,
            trigger_expression="A AND B",
            facet_matching_behavior="FACETS_MATCH",
            component_conditions=[
                {
                    "id": high_throughput_per_host.id,
                    "alias": "A",
                },
                {
                    "id": high_error_rate_per_host.id,
                    "alias": "B",
                },
            ])
        ```

        ## Additional Information

        ### Understanding Trigger Expressions

        Trigger expressions define the logical conditions under which your alert compound condition will activate. Valid operators are:

        - **AND** - Both conditions must be true
        - **OR** - Either condition must be true
        - **NOT** - Negates a condition
        - **Parentheses** - Group conditions for complex logic

        Examples:

        - `"A AND B"` - Activate when both A and B are in violation
        - `"A OR B"` - Activate when either A or B is in violation
        - `"A AND NOT B"` - Activate when A is in violation but B is not
        - `"(A AND B) OR C"` - Activate when both A and B are in violation, OR when C is in violation
        - `"A AND (B OR C) AND NOT D"` - Activate when A is in violation AND either B or C is in violation AND D is not in violation

        ### Facet Matching Behavior

        When your component NRQL conditions use FACET clauses:

        - **FACETS_IGNORED** (Default) - Facets are not taken into consideration when determining when the compound alert condition activates. If component conditions have violations (on any facet), the compound alert condition will activate based on the trigger expression.
        - **FACETS_MATCH** - The compound alert condition will activate only when shared facets have matching values. For example, if condition A fires for `host="server-1"` and condition B fires for `host="server-2"`, the compound alert condition will NOT activate because the facet values don't match.

        ### Threshold Duration

        The `threshold_duration` parameter controls how long the trigger expression must remain true before the compound alert condition will activate.

        ## Import

        Compound alert conditions can be imported using the condition ID, e.g.

        bash

        ```sh
        $ pulumi import newrelic:index/alertCompoundCondition:AlertCompoundCondition main 789012
        ```

        :param str resource_name: The name of the resource.
        :param AlertCompoundConditionArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(AlertCompoundConditionArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 component_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[Union['AlertCompoundConditionComponentConditionArgs', 'AlertCompoundConditionComponentConditionArgsDict']]]]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 facet_matching_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 runbook_url: Optional[pulumi.Input[_builtins.str]] = None,
                 threshold_duration: Optional[pulumi.Input[_builtins.int]] = None,
                 trigger_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = AlertCompoundConditionArgs.__new__(AlertCompoundConditionArgs)

            __props__.__dict__["account_id"] = account_id
            if component_conditions is None and not opts.urn:
                raise TypeError("Missing required property 'component_conditions'")
            __props__.__dict__["component_conditions"] = component_conditions
            if enabled is None and not opts.urn:
                raise TypeError("Missing required property 'enabled'")
            __props__.__dict__["enabled"] = enabled
            __props__.__dict__["facet_matching_behavior"] = facet_matching_behavior
            __props__.__dict__["name"] = name
            if policy_id is None and not opts.urn:
                raise TypeError("Missing required property 'policy_id'")
            __props__.__dict__["policy_id"] = policy_id
            __props__.__dict__["runbook_url"] = runbook_url
            __props__.__dict__["threshold_duration"] = threshold_duration
            if trigger_expression is None and not opts.urn:
                raise TypeError("Missing required property 'trigger_expression'")
            __props__.__dict__["trigger_expression"] = trigger_expression
        super(AlertCompoundCondition, __self__).__init__(
            'newrelic:index/alertCompoundCondition:AlertCompoundCondition',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            account_id: Optional[pulumi.Input[_builtins.str]] = None,
            component_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[Union['AlertCompoundConditionComponentConditionArgs', 'AlertCompoundConditionComponentConditionArgsDict']]]]] = None,
            enabled: Optional[pulumi.Input[_builtins.bool]] = None,
            facet_matching_behavior: Optional[pulumi.Input[_builtins.str]] = None,
            name: Optional[pulumi.Input[_builtins.str]] = None,
            policy_id: Optional[pulumi.Input[_builtins.str]] = None,
            runbook_url: Optional[pulumi.Input[_builtins.str]] = None,
            threshold_duration: Optional[pulumi.Input[_builtins.int]] = None,
            trigger_expression: Optional[pulumi.Input[_builtins.str]] = None) -> 'AlertCompoundCondition':
        """
        Get an existing AlertCompoundCondition resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] account_id: The New Relic account ID for managing your compound alert conditions. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
        :param pulumi.Input[Sequence[pulumi.Input[Union['AlertCompoundConditionComponentConditionArgs', 'AlertCompoundConditionComponentConditionArgsDict']]]] component_conditions: The list of conditions to be combined. Each component condition must be enabled. Must include at least 2. See Component Conditions below for details.
        :param pulumi.Input[_builtins.bool] enabled: Whether or not the compound alert condition is enabled. Defaults to `true`.
        :param pulumi.Input[_builtins.str] facet_matching_behavior: How the compound condition will take into account the component conditions' facets during evaluation. Valid values are:
               - `FACETS_IGNORED` - (Default) Facets are not taken into consideration when determining when the compound alert condition activates
               - `FACETS_MATCH` - The compound alert condition will activate only when shared facets have matching values
        :param pulumi.Input[_builtins.str] name: The title of the compound alert condition.
        :param pulumi.Input[_builtins.str] policy_id: The ID of the policy where this alert compound condition should be used.
        :param pulumi.Input[_builtins.str] runbook_url: Runbook URL to display in notifications.
        :param pulumi.Input[_builtins.int] threshold_duration: The duration, in seconds, that the trigger expression must be true before the compound alert condition will activate. Between 30-86400 seconds.
        :param pulumi.Input[_builtins.str] trigger_expression: Expression that defines how component condition evaluations are combined. Valid operators are 'AND', 'OR', 'NOT'. For more complex expressions, use parentheses. Use the aliases from `component_conditions` to build expressions like `"A AND B"`, `"A OR B"`, `"(A AND B) OR C"`, or `"A AND (B OR C) AND NOT (D AND E)"`.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _AlertCompoundConditionState.__new__(_AlertCompoundConditionState)

        __props__.__dict__["account_id"] = account_id
        __props__.__dict__["component_conditions"] = component_conditions
        __props__.__dict__["enabled"] = enabled
        __props__.__dict__["facet_matching_behavior"] = facet_matching_behavior
        __props__.__dict__["name"] = name
        __props__.__dict__["policy_id"] = policy_id
        __props__.__dict__["runbook_url"] = runbook_url
        __props__.__dict__["threshold_duration"] = threshold_duration
        __props__.__dict__["trigger_expression"] = trigger_expression
        return AlertCompoundCondition(resource_name, opts=opts, __props__=__props__)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> pulumi.Output[_builtins.str]:
        """
        The New Relic account ID for managing your compound alert conditions. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
        """
        return pulumi.get(self, "account_id")

    @_builtins.property
    @pulumi.getter(name="componentConditions")
    def component_conditions(self) -> pulumi.Output[Sequence['outputs.AlertCompoundConditionComponentCondition']]:
        """
        The list of conditions to be combined. Each component condition must be enabled. Must include at least 2. See Component Conditions below for details.
        """
        return pulumi.get(self, "component_conditions")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Output[_builtins.bool]:
        """
        Whether or not the compound alert condition is enabled. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="facetMatchingBehavior")
    def facet_matching_behavior(self) -> pulumi.Output[_builtins.str]:
        """
        How the compound condition will take into account the component conditions' facets during evaluation. Valid values are:
        - `FACETS_IGNORED` - (Default) Facets are not taken into consideration when determining when the compound alert condition activates
        - `FACETS_MATCH` - The compound alert condition will activate only when shared facets have matching values
        """
        return pulumi.get(self, "facet_matching_behavior")

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Output[_builtins.str]:
        """
        The title of the compound alert condition.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> pulumi.Output[_builtins.str]:
        """
        The ID of the policy where this alert compound condition should be used.
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="runbookUrl")
    def runbook_url(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        Runbook URL to display in notifications.
        """
        return pulumi.get(self, "runbook_url")

    @_builtins.property
    @pulumi.getter(name="thresholdDuration")
    def threshold_duration(self) -> pulumi.Output[_builtins.int]:
        """
        The duration, in seconds, that the trigger expression must be true before the compound alert condition will activate. Between 30-86400 seconds.
        """
        return pulumi.get(self, "threshold_duration")

    @_builtins.property
    @pulumi.getter(name="triggerExpression")
    def trigger_expression(self) -> pulumi.Output[_builtins.str]:
        """
        Expression that defines how component condition evaluations are combined. Valid operators are 'AND', 'OR', 'NOT'. For more complex expressions, use parentheses. Use the aliases from `component_conditions` to build expressions like `"A AND B"`, `"A OR B"`, `"(A AND B) OR C"`, or `"A AND (B OR C) AND NOT (D AND E)"`.
        """
        return pulumi.get(self, "trigger_expression")

