# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AwsGovcloudIntegrationsAlbArgs',
    'AwsGovcloudIntegrationsAlbArgsDict',
    'AwsGovcloudIntegrationsApiGatewayArgs',
    'AwsGovcloudIntegrationsApiGatewayArgsDict',
    'AwsGovcloudIntegrationsAutoScalingArgs',
    'AwsGovcloudIntegrationsAutoScalingArgsDict',
    'AwsGovcloudIntegrationsAwsDirectConnectArgs',
    'AwsGovcloudIntegrationsAwsDirectConnectArgsDict',
    'AwsGovcloudIntegrationsAwsStatesArgs',
    'AwsGovcloudIntegrationsAwsStatesArgsDict',
    'AwsGovcloudIntegrationsCloudtrailArgs',
    'AwsGovcloudIntegrationsCloudtrailArgsDict',
    'AwsGovcloudIntegrationsDynamoDbArgs',
    'AwsGovcloudIntegrationsDynamoDbArgsDict',
    'AwsGovcloudIntegrationsEbsArgs',
    'AwsGovcloudIntegrationsEbsArgsDict',
    'AwsGovcloudIntegrationsEc2Args',
    'AwsGovcloudIntegrationsEc2ArgsDict',
    'AwsGovcloudIntegrationsElasticSearchArgs',
    'AwsGovcloudIntegrationsElasticSearchArgsDict',
    'AwsGovcloudIntegrationsElbArgs',
    'AwsGovcloudIntegrationsElbArgsDict',
    'AwsGovcloudIntegrationsEmrArgs',
    'AwsGovcloudIntegrationsEmrArgsDict',
    'AwsGovcloudIntegrationsIamArgs',
    'AwsGovcloudIntegrationsIamArgsDict',
    'AwsGovcloudIntegrationsLambdaArgs',
    'AwsGovcloudIntegrationsLambdaArgsDict',
    'AwsGovcloudIntegrationsRdsArgs',
    'AwsGovcloudIntegrationsRdsArgsDict',
    'AwsGovcloudIntegrationsRedShiftArgs',
    'AwsGovcloudIntegrationsRedShiftArgsDict',
    'AwsGovcloudIntegrationsRoute53Args',
    'AwsGovcloudIntegrationsRoute53ArgsDict',
    'AwsGovcloudIntegrationsS3Args',
    'AwsGovcloudIntegrationsS3ArgsDict',
    'AwsGovcloudIntegrationsSnsArgs',
    'AwsGovcloudIntegrationsSnsArgsDict',
    'AwsGovcloudIntegrationsSqsArgs',
    'AwsGovcloudIntegrationsSqsArgsDict',
    'AwsIntegrationsAlbArgs',
    'AwsIntegrationsAlbArgsDict',
    'AwsIntegrationsApiGatewayArgs',
    'AwsIntegrationsApiGatewayArgsDict',
    'AwsIntegrationsAutoScalingArgs',
    'AwsIntegrationsAutoScalingArgsDict',
    'AwsIntegrationsAwsAppSyncArgs',
    'AwsIntegrationsAwsAppSyncArgsDict',
    'AwsIntegrationsAwsAthenaArgs',
    'AwsIntegrationsAwsAthenaArgsDict',
    'AwsIntegrationsAwsCognitoArgs',
    'AwsIntegrationsAwsCognitoArgsDict',
    'AwsIntegrationsAwsConnectArgs',
    'AwsIntegrationsAwsConnectArgsDict',
    'AwsIntegrationsAwsDirectConnectArgs',
    'AwsIntegrationsAwsDirectConnectArgsDict',
    'AwsIntegrationsAwsFsxArgs',
    'AwsIntegrationsAwsFsxArgsDict',
    'AwsIntegrationsAwsGlueArgs',
    'AwsIntegrationsAwsGlueArgsDict',
    'AwsIntegrationsAwsKinesisAnalyticsArgs',
    'AwsIntegrationsAwsKinesisAnalyticsArgsDict',
    'AwsIntegrationsAwsMediaConvertArgs',
    'AwsIntegrationsAwsMediaConvertArgsDict',
    'AwsIntegrationsAwsMediaPackageVodArgs',
    'AwsIntegrationsAwsMediaPackageVodArgsDict',
    'AwsIntegrationsAwsMqArgs',
    'AwsIntegrationsAwsMqArgsDict',
    'AwsIntegrationsAwsMskArgs',
    'AwsIntegrationsAwsMskArgsDict',
    'AwsIntegrationsAwsNeptuneArgs',
    'AwsIntegrationsAwsNeptuneArgsDict',
    'AwsIntegrationsAwsQldbArgs',
    'AwsIntegrationsAwsQldbArgsDict',
    'AwsIntegrationsAwsRoute53resolverArgs',
    'AwsIntegrationsAwsRoute53resolverArgsDict',
    'AwsIntegrationsAwsStatesArgs',
    'AwsIntegrationsAwsStatesArgsDict',
    'AwsIntegrationsAwsTransitGatewayArgs',
    'AwsIntegrationsAwsTransitGatewayArgsDict',
    'AwsIntegrationsAwsWafArgs',
    'AwsIntegrationsAwsWafArgsDict',
    'AwsIntegrationsAwsWafv2Args',
    'AwsIntegrationsAwsWafv2ArgsDict',
    'AwsIntegrationsBillingArgs',
    'AwsIntegrationsBillingArgsDict',
    'AwsIntegrationsCloudfrontArgs',
    'AwsIntegrationsCloudfrontArgsDict',
    'AwsIntegrationsCloudtrailArgs',
    'AwsIntegrationsCloudtrailArgsDict',
    'AwsIntegrationsDocDbArgs',
    'AwsIntegrationsDocDbArgsDict',
    'AwsIntegrationsDynamodbArgs',
    'AwsIntegrationsDynamodbArgsDict',
    'AwsIntegrationsEbsArgs',
    'AwsIntegrationsEbsArgsDict',
    'AwsIntegrationsEc2Args',
    'AwsIntegrationsEc2ArgsDict',
    'AwsIntegrationsEcsArgs',
    'AwsIntegrationsEcsArgsDict',
    'AwsIntegrationsEfsArgs',
    'AwsIntegrationsEfsArgsDict',
    'AwsIntegrationsElasticacheArgs',
    'AwsIntegrationsElasticacheArgsDict',
    'AwsIntegrationsElasticbeanstalkArgs',
    'AwsIntegrationsElasticbeanstalkArgsDict',
    'AwsIntegrationsElasticsearchArgs',
    'AwsIntegrationsElasticsearchArgsDict',
    'AwsIntegrationsElbArgs',
    'AwsIntegrationsElbArgsDict',
    'AwsIntegrationsEmrArgs',
    'AwsIntegrationsEmrArgsDict',
    'AwsIntegrationsHealthArgs',
    'AwsIntegrationsHealthArgsDict',
    'AwsIntegrationsIamArgs',
    'AwsIntegrationsIamArgsDict',
    'AwsIntegrationsIotArgs',
    'AwsIntegrationsIotArgsDict',
    'AwsIntegrationsKinesisArgs',
    'AwsIntegrationsKinesisArgsDict',
    'AwsIntegrationsKinesisFirehoseArgs',
    'AwsIntegrationsKinesisFirehoseArgsDict',
    'AwsIntegrationsLambdaArgs',
    'AwsIntegrationsLambdaArgsDict',
    'AwsIntegrationsRdsArgs',
    'AwsIntegrationsRdsArgsDict',
    'AwsIntegrationsRedshiftArgs',
    'AwsIntegrationsRedshiftArgsDict',
    'AwsIntegrationsRoute53Args',
    'AwsIntegrationsRoute53ArgsDict',
    'AwsIntegrationsS3Args',
    'AwsIntegrationsS3ArgsDict',
    'AwsIntegrationsSesArgs',
    'AwsIntegrationsSesArgsDict',
    'AwsIntegrationsSnsArgs',
    'AwsIntegrationsSnsArgsDict',
    'AwsIntegrationsSqsArgs',
    'AwsIntegrationsSqsArgsDict',
    'AwsIntegrationsTrustedAdvisorArgs',
    'AwsIntegrationsTrustedAdvisorArgsDict',
    'AwsIntegrationsVpcArgs',
    'AwsIntegrationsVpcArgsDict',
    'AwsIntegrationsXRayArgs',
    'AwsIntegrationsXRayArgsDict',
    'AzureIntegrationsApiManagementArgs',
    'AzureIntegrationsApiManagementArgsDict',
    'AzureIntegrationsAppGatewayArgs',
    'AzureIntegrationsAppGatewayArgsDict',
    'AzureIntegrationsAppServiceArgs',
    'AzureIntegrationsAppServiceArgsDict',
    'AzureIntegrationsContainersArgs',
    'AzureIntegrationsContainersArgsDict',
    'AzureIntegrationsCosmosDbArgs',
    'AzureIntegrationsCosmosDbArgsDict',
    'AzureIntegrationsCostManagementArgs',
    'AzureIntegrationsCostManagementArgsDict',
    'AzureIntegrationsDataFactoryArgs',
    'AzureIntegrationsDataFactoryArgsDict',
    'AzureIntegrationsEventHubArgs',
    'AzureIntegrationsEventHubArgsDict',
    'AzureIntegrationsExpressRouteArgs',
    'AzureIntegrationsExpressRouteArgsDict',
    'AzureIntegrationsFirewallsArgs',
    'AzureIntegrationsFirewallsArgsDict',
    'AzureIntegrationsFrontDoorArgs',
    'AzureIntegrationsFrontDoorArgsDict',
    'AzureIntegrationsFunctionsArgs',
    'AzureIntegrationsFunctionsArgsDict',
    'AzureIntegrationsKeyVaultArgs',
    'AzureIntegrationsKeyVaultArgsDict',
    'AzureIntegrationsLoadBalancerArgs',
    'AzureIntegrationsLoadBalancerArgsDict',
    'AzureIntegrationsLogicAppsArgs',
    'AzureIntegrationsLogicAppsArgsDict',
    'AzureIntegrationsMachineLearningArgs',
    'AzureIntegrationsMachineLearningArgsDict',
    'AzureIntegrationsMariaDbArgs',
    'AzureIntegrationsMariaDbArgsDict',
    'AzureIntegrationsMonitorArgs',
    'AzureIntegrationsMonitorArgsDict',
    'AzureIntegrationsMysqlArgs',
    'AzureIntegrationsMysqlArgsDict',
    'AzureIntegrationsMysqlFlexibleArgs',
    'AzureIntegrationsMysqlFlexibleArgsDict',
    'AzureIntegrationsPostgresqlArgs',
    'AzureIntegrationsPostgresqlArgsDict',
    'AzureIntegrationsPostgresqlFlexibleArgs',
    'AzureIntegrationsPostgresqlFlexibleArgsDict',
    'AzureIntegrationsPowerBiDedicatedArgs',
    'AzureIntegrationsPowerBiDedicatedArgsDict',
    'AzureIntegrationsRedisCacheArgs',
    'AzureIntegrationsRedisCacheArgsDict',
    'AzureIntegrationsServiceBusArgs',
    'AzureIntegrationsServiceBusArgsDict',
    'AzureIntegrationsSqlArgs',
    'AzureIntegrationsSqlArgsDict',
    'AzureIntegrationsSqlManagedArgs',
    'AzureIntegrationsSqlManagedArgsDict',
    'AzureIntegrationsStorageArgs',
    'AzureIntegrationsStorageArgsDict',
    'AzureIntegrationsVirtualMachineArgs',
    'AzureIntegrationsVirtualMachineArgsDict',
    'AzureIntegrationsVirtualNetworksArgs',
    'AzureIntegrationsVirtualNetworksArgsDict',
    'AzureIntegrationsVmsArgs',
    'AzureIntegrationsVmsArgsDict',
    'AzureIntegrationsVpnGatewayArgs',
    'AzureIntegrationsVpnGatewayArgsDict',
    'GcpIntegrationsAlloyDbArgs',
    'GcpIntegrationsAlloyDbArgsDict',
    'GcpIntegrationsAppEngineArgs',
    'GcpIntegrationsAppEngineArgsDict',
    'GcpIntegrationsBigQueryArgs',
    'GcpIntegrationsBigQueryArgsDict',
    'GcpIntegrationsBigTableArgs',
    'GcpIntegrationsBigTableArgsDict',
    'GcpIntegrationsComposerArgs',
    'GcpIntegrationsComposerArgsDict',
    'GcpIntegrationsDataFlowArgs',
    'GcpIntegrationsDataFlowArgsDict',
    'GcpIntegrationsDataProcArgs',
    'GcpIntegrationsDataProcArgsDict',
    'GcpIntegrationsDataStoreArgs',
    'GcpIntegrationsDataStoreArgsDict',
    'GcpIntegrationsFireBaseDatabaseArgs',
    'GcpIntegrationsFireBaseDatabaseArgsDict',
    'GcpIntegrationsFireBaseHostingArgs',
    'GcpIntegrationsFireBaseHostingArgsDict',
    'GcpIntegrationsFireBaseStorageArgs',
    'GcpIntegrationsFireBaseStorageArgsDict',
    'GcpIntegrationsFireStoreArgs',
    'GcpIntegrationsFireStoreArgsDict',
    'GcpIntegrationsFunctionsArgs',
    'GcpIntegrationsFunctionsArgsDict',
    'GcpIntegrationsInterconnectArgs',
    'GcpIntegrationsInterconnectArgsDict',
    'GcpIntegrationsKubernetesArgs',
    'GcpIntegrationsKubernetesArgsDict',
    'GcpIntegrationsLoadBalancingArgs',
    'GcpIntegrationsLoadBalancingArgsDict',
    'GcpIntegrationsMemCacheArgs',
    'GcpIntegrationsMemCacheArgsDict',
    'GcpIntegrationsPubSubArgs',
    'GcpIntegrationsPubSubArgsDict',
    'GcpIntegrationsRedisArgs',
    'GcpIntegrationsRedisArgsDict',
    'GcpIntegrationsRouterArgs',
    'GcpIntegrationsRouterArgsDict',
    'GcpIntegrationsRunArgs',
    'GcpIntegrationsRunArgsDict',
    'GcpIntegrationsSpannerArgs',
    'GcpIntegrationsSpannerArgsDict',
    'GcpIntegrationsSqlArgs',
    'GcpIntegrationsSqlArgsDict',
    'GcpIntegrationsStorageArgs',
    'GcpIntegrationsStorageArgsDict',
    'GcpIntegrationsVirtualMachinesArgs',
    'GcpIntegrationsVirtualMachinesArgsDict',
    'GcpIntegrationsVpcAccessArgs',
    'GcpIntegrationsVpcAccessArgsDict',
]

MYPY = False

if not MYPY:
    class AwsGovcloudIntegrationsAlbArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        fetch_extended_inventory: NotRequired[pulumi.Input[bool]]
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        load_balancer_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each name or prefix for the LBs that you want to monitor. Filter values are case-sensitive.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsGovcloudIntegrationsAlbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsGovcloudIntegrationsAlbArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_extended_inventory: Optional[pulumi.Input[bool]] = None,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 load_balancer_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor
        :param pulumi.Input[bool] fetch_extended_inventory: Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[bool] fetch_tags: Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] load_balancer_prefixes: Specify each name or prefix for the LBs that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_extended_inventory is not None:
            pulumi.set(__self__, "fetch_extended_inventory", fetch_extended_inventory)
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if load_balancer_prefixes is not None:
            pulumi.set(__self__, "load_balancer_prefixes", load_balancer_prefixes)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchExtendedInventory")
    def fetch_extended_inventory(self) -> Optional[pulumi.Input[bool]]:
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_extended_inventory")

    @fetch_extended_inventory.setter
    def fetch_extended_inventory(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_extended_inventory", value)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="loadBalancerPrefixes")
    def load_balancer_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each name or prefix for the LBs that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "load_balancer_prefixes")

    @load_balancer_prefixes.setter
    def load_balancer_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "load_balancer_prefixes", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsGovcloudIntegrationsApiGatewayArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        stage_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsGovcloudIntegrationsApiGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsGovcloudIntegrationsApiGatewayArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 stage_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] stage_prefixes: Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if stage_prefixes is not None:
            pulumi.set(__self__, "stage_prefixes", stage_prefixes)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="stagePrefixes")
    def stage_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "stage_prefixes")

    @stage_prefixes.setter
    def stage_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "stage_prefixes", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsGovcloudIntegrationsAutoScalingArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
elif False:
    AwsGovcloudIntegrationsAutoScalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsGovcloudIntegrationsAutoScalingArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsGovcloudIntegrationsAwsDirectConnectArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
elif False:
    AwsGovcloudIntegrationsAwsDirectConnectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsGovcloudIntegrationsAwsDirectConnectArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsGovcloudIntegrationsAwsStatesArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
elif False:
    AwsGovcloudIntegrationsAwsStatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsGovcloudIntegrationsAwsStatesArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsGovcloudIntegrationsCloudtrailArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
elif False:
    AwsGovcloudIntegrationsCloudtrailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsGovcloudIntegrationsCloudtrailArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsGovcloudIntegrationsDynamoDbArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        fetch_extended_inventory: NotRequired[pulumi.Input[bool]]
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsGovcloudIntegrationsDynamoDbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsGovcloudIntegrationsDynamoDbArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_extended_inventory: Optional[pulumi.Input[bool]] = None,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor
        :param pulumi.Input[bool] fetch_extended_inventory: Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[bool] fetch_tags: Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_extended_inventory is not None:
            pulumi.set(__self__, "fetch_extended_inventory", fetch_extended_inventory)
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchExtendedInventory")
    def fetch_extended_inventory(self) -> Optional[pulumi.Input[bool]]:
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_extended_inventory")

    @fetch_extended_inventory.setter
    def fetch_extended_inventory(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_extended_inventory", value)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsGovcloudIntegrationsEbsArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        fetch_extended_inventory: NotRequired[pulumi.Input[bool]]
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsGovcloudIntegrationsEbsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsGovcloudIntegrationsEbsArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_extended_inventory: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor
        :param pulumi.Input[bool] fetch_extended_inventory: Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_extended_inventory is not None:
            pulumi.set(__self__, "fetch_extended_inventory", fetch_extended_inventory)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchExtendedInventory")
    def fetch_extended_inventory(self) -> Optional[pulumi.Input[bool]]:
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_extended_inventory")

    @fetch_extended_inventory.setter
    def fetch_extended_inventory(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_extended_inventory", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsGovcloudIntegrationsEc2ArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        fetch_ip_addresses: NotRequired[pulumi.Input[bool]]
        """
        Specify if IP addresses of ec2 instance should be collected
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsGovcloudIntegrationsEc2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsGovcloudIntegrationsEc2Args:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_ip_addresses: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor
        :param pulumi.Input[bool] fetch_ip_addresses: Specify if IP addresses of ec2 instance should be collected
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_ip_addresses is not None:
            pulumi.set(__self__, "fetch_ip_addresses", fetch_ip_addresses)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchIpAddresses")
    def fetch_ip_addresses(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if IP addresses of ec2 instance should be collected
        """
        return pulumi.get(self, "fetch_ip_addresses")

    @fetch_ip_addresses.setter
    def fetch_ip_addresses(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_ip_addresses", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsGovcloudIntegrationsElasticSearchArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        fetch_nodes: NotRequired[pulumi.Input[bool]]
        """
        Specify if IP addresses of ec2 instance should be collected
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsGovcloudIntegrationsElasticSearchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsGovcloudIntegrationsElasticSearchArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_nodes: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor
        :param pulumi.Input[bool] fetch_nodes: Specify if IP addresses of ec2 instance should be collected
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_nodes is not None:
            pulumi.set(__self__, "fetch_nodes", fetch_nodes)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchNodes")
    def fetch_nodes(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if IP addresses of ec2 instance should be collected
        """
        return pulumi.get(self, "fetch_nodes")

    @fetch_nodes.setter
    def fetch_nodes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_nodes", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsGovcloudIntegrationsElbArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        fetch_extended_inventory: NotRequired[pulumi.Input[bool]]
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
elif False:
    AwsGovcloudIntegrationsElbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsGovcloudIntegrationsElbArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_extended_inventory: Optional[pulumi.Input[bool]] = None,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor
        :param pulumi.Input[bool] fetch_extended_inventory: Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[bool] fetch_tags: Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_extended_inventory is not None:
            pulumi.set(__self__, "fetch_extended_inventory", fetch_extended_inventory)
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchExtendedInventory")
    def fetch_extended_inventory(self) -> Optional[pulumi.Input[bool]]:
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_extended_inventory")

    @fetch_extended_inventory.setter
    def fetch_extended_inventory(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_extended_inventory", value)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsGovcloudIntegrationsEmrArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[str]]
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsGovcloudIntegrationsEmrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsGovcloudIntegrationsEmrArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[str]] = None,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aws_regions: Specify each AWS region that includes the resources that you want to monitor
        :param pulumi.Input[bool] fetch_tags: Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[str]]:
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsGovcloudIntegrationsIamArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsGovcloudIntegrationsIamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsGovcloudIntegrationsIamArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsGovcloudIntegrationsLambdaArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsGovcloudIntegrationsLambdaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsGovcloudIntegrationsLambdaArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor
        :param pulumi.Input[bool] fetch_tags: Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsGovcloudIntegrationsRdsArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsGovcloudIntegrationsRdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsGovcloudIntegrationsRdsArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor
        :param pulumi.Input[bool] fetch_tags: Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsGovcloudIntegrationsRedShiftArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsGovcloudIntegrationsRedShiftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsGovcloudIntegrationsRedShiftArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsGovcloudIntegrationsRoute53ArgsDict(TypedDict):
        fetch_extended_inventory: NotRequired[pulumi.Input[bool]]
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
elif False:
    AwsGovcloudIntegrationsRoute53ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsGovcloudIntegrationsRoute53Args:
    def __init__(__self__, *,
                 fetch_extended_inventory: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] fetch_extended_inventory: Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        """
        if fetch_extended_inventory is not None:
            pulumi.set(__self__, "fetch_extended_inventory", fetch_extended_inventory)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="fetchExtendedInventory")
    def fetch_extended_inventory(self) -> Optional[pulumi.Input[bool]]:
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_extended_inventory")

    @fetch_extended_inventory.setter
    def fetch_extended_inventory(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_extended_inventory", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsGovcloudIntegrationsS3ArgsDict(TypedDict):
        fetch_extended_inventory: NotRequired[pulumi.Input[bool]]
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsGovcloudIntegrationsS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsGovcloudIntegrationsS3Args:
    def __init__(__self__, *,
                 fetch_extended_inventory: Optional[pulumi.Input[bool]] = None,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] fetch_extended_inventory: Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[bool] fetch_tags: Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if fetch_extended_inventory is not None:
            pulumi.set(__self__, "fetch_extended_inventory", fetch_extended_inventory)
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="fetchExtendedInventory")
    def fetch_extended_inventory(self) -> Optional[pulumi.Input[bool]]:
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_extended_inventory")

    @fetch_extended_inventory.setter
    def fetch_extended_inventory(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_extended_inventory", value)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsGovcloudIntegrationsSnsArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        fetch_extended_inventory: NotRequired[pulumi.Input[bool]]
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
elif False:
    AwsGovcloudIntegrationsSnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsGovcloudIntegrationsSnsArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_extended_inventory: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor
        :param pulumi.Input[bool] fetch_extended_inventory: Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_extended_inventory is not None:
            pulumi.set(__self__, "fetch_extended_inventory", fetch_extended_inventory)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchExtendedInventory")
    def fetch_extended_inventory(self) -> Optional[pulumi.Input[bool]]:
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_extended_inventory")

    @fetch_extended_inventory.setter
    def fetch_extended_inventory(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_extended_inventory", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsGovcloudIntegrationsSqsArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        fetch_extended_inventory: NotRequired[pulumi.Input[bool]]
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        queue_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each name or prefix for the Queues that you want to monitor. Filter values are case-sensitive.
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsGovcloudIntegrationsSqsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsGovcloudIntegrationsSqsArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_extended_inventory: Optional[pulumi.Input[bool]] = None,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 queue_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor
        :param pulumi.Input[bool] fetch_extended_inventory: Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[bool] fetch_tags: Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] queue_prefixes: Specify each name or prefix for the Queues that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_extended_inventory is not None:
            pulumi.set(__self__, "fetch_extended_inventory", fetch_extended_inventory)
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if queue_prefixes is not None:
            pulumi.set(__self__, "queue_prefixes", queue_prefixes)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchExtendedInventory")
    def fetch_extended_inventory(self) -> Optional[pulumi.Input[bool]]:
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_extended_inventory")

    @fetch_extended_inventory.setter
    def fetch_extended_inventory(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_extended_inventory", value)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="queuePrefixes")
    def queue_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each name or prefix for the Queues that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "queue_prefixes")

    @queue_prefixes.setter
    def queue_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "queue_prefixes", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsIntegrationsAlbArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        fetch_extended_inventory: NotRequired[pulumi.Input[bool]]
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        load_balancer_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each name or prefix for the LBs that you want to monitor. Filter values are case-sensitive.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsIntegrationsAlbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsAlbArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_extended_inventory: Optional[pulumi.Input[bool]] = None,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 load_balancer_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[bool] fetch_extended_inventory: Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[bool] fetch_tags: Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] load_balancer_prefixes: Specify each name or prefix for the LBs that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_extended_inventory is not None:
            pulumi.set(__self__, "fetch_extended_inventory", fetch_extended_inventory)
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if load_balancer_prefixes is not None:
            pulumi.set(__self__, "load_balancer_prefixes", load_balancer_prefixes)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchExtendedInventory")
    def fetch_extended_inventory(self) -> Optional[pulumi.Input[bool]]:
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_extended_inventory")

    @fetch_extended_inventory.setter
    def fetch_extended_inventory(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_extended_inventory", value)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="loadBalancerPrefixes")
    def load_balancer_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each name or prefix for the LBs that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "load_balancer_prefixes")

    @load_balancer_prefixes.setter
    def load_balancer_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "load_balancer_prefixes", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsIntegrationsApiGatewayArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
        stage_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsIntegrationsApiGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsApiGatewayArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 stage_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] stage_prefixes: Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if stage_prefixes is not None:
            pulumi.set(__self__, "stage_prefixes", stage_prefixes)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="stagePrefixes")
    def stage_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "stage_prefixes")

    @stage_prefixes.setter
    def stage_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "stage_prefixes", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsIntegrationsAutoScalingArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsAutoScalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsAutoScalingArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsAwsAppSyncArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsAwsAppSyncArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsAwsAppSyncArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsAwsAthenaArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsAwsAthenaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsAwsAthenaArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsAwsCognitoArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsAwsCognitoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsAwsCognitoArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsAwsConnectArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsAwsConnectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsAwsConnectArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsAwsDirectConnectArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsAwsDirectConnectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsAwsDirectConnectArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsAwsFsxArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsAwsFsxArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsAwsFsxArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsAwsGlueArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsAwsGlueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsAwsGlueArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsAwsKinesisAnalyticsArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsAwsKinesisAnalyticsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsAwsKinesisAnalyticsArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsAwsMediaConvertArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsAwsMediaConvertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsAwsMediaConvertArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsAwsMediaPackageVodArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsAwsMediaPackageVodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsAwsMediaPackageVodArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsAwsMqArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsAwsMqArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsAwsMqArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsAwsMskArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsAwsMskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsAwsMskArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsAwsNeptuneArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsAwsNeptuneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsAwsNeptuneArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsAwsQldbArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsAwsQldbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsAwsQldbArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsAwsRoute53resolverArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsAwsRoute53resolverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsAwsRoute53resolverArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsAwsStatesArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsAwsStatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsAwsStatesArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsAwsTransitGatewayArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsAwsTransitGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsAwsTransitGatewayArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsAwsWafArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsAwsWafArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsAwsWafArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsAwsWafv2ArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsAwsWafv2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsAwsWafv2Args:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsBillingArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsBillingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsBillingArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsCloudfrontArgsDict(TypedDict):
        fetch_lambdas_at_edge: NotRequired[pulumi.Input[bool]]
        """
        Specify if Lambdas@Edge should be monitored. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsIntegrationsCloudfrontArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsCloudfrontArgs:
    def __init__(__self__, *,
                 fetch_lambdas_at_edge: Optional[pulumi.Input[bool]] = None,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] fetch_lambdas_at_edge: Specify if Lambdas@Edge should be monitored. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[bool] fetch_tags: Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if fetch_lambdas_at_edge is not None:
            pulumi.set(__self__, "fetch_lambdas_at_edge", fetch_lambdas_at_edge)
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="fetchLambdasAtEdge")
    def fetch_lambdas_at_edge(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if Lambdas@Edge should be monitored. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_lambdas_at_edge")

    @fetch_lambdas_at_edge.setter
    def fetch_lambdas_at_edge(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_lambdas_at_edge", value)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsIntegrationsCloudtrailArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsCloudtrailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsCloudtrailArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsDocDbArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsDocDbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsDocDbArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsDynamodbArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        fetch_extended_inventory: NotRequired[pulumi.Input[bool]]
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsIntegrationsDynamodbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsDynamodbArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_extended_inventory: Optional[pulumi.Input[bool]] = None,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[bool] fetch_extended_inventory: Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[bool] fetch_tags: Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_extended_inventory is not None:
            pulumi.set(__self__, "fetch_extended_inventory", fetch_extended_inventory)
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchExtendedInventory")
    def fetch_extended_inventory(self) -> Optional[pulumi.Input[bool]]:
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_extended_inventory")

    @fetch_extended_inventory.setter
    def fetch_extended_inventory(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_extended_inventory", value)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsIntegrationsEbsArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        fetch_extended_inventory: NotRequired[pulumi.Input[bool]]
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsIntegrationsEbsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsEbsArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_extended_inventory: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[bool] fetch_extended_inventory: Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_extended_inventory is not None:
            pulumi.set(__self__, "fetch_extended_inventory", fetch_extended_inventory)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchExtendedInventory")
    def fetch_extended_inventory(self) -> Optional[pulumi.Input[bool]]:
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_extended_inventory")

    @fetch_extended_inventory.setter
    def fetch_extended_inventory(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_extended_inventory", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsIntegrationsEc2ArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        duplicate_ec2_tags: NotRequired[pulumi.Input[bool]]
        """
        Specify if the old legacy metadata and tag names have to be kept, it will consume more ingest data size
        """
        fetch_ip_addresses: NotRequired[pulumi.Input[bool]]
        """
        Specify if IP addresses of ec2 instance should be collected
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsIntegrationsEc2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsEc2Args:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 duplicate_ec2_tags: Optional[pulumi.Input[bool]] = None,
                 fetch_ip_addresses: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[bool] duplicate_ec2_tags: Specify if the old legacy metadata and tag names have to be kept, it will consume more ingest data size
        :param pulumi.Input[bool] fetch_ip_addresses: Specify if IP addresses of ec2 instance should be collected
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if duplicate_ec2_tags is not None:
            pulumi.set(__self__, "duplicate_ec2_tags", duplicate_ec2_tags)
        if fetch_ip_addresses is not None:
            pulumi.set(__self__, "fetch_ip_addresses", fetch_ip_addresses)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="duplicateEc2Tags")
    def duplicate_ec2_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if the old legacy metadata and tag names have to be kept, it will consume more ingest data size
        """
        return pulumi.get(self, "duplicate_ec2_tags")

    @duplicate_ec2_tags.setter
    def duplicate_ec2_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "duplicate_ec2_tags", value)

    @property
    @pulumi.getter(name="fetchIpAddresses")
    def fetch_ip_addresses(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if IP addresses of ec2 instance should be collected
        """
        return pulumi.get(self, "fetch_ip_addresses")

    @fetch_ip_addresses.setter
    def fetch_ip_addresses(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_ip_addresses", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsIntegrationsEcsArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsIntegrationsEcsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsEcsArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[bool] fetch_tags: Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsIntegrationsEfsArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsIntegrationsEfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsEfsArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[bool] fetch_tags: Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsIntegrationsElasticacheArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsIntegrationsElasticacheArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsElasticacheArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[bool] fetch_tags: Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsIntegrationsElasticbeanstalkArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        fetch_extended_inventory: NotRequired[pulumi.Input[bool]]
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsIntegrationsElasticbeanstalkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsElasticbeanstalkArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_extended_inventory: Optional[pulumi.Input[bool]] = None,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[bool] fetch_extended_inventory: Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[bool] fetch_tags: Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_extended_inventory is not None:
            pulumi.set(__self__, "fetch_extended_inventory", fetch_extended_inventory)
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchExtendedInventory")
    def fetch_extended_inventory(self) -> Optional[pulumi.Input[bool]]:
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_extended_inventory")

    @fetch_extended_inventory.setter
    def fetch_extended_inventory(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_extended_inventory", value)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsIntegrationsElasticsearchArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        fetch_nodes: NotRequired[pulumi.Input[bool]]
        """
        Specify if metrics should be collected for nodes. Turning it on will increase the number of API calls made to CloudWatch.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsIntegrationsElasticsearchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsElasticsearchArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_nodes: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[bool] fetch_nodes: Specify if metrics should be collected for nodes. Turning it on will increase the number of API calls made to CloudWatch.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_nodes is not None:
            pulumi.set(__self__, "fetch_nodes", fetch_nodes)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchNodes")
    def fetch_nodes(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if metrics should be collected for nodes. Turning it on will increase the number of API calls made to CloudWatch.
        """
        return pulumi.get(self, "fetch_nodes")

    @fetch_nodes.setter
    def fetch_nodes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_nodes", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsIntegrationsElbArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        fetch_extended_inventory: NotRequired[pulumi.Input[bool]]
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsElbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsElbArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_extended_inventory: Optional[pulumi.Input[bool]] = None,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[bool] fetch_extended_inventory: Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[bool] fetch_tags: Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_extended_inventory is not None:
            pulumi.set(__self__, "fetch_extended_inventory", fetch_extended_inventory)
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchExtendedInventory")
    def fetch_extended_inventory(self) -> Optional[pulumi.Input[bool]]:
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_extended_inventory")

    @fetch_extended_inventory.setter
    def fetch_extended_inventory(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_extended_inventory", value)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsEmrArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsIntegrationsEmrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsEmrArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[bool] fetch_tags: Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsIntegrationsHealthArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsHealthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsHealthArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsIamArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsIntegrationsIamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsIamArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsIntegrationsIotArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsIotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsIotArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsKinesisArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        fetch_shards: NotRequired[pulumi.Input[bool]]
        """
        Specify if Shards should be monitored. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsIntegrationsKinesisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsKinesisArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_shards: Optional[pulumi.Input[bool]] = None,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[bool] fetch_shards: Specify if Shards should be monitored. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[bool] fetch_tags: Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_shards is not None:
            pulumi.set(__self__, "fetch_shards", fetch_shards)
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchShards")
    def fetch_shards(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if Shards should be monitored. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_shards")

    @fetch_shards.setter
    def fetch_shards(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_shards", value)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsIntegrationsKinesisFirehoseArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsKinesisFirehoseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsKinesisFirehoseArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsLambdaArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsIntegrationsLambdaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsLambdaArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[bool] fetch_tags: Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsIntegrationsRdsArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsIntegrationsRdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsRdsArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[bool] fetch_tags: Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if tags and the extended inventory should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsIntegrationsRedshiftArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsIntegrationsRedshiftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsRedshiftArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsIntegrationsRoute53ArgsDict(TypedDict):
        fetch_extended_inventory: NotRequired[pulumi.Input[bool]]
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsRoute53ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsRoute53Args:
    def __init__(__self__, *,
                 fetch_extended_inventory: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] fetch_extended_inventory: Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if fetch_extended_inventory is not None:
            pulumi.set(__self__, "fetch_extended_inventory", fetch_extended_inventory)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="fetchExtendedInventory")
    def fetch_extended_inventory(self) -> Optional[pulumi.Input[bool]]:
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_extended_inventory")

    @fetch_extended_inventory.setter
    def fetch_extended_inventory(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_extended_inventory", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsS3ArgsDict(TypedDict):
        fetch_extended_inventory: NotRequired[pulumi.Input[bool]]
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsIntegrationsS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsS3Args:
    def __init__(__self__, *,
                 fetch_extended_inventory: Optional[pulumi.Input[bool]] = None,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] fetch_extended_inventory: Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[bool] fetch_tags: Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if fetch_extended_inventory is not None:
            pulumi.set(__self__, "fetch_extended_inventory", fetch_extended_inventory)
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="fetchExtendedInventory")
    def fetch_extended_inventory(self) -> Optional[pulumi.Input[bool]]:
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_extended_inventory")

    @fetch_extended_inventory.setter
    def fetch_extended_inventory(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_extended_inventory", value)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsIntegrationsSesArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsSesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsSesArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsSnsArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        fetch_extended_inventory: NotRequired[pulumi.Input[bool]]
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsSnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsSnsArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_extended_inventory: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[bool] fetch_extended_inventory: Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_extended_inventory is not None:
            pulumi.set(__self__, "fetch_extended_inventory", fetch_extended_inventory)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchExtendedInventory")
    def fetch_extended_inventory(self) -> Optional[pulumi.Input[bool]]:
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_extended_inventory")

    @fetch_extended_inventory.setter
    def fetch_extended_inventory(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_extended_inventory", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsSqsArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        fetch_extended_inventory: NotRequired[pulumi.Input[bool]]
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
        queue_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each name or prefix for the Queues that you want to monitor. Filter values are case-sensitive.
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsIntegrationsSqsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsSqsArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_extended_inventory: Optional[pulumi.Input[bool]] = None,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 queue_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[bool] fetch_extended_inventory: Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[bool] fetch_tags: Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] queue_prefixes: Specify each name or prefix for the Queues that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_extended_inventory is not None:
            pulumi.set(__self__, "fetch_extended_inventory", fetch_extended_inventory)
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if queue_prefixes is not None:
            pulumi.set(__self__, "queue_prefixes", queue_prefixes)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchExtendedInventory")
    def fetch_extended_inventory(self) -> Optional[pulumi.Input[bool]]:
        """
        Determine if extra inventory data be collected or not. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_extended_inventory")

    @fetch_extended_inventory.setter
    def fetch_extended_inventory(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_extended_inventory", value)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if tags should be collected. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="queuePrefixes")
    def queue_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each name or prefix for the Queues that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "queue_prefixes")

    @queue_prefixes.setter
    def queue_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "queue_prefixes", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsIntegrationsTrustedAdvisorArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsTrustedAdvisorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsTrustedAdvisorArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AwsIntegrationsVpcArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        fetch_nat_gateway: NotRequired[pulumi.Input[bool]]
        """
        Specify if NAT gateway should be monitored. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        fetch_vpn: NotRequired[pulumi.Input[bool]]
        """
        Specify if VPN should be monitored. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
        tag_key: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
elif False:
    AwsIntegrationsVpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsVpcArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fetch_nat_gateway: Optional[pulumi.Input[bool]] = None,
                 fetch_vpn: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_key: Optional[pulumi.Input[str]] = None,
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[bool] fetch_nat_gateway: Specify if NAT gateway should be monitored. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[bool] fetch_vpn: Specify if VPN should be monitored. May affect total data collection time and contribute to the Cloud provider API rate limit.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        :param pulumi.Input[str] tag_key: Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        :param pulumi.Input[str] tag_value: Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if fetch_nat_gateway is not None:
            pulumi.set(__self__, "fetch_nat_gateway", fetch_nat_gateway)
        if fetch_vpn is not None:
            pulumi.set(__self__, "fetch_vpn", fetch_vpn)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_key is not None:
            pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="fetchNatGateway")
    def fetch_nat_gateway(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if NAT gateway should be monitored. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_nat_gateway")

    @fetch_nat_gateway.setter
    def fetch_nat_gateway(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_nat_gateway", value)

    @property
    @pulumi.getter(name="fetchVpn")
    def fetch_vpn(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if VPN should be monitored. May affect total data collection time and contribute to the Cloud provider API rate limit.
        """
        return pulumi.get(self, "fetch_vpn")

    @fetch_vpn.setter
    def fetch_vpn(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_vpn", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag key associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a Tag value associated with the resources that you want to monitor. Filter values are case-sensitive.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class AwsIntegrationsXRayArgsDict(TypedDict):
        aws_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds.
        """
elif False:
    AwsIntegrationsXRayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsIntegrationsXRayArgs:
    def __init__(__self__, *,
                 aws_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aws_regions: Specify each AWS region that includes the resources that you want to monitor.
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds.
        """
        if aws_regions is not None:
            pulumi.set(__self__, "aws_regions", aws_regions)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="awsRegions")
    def aws_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each AWS region that includes the resources that you want to monitor.
        """
        return pulumi.get(self, "aws_regions")

    @aws_regions.setter
    def aws_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aws_regions", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds.
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class AzureIntegrationsApiManagementArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsApiManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsApiManagementArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsAppGatewayArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsAppGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsAppGatewayArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsAppServiceArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsAppServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsAppServiceArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsContainersArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsContainersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsContainersArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsCosmosDbArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsCosmosDbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsCosmosDbArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsCostManagementArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        tag_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify if additional cost data per tag should be collected. This field is case sensitive.
        """
elif False:
    AzureIntegrationsCostManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsCostManagementArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 tag_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tag_keys: Specify if additional cost data per tag should be collected. This field is case sensitive.
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if tag_keys is not None:
            pulumi.set(__self__, "tag_keys", tag_keys)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="tagKeys")
    def tag_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify if additional cost data per tag should be collected. This field is case sensitive.
        """
        return pulumi.get(self, "tag_keys")

    @tag_keys.setter
    def tag_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tag_keys", value)


if not MYPY:
    class AzureIntegrationsDataFactoryArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsDataFactoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsDataFactoryArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsEventHubArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsEventHubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsEventHubArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsExpressRouteArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsExpressRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsExpressRouteArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsFirewallsArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsFirewallsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsFirewallsArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsFrontDoorArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsFrontDoorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsFrontDoorArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsFunctionsArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsFunctionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsFunctionsArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsKeyVaultArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsKeyVaultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsKeyVaultArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsLoadBalancerArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsLoadBalancerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsLoadBalancerArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsLogicAppsArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsLogicAppsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsLogicAppsArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsMachineLearningArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsMachineLearningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsMachineLearningArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsMariaDbArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsMariaDbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsMariaDbArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsMonitorArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        A flag that specifies if the integration is active
        """
        exclude_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify resource tags in 'key:value' form to be excluded from monitoring
        """
        include_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify resource tags in 'key:value' form to be monitored
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        resource_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Azure resource type that needs to be monitored
        """
elif False:
    AzureIntegrationsMonitorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsMonitorArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 exclude_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 resource_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] enabled: A flag that specifies if the integration is active
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_tags: Specify resource tags in 'key:value' form to be excluded from monitoring
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_tags: Specify resource tags in 'key:value' form to be monitored
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_types: Specify each Azure resource type that needs to be monitored
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exclude_tags is not None:
            pulumi.set(__self__, "exclude_tags", exclude_tags)
        if include_tags is not None:
            pulumi.set(__self__, "include_tags", include_tags)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)
        if resource_types is not None:
            pulumi.set(__self__, "resource_types", resource_types)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag that specifies if the integration is active
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="excludeTags")
    def exclude_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify resource tags in 'key:value' form to be excluded from monitoring
        """
        return pulumi.get(self, "exclude_tags")

    @exclude_tags.setter
    def exclude_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_tags", value)

    @property
    @pulumi.getter(name="includeTags")
    def include_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify resource tags in 'key:value' form to be monitored
        """
        return pulumi.get(self, "include_tags")

    @include_tags.setter
    def include_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_tags", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)

    @property
    @pulumi.getter(name="resourceTypes")
    def resource_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Azure resource type that needs to be monitored
        """
        return pulumi.get(self, "resource_types")

    @resource_types.setter
    def resource_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_types", value)


if not MYPY:
    class AzureIntegrationsMysqlArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsMysqlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsMysqlArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsMysqlFlexibleArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsMysqlFlexibleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsMysqlFlexibleArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsPostgresqlArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsPostgresqlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsPostgresqlArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsPostgresqlFlexibleArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsPostgresqlFlexibleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsPostgresqlFlexibleArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsPowerBiDedicatedArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsPowerBiDedicatedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsPowerBiDedicatedArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsRedisCacheArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsRedisCacheArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsRedisCacheArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsServiceBusArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsServiceBusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsServiceBusArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsSqlArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsSqlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsSqlArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsSqlManagedArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsSqlManagedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsSqlManagedArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsStorageArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsStorageArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsVirtualMachineArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsVirtualMachineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsVirtualMachineArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsVirtualNetworksArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsVirtualNetworksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsVirtualNetworksArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsVmsArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsVmsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsVmsArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class AzureIntegrationsVpnGatewayArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        The data polling interval in seconds
        """
        resource_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
elif False:
    AzureIntegrationsVpnGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureIntegrationsVpnGatewayArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None,
                 resource_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: The data polling interval in seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_groups: Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify each Resource group associated with the resources that you want to monitor. Filter values are case-sensitive
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class GcpIntegrationsAlloyDbArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsAlloyDbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsAlloyDbArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class GcpIntegrationsAppEngineArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsAppEngineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsAppEngineArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class GcpIntegrationsBigQueryArgsDict(TypedDict):
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        to fetch tags of the resource
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsBigQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsBigQueryArgs:
    def __init__(__self__, *,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] fetch_tags: to fetch tags of the resource
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        to fetch tags of the resource
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class GcpIntegrationsBigTableArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsBigTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsBigTableArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class GcpIntegrationsComposerArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsComposerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsComposerArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class GcpIntegrationsDataFlowArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsDataFlowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsDataFlowArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class GcpIntegrationsDataProcArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsDataProcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsDataProcArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class GcpIntegrationsDataStoreArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsDataStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsDataStoreArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class GcpIntegrationsFireBaseDatabaseArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsFireBaseDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsFireBaseDatabaseArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class GcpIntegrationsFireBaseHostingArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsFireBaseHostingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsFireBaseHostingArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class GcpIntegrationsFireBaseStorageArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsFireBaseStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsFireBaseStorageArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class GcpIntegrationsFireStoreArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsFireStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsFireStoreArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class GcpIntegrationsFunctionsArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsFunctionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsFunctionsArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class GcpIntegrationsInterconnectArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsInterconnectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsInterconnectArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class GcpIntegrationsKubernetesArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsKubernetesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsKubernetesArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class GcpIntegrationsLoadBalancingArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsLoadBalancingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsLoadBalancingArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class GcpIntegrationsMemCacheArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsMemCacheArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsMemCacheArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class GcpIntegrationsPubSubArgsDict(TypedDict):
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        to fetch tags of the resource
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsPubSubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsPubSubArgs:
    def __init__(__self__, *,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] fetch_tags: to fetch tags of the resource
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        to fetch tags of the resource
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class GcpIntegrationsRedisArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsRedisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsRedisArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class GcpIntegrationsRouterArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsRouterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsRouterArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class GcpIntegrationsRunArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsRunArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsRunArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class GcpIntegrationsSpannerArgsDict(TypedDict):
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        to fetch tags of the resource
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsSpannerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsSpannerArgs:
    def __init__(__self__, *,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] fetch_tags: to fetch tags of the resource
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        to fetch tags of the resource
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class GcpIntegrationsSqlArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsSqlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsSqlArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class GcpIntegrationsStorageArgsDict(TypedDict):
        fetch_tags: NotRequired[pulumi.Input[bool]]
        """
        to fetch tags of the resource
        """
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsStorageArgs:
    def __init__(__self__, *,
                 fetch_tags: Optional[pulumi.Input[bool]] = None,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] fetch_tags: to fetch tags of the resource
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if fetch_tags is not None:
            pulumi.set(__self__, "fetch_tags", fetch_tags)
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="fetchTags")
    def fetch_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        to fetch tags of the resource
        """
        return pulumi.get(self, "fetch_tags")

    @fetch_tags.setter
    def fetch_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_tags", value)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class GcpIntegrationsVirtualMachinesArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsVirtualMachinesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsVirtualMachinesArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


if not MYPY:
    class GcpIntegrationsVpcAccessArgsDict(TypedDict):
        metrics_polling_interval: NotRequired[pulumi.Input[int]]
        """
        the data polling interval in seconds
        """
elif False:
    GcpIntegrationsVpcAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpIntegrationsVpcAccessArgs:
    def __init__(__self__, *,
                 metrics_polling_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] metrics_polling_interval: the data polling interval in seconds
        """
        if metrics_polling_interval is not None:
            pulumi.set(__self__, "metrics_polling_interval", metrics_polling_interval)

    @property
    @pulumi.getter(name="metricsPollingInterval")
    def metrics_polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        the data polling interval in seconds
        """
        return pulumi.get(self, "metrics_polling_interval")

    @metrics_polling_interval.setter
    def metrics_polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "metrics_polling_interval", value)


