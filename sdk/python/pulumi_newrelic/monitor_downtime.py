# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['MonitorDowntimeArgs', 'MonitorDowntime']

@pulumi.input_type
class MonitorDowntimeArgs:
    def __init__(__self__, *,
                 end_time: pulumi.Input[str],
                 mode: pulumi.Input[str],
                 start_time: pulumi.Input[str],
                 time_zone: pulumi.Input[str],
                 account_id: Optional[pulumi.Input[str]] = None,
                 end_repeat: Optional[pulumi.Input['MonitorDowntimeEndRepeatArgs']] = None,
                 frequency: Optional[pulumi.Input['MonitorDowntimeFrequencyArgs']] = None,
                 maintenance_days: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 monitor_guids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        The set of arguments for constructing a MonitorDowntime resource.
        :param pulumi.Input[str] end_time: The time at which the monitor downtime would end operating, a timestamp specified in the ISO 8601 format without the offset/timezone - for instance, `2024-01-05T14:27:07`.
        :param pulumi.Input[str] mode: One of the four modes of operation of monitor downtimes - `ONE_TIME`, `DAILY`, `MONTHLY` or `WEEKLY`.
        :param pulumi.Input[str] start_time: The time at which the monitor downtime would begin to operate, a timestamp specified in the ISO 8601 format without the offset/timezone - for instance, `2023-12-20T10:48:53`.
        :param pulumi.Input[str] time_zone: The timezone that applies to the Monitor Downtime schedule.
        :param pulumi.Input[str] account_id: The account in which the monitor downtime would be created. Defaults to the value of the environment variable `NEW_RELIC_ACCOUNT_ID` (or the `account_id` specified in the `provider{}`), if not specified.
        :param pulumi.Input['MonitorDowntimeEndRepeatArgs'] end_repeat: Options which may be used to specify when the repeat cycle of the monitor should end. This argument comprises the following nested arguments -
        :param pulumi.Input['MonitorDowntimeFrequencyArgs'] frequency: Options which may be used to specify the configuration of a monthly monitor downtime. This argument comprises the following nested arguments -
        :param pulumi.Input[Sequence[pulumi.Input[str]]] maintenance_days: A list of days on which weekly monitor downtimes would function. Valid values which go into this list would be `"SUNDAY"`, `"MONDAY"`, `"TUESDAY"`, `"WEDNESDAY"`, `"THURSDAY"`, `"FRIDAY"` and/or `"SATURDAY"`.
               
               > **NOTE:** `maintenance_days` **can only be used with the mode** `WEEKLY`, and **is a required argument** with weekly monitor downtimes (i.e. if the `mode` is `WEEKLY`).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] monitor_guids: A list of GUIDs of synthetic monitors the monitor downtime would need to be applied to.
        :param pulumi.Input[str] name: Name of the monitor downtime to be created.
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if end_repeat is not None:
            pulumi.set(__self__, "end_repeat", end_repeat)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if maintenance_days is not None:
            pulumi.set(__self__, "maintenance_days", maintenance_days)
        if monitor_guids is not None:
            pulumi.set(__self__, "monitor_guids", monitor_guids)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> pulumi.Input[str]:
        """
        The time at which the monitor downtime would end operating, a timestamp specified in the ISO 8601 format without the offset/timezone - for instance, `2024-01-05T14:27:07`.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[str]:
        """
        One of the four modes of operation of monitor downtimes - `ONE_TIME`, `DAILY`, `MONTHLY` or `WEEKLY`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[str]:
        """
        The time at which the monitor downtime would begin to operate, a timestamp specified in the ISO 8601 format without the offset/timezone - for instance, `2023-12-20T10:48:53`.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> pulumi.Input[str]:
        """
        The timezone that applies to the Monitor Downtime schedule.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[str]]:
        """
        The account in which the monitor downtime would be created. Defaults to the value of the environment variable `NEW_RELIC_ACCOUNT_ID` (or the `account_id` specified in the `provider{}`), if not specified.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account_id", value)

    @property
    @pulumi.getter(name="endRepeat")
    def end_repeat(self) -> Optional[pulumi.Input['MonitorDowntimeEndRepeatArgs']]:
        """
        Options which may be used to specify when the repeat cycle of the monitor should end. This argument comprises the following nested arguments -
        """
        return pulumi.get(self, "end_repeat")

    @end_repeat.setter
    def end_repeat(self, value: Optional[pulumi.Input['MonitorDowntimeEndRepeatArgs']]):
        pulumi.set(self, "end_repeat", value)

    @property
    @pulumi.getter
    def frequency(self) -> Optional[pulumi.Input['MonitorDowntimeFrequencyArgs']]:
        """
        Options which may be used to specify the configuration of a monthly monitor downtime. This argument comprises the following nested arguments -
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: Optional[pulumi.Input['MonitorDowntimeFrequencyArgs']]):
        pulumi.set(self, "frequency", value)

    @property
    @pulumi.getter(name="maintenanceDays")
    def maintenance_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of days on which weekly monitor downtimes would function. Valid values which go into this list would be `"SUNDAY"`, `"MONDAY"`, `"TUESDAY"`, `"WEDNESDAY"`, `"THURSDAY"`, `"FRIDAY"` and/or `"SATURDAY"`.

        > **NOTE:** `maintenance_days` **can only be used with the mode** `WEEKLY`, and **is a required argument** with weekly monitor downtimes (i.e. if the `mode` is `WEEKLY`).
        """
        return pulumi.get(self, "maintenance_days")

    @maintenance_days.setter
    def maintenance_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "maintenance_days", value)

    @property
    @pulumi.getter(name="monitorGuids")
    def monitor_guids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of GUIDs of synthetic monitors the monitor downtime would need to be applied to.
        """
        return pulumi.get(self, "monitor_guids")

    @monitor_guids.setter
    def monitor_guids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "monitor_guids", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the monitor downtime to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class _MonitorDowntimeState:
    def __init__(__self__, *,
                 account_id: Optional[pulumi.Input[str]] = None,
                 end_repeat: Optional[pulumi.Input['MonitorDowntimeEndRepeatArgs']] = None,
                 end_time: Optional[pulumi.Input[str]] = None,
                 frequency: Optional[pulumi.Input['MonitorDowntimeFrequencyArgs']] = None,
                 maintenance_days: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 monitor_guids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        """
        Input properties used for looking up and filtering MonitorDowntime resources.
        :param pulumi.Input[str] account_id: The account in which the monitor downtime would be created. Defaults to the value of the environment variable `NEW_RELIC_ACCOUNT_ID` (or the `account_id` specified in the `provider{}`), if not specified.
        :param pulumi.Input['MonitorDowntimeEndRepeatArgs'] end_repeat: Options which may be used to specify when the repeat cycle of the monitor should end. This argument comprises the following nested arguments -
        :param pulumi.Input[str] end_time: The time at which the monitor downtime would end operating, a timestamp specified in the ISO 8601 format without the offset/timezone - for instance, `2024-01-05T14:27:07`.
        :param pulumi.Input['MonitorDowntimeFrequencyArgs'] frequency: Options which may be used to specify the configuration of a monthly monitor downtime. This argument comprises the following nested arguments -
        :param pulumi.Input[Sequence[pulumi.Input[str]]] maintenance_days: A list of days on which weekly monitor downtimes would function. Valid values which go into this list would be `"SUNDAY"`, `"MONDAY"`, `"TUESDAY"`, `"WEDNESDAY"`, `"THURSDAY"`, `"FRIDAY"` and/or `"SATURDAY"`.
               
               > **NOTE:** `maintenance_days` **can only be used with the mode** `WEEKLY`, and **is a required argument** with weekly monitor downtimes (i.e. if the `mode` is `WEEKLY`).
        :param pulumi.Input[str] mode: One of the four modes of operation of monitor downtimes - `ONE_TIME`, `DAILY`, `MONTHLY` or `WEEKLY`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] monitor_guids: A list of GUIDs of synthetic monitors the monitor downtime would need to be applied to.
        :param pulumi.Input[str] name: Name of the monitor downtime to be created.
        :param pulumi.Input[str] start_time: The time at which the monitor downtime would begin to operate, a timestamp specified in the ISO 8601 format without the offset/timezone - for instance, `2023-12-20T10:48:53`.
        :param pulumi.Input[str] time_zone: The timezone that applies to the Monitor Downtime schedule.
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if end_repeat is not None:
            pulumi.set(__self__, "end_repeat", end_repeat)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if maintenance_days is not None:
            pulumi.set(__self__, "maintenance_days", maintenance_days)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if monitor_guids is not None:
            pulumi.set(__self__, "monitor_guids", monitor_guids)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[str]]:
        """
        The account in which the monitor downtime would be created. Defaults to the value of the environment variable `NEW_RELIC_ACCOUNT_ID` (or the `account_id` specified in the `provider{}`), if not specified.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account_id", value)

    @property
    @pulumi.getter(name="endRepeat")
    def end_repeat(self) -> Optional[pulumi.Input['MonitorDowntimeEndRepeatArgs']]:
        """
        Options which may be used to specify when the repeat cycle of the monitor should end. This argument comprises the following nested arguments -
        """
        return pulumi.get(self, "end_repeat")

    @end_repeat.setter
    def end_repeat(self, value: Optional[pulumi.Input['MonitorDowntimeEndRepeatArgs']]):
        pulumi.set(self, "end_repeat", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time at which the monitor downtime would end operating, a timestamp specified in the ISO 8601 format without the offset/timezone - for instance, `2024-01-05T14:27:07`.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter
    def frequency(self) -> Optional[pulumi.Input['MonitorDowntimeFrequencyArgs']]:
        """
        Options which may be used to specify the configuration of a monthly monitor downtime. This argument comprises the following nested arguments -
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: Optional[pulumi.Input['MonitorDowntimeFrequencyArgs']]):
        pulumi.set(self, "frequency", value)

    @property
    @pulumi.getter(name="maintenanceDays")
    def maintenance_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of days on which weekly monitor downtimes would function. Valid values which go into this list would be `"SUNDAY"`, `"MONDAY"`, `"TUESDAY"`, `"WEDNESDAY"`, `"THURSDAY"`, `"FRIDAY"` and/or `"SATURDAY"`.

        > **NOTE:** `maintenance_days` **can only be used with the mode** `WEEKLY`, and **is a required argument** with weekly monitor downtimes (i.e. if the `mode` is `WEEKLY`).
        """
        return pulumi.get(self, "maintenance_days")

    @maintenance_days.setter
    def maintenance_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "maintenance_days", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        One of the four modes of operation of monitor downtimes - `ONE_TIME`, `DAILY`, `MONTHLY` or `WEEKLY`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="monitorGuids")
    def monitor_guids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of GUIDs of synthetic monitors the monitor downtime would need to be applied to.
        """
        return pulumi.get(self, "monitor_guids")

    @monitor_guids.setter
    def monitor_guids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "monitor_guids", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the monitor downtime to be created.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time at which the monitor downtime would begin to operate, a timestamp specified in the ISO 8601 format without the offset/timezone - for instance, `2023-12-20T10:48:53`.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        The timezone that applies to the Monitor Downtime schedule.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


class MonitorDowntime(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 account_id: Optional[pulumi.Input[str]] = None,
                 end_repeat: Optional[pulumi.Input[pulumi.InputType['MonitorDowntimeEndRepeatArgs']]] = None,
                 end_time: Optional[pulumi.Input[str]] = None,
                 frequency: Optional[pulumi.Input[pulumi.InputType['MonitorDowntimeFrequencyArgs']]] = None,
                 maintenance_days: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 monitor_guids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        """
        Use this resource to create, update, and delete [Monitor Downtimes](https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/) in New Relic.

        ## Example Usage

        ```python
        import pulumi
        import pulumi_newrelic as newrelic

        foo = newrelic.MonitorDowntime("foo",
            end_repeat=newrelic.MonitorDowntimeEndRepeatArgs(
                on_date="2023-12-20",
            ),
            end_time="2023-12-10T02:45:30",
            maintenance_days=[
                "FRIDAY",
                "SATURDAY",
            ],
            mode="WEEKLY",
            monitor_guids=[
                "<GUID-1>",
                "<GUID-2>",
            ],
            start_time="2023-11-30T10:30:00",
            time_zone="Asia/Kolkata")
        ```
        Monitor Downtimes are of four types; **one-time**, **daily**, **weekly** and **monthly**. For more details on each type and the right arguments that go with them, check out the argument reference and examples sections below.
        ## Examples

        ### One-Time Monitor Downtime

        The below example illustrates creating a **one-time** monitor downtime.

        ```python
        import pulumi
        import pulumi_newrelic as newrelic

        sample_one_time_newrelic_monitor_downtime = newrelic.MonitorDowntime("sampleOneTimeNewrelicMonitorDowntime",
            end_time="2024-01-04T16:24:30",
            mode="ONE_TIME",
            monitor_guids=[
                "<GUID-1>",
                "<GUID-2>",
            ],
            start_time="2023-12-04T10:15:00",
            time_zone="America/Los_Angeles")
        ```

        ### Daily Monitor Downtime

        The below example illustrates creating a **daily** monitor downtime.

        Note that `end_repeat` has been specified in the configuration; however, this is optional, in accordance with the rules of `end_repeat` specified in the argument reference section above. This example uses the `on_date` nested argument of `end_repeat`, however, the other nested argument, `on_repeat` may also be used _instead_, as you may see in some of the other examples below; though both `on_date` and `on_repeat` cannot be specified together, as they are mutually exclusive.

        ```python
        import pulumi
        import pulumi_newrelic as newrelic

        sample_daily_newrelic_monitor_downtime = newrelic.MonitorDowntime("sampleDailyNewrelicMonitorDowntime",
            end_repeat=newrelic.MonitorDowntimeEndRepeatArgs(
                on_date="2023-12-25",
            ),
            end_time="2024-01-04T07:15:00",
            mode="DAILY",
            monitor_guids=[
                "<GUID-1>",
                "<GUID-2>",
            ],
            start_time="2023-12-04T18:15:00",
            time_zone="Asia/Kolkata")
        ```

        ### Weekly Monitor Downtime

        The below example illustrates creating a **weekly** monitor downtime.

        Note that `maintenance_days` has been specified in the configuration as it is required with weekly monitor downtimes; and `end_repeat` has not been specified as it is optional, all in accordance with the rules of these arguments specified in the argument reference section above.

        ```python
        import pulumi
        import pulumi_newrelic as newrelic

        sample_weekly_newrelic_monitor_downtime = newrelic.MonitorDowntime("sampleWeeklyNewrelicMonitorDowntime",
            end_time="2024-01-04T23:55:00",
            maintenance_days=[
                "SATURDAY",
                "SUNDAY",
            ],
            mode="WEEKLY",
            monitor_guids=[
                "<GUID-1>",
                "<GUID-2>",
            ],
            start_time="2023-12-04T14:15:00",
            time_zone="US/Hawaii")
        ```

        ### Monthly Monitor Downtime

        The below example illustrates creating a **monthly** monitor downtime.

        Note that `frequency` has been specified in the configuration as it is required with monthly monitor downtimes, and `end_repeat` has been specified too, though it is optional. `frequency` has been specified with `days_of_week` comprising both of its nested arguments, `ordinal_day_of_month` and `week_day`; all in accordance with the rules of these arguments specified in the argument reference section above.

        ```python
        import pulumi
        import pulumi_newrelic as newrelic

        sample_monthly_newrelic_monitor_downtime = newrelic.MonitorDowntime("sampleMonthlyNewrelicMonitorDowntime",
            end_repeat=newrelic.MonitorDowntimeEndRepeatArgs(
                on_repeat=6,
            ),
            end_time="2024-01-04T19:15:00",
            frequency=newrelic.MonitorDowntimeFrequencyArgs(
                days_of_week=newrelic.MonitorDowntimeFrequencyDaysOfWeekArgs(
                    ordinal_day_of_month="SECOND",
                    week_day="SATURDAY",
                ),
            ),
            mode="MONTHLY",
            monitor_guids=[
                "<GUID-1>",
                "<GUID-2>",
            ],
            start_time="2023-12-04T07:15:00",
            time_zone="Europe/Dublin")
        ```
        However, the `frequency` block in monthly monitor downtimes may also be specified with its other nested argument, `days_of_month`, as shown in the example below - though both `days_of_month` and `days_of_week` cannot be specified together, as they are mutually exclusive.
        ```python
        import pulumi
        import pulumi_newrelic as newrelic

        sample_monthly_newrelic_monitor_downtime = newrelic.MonitorDowntime("sampleMonthlyNewrelicMonitorDowntime",
            end_repeat=newrelic.MonitorDowntimeEndRepeatArgs(
                on_repeat=6,
            ),
            end_time="2024-01-04T19:15:00",
            frequency=newrelic.MonitorDowntimeFrequencyArgs(
                days_of_months=[
                    3,
                    6,
                    14,
                    23,
                ],
            ),
            mode="MONTHLY",
            monitor_guids=[
                "<GUID-1>",
                "<GUID-2>",
            ],
            start_time="2023-12-04T07:15:00",
            time_zone="Europe/Dublin")
        ```

        ## Import

        A monitor downtime can be imported into Terraform configuration using its `guid`, i.e. bash

        ```sh
         $ pulumi import newrelic:index/monitorDowntime:MonitorDowntime monitor <guid>
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] account_id: The account in which the monitor downtime would be created. Defaults to the value of the environment variable `NEW_RELIC_ACCOUNT_ID` (or the `account_id` specified in the `provider{}`), if not specified.
        :param pulumi.Input[pulumi.InputType['MonitorDowntimeEndRepeatArgs']] end_repeat: Options which may be used to specify when the repeat cycle of the monitor should end. This argument comprises the following nested arguments -
        :param pulumi.Input[str] end_time: The time at which the monitor downtime would end operating, a timestamp specified in the ISO 8601 format without the offset/timezone - for instance, `2024-01-05T14:27:07`.
        :param pulumi.Input[pulumi.InputType['MonitorDowntimeFrequencyArgs']] frequency: Options which may be used to specify the configuration of a monthly monitor downtime. This argument comprises the following nested arguments -
        :param pulumi.Input[Sequence[pulumi.Input[str]]] maintenance_days: A list of days on which weekly monitor downtimes would function. Valid values which go into this list would be `"SUNDAY"`, `"MONDAY"`, `"TUESDAY"`, `"WEDNESDAY"`, `"THURSDAY"`, `"FRIDAY"` and/or `"SATURDAY"`.
               
               > **NOTE:** `maintenance_days` **can only be used with the mode** `WEEKLY`, and **is a required argument** with weekly monitor downtimes (i.e. if the `mode` is `WEEKLY`).
        :param pulumi.Input[str] mode: One of the four modes of operation of monitor downtimes - `ONE_TIME`, `DAILY`, `MONTHLY` or `WEEKLY`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] monitor_guids: A list of GUIDs of synthetic monitors the monitor downtime would need to be applied to.
        :param pulumi.Input[str] name: Name of the monitor downtime to be created.
        :param pulumi.Input[str] start_time: The time at which the monitor downtime would begin to operate, a timestamp specified in the ISO 8601 format without the offset/timezone - for instance, `2023-12-20T10:48:53`.
        :param pulumi.Input[str] time_zone: The timezone that applies to the Monitor Downtime schedule.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: MonitorDowntimeArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Use this resource to create, update, and delete [Monitor Downtimes](https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/) in New Relic.

        ## Example Usage

        ```python
        import pulumi
        import pulumi_newrelic as newrelic

        foo = newrelic.MonitorDowntime("foo",
            end_repeat=newrelic.MonitorDowntimeEndRepeatArgs(
                on_date="2023-12-20",
            ),
            end_time="2023-12-10T02:45:30",
            maintenance_days=[
                "FRIDAY",
                "SATURDAY",
            ],
            mode="WEEKLY",
            monitor_guids=[
                "<GUID-1>",
                "<GUID-2>",
            ],
            start_time="2023-11-30T10:30:00",
            time_zone="Asia/Kolkata")
        ```
        Monitor Downtimes are of four types; **one-time**, **daily**, **weekly** and **monthly**. For more details on each type and the right arguments that go with them, check out the argument reference and examples sections below.
        ## Examples

        ### One-Time Monitor Downtime

        The below example illustrates creating a **one-time** monitor downtime.

        ```python
        import pulumi
        import pulumi_newrelic as newrelic

        sample_one_time_newrelic_monitor_downtime = newrelic.MonitorDowntime("sampleOneTimeNewrelicMonitorDowntime",
            end_time="2024-01-04T16:24:30",
            mode="ONE_TIME",
            monitor_guids=[
                "<GUID-1>",
                "<GUID-2>",
            ],
            start_time="2023-12-04T10:15:00",
            time_zone="America/Los_Angeles")
        ```

        ### Daily Monitor Downtime

        The below example illustrates creating a **daily** monitor downtime.

        Note that `end_repeat` has been specified in the configuration; however, this is optional, in accordance with the rules of `end_repeat` specified in the argument reference section above. This example uses the `on_date` nested argument of `end_repeat`, however, the other nested argument, `on_repeat` may also be used _instead_, as you may see in some of the other examples below; though both `on_date` and `on_repeat` cannot be specified together, as they are mutually exclusive.

        ```python
        import pulumi
        import pulumi_newrelic as newrelic

        sample_daily_newrelic_monitor_downtime = newrelic.MonitorDowntime("sampleDailyNewrelicMonitorDowntime",
            end_repeat=newrelic.MonitorDowntimeEndRepeatArgs(
                on_date="2023-12-25",
            ),
            end_time="2024-01-04T07:15:00",
            mode="DAILY",
            monitor_guids=[
                "<GUID-1>",
                "<GUID-2>",
            ],
            start_time="2023-12-04T18:15:00",
            time_zone="Asia/Kolkata")
        ```

        ### Weekly Monitor Downtime

        The below example illustrates creating a **weekly** monitor downtime.

        Note that `maintenance_days` has been specified in the configuration as it is required with weekly monitor downtimes; and `end_repeat` has not been specified as it is optional, all in accordance with the rules of these arguments specified in the argument reference section above.

        ```python
        import pulumi
        import pulumi_newrelic as newrelic

        sample_weekly_newrelic_monitor_downtime = newrelic.MonitorDowntime("sampleWeeklyNewrelicMonitorDowntime",
            end_time="2024-01-04T23:55:00",
            maintenance_days=[
                "SATURDAY",
                "SUNDAY",
            ],
            mode="WEEKLY",
            monitor_guids=[
                "<GUID-1>",
                "<GUID-2>",
            ],
            start_time="2023-12-04T14:15:00",
            time_zone="US/Hawaii")
        ```

        ### Monthly Monitor Downtime

        The below example illustrates creating a **monthly** monitor downtime.

        Note that `frequency` has been specified in the configuration as it is required with monthly monitor downtimes, and `end_repeat` has been specified too, though it is optional. `frequency` has been specified with `days_of_week` comprising both of its nested arguments, `ordinal_day_of_month` and `week_day`; all in accordance with the rules of these arguments specified in the argument reference section above.

        ```python
        import pulumi
        import pulumi_newrelic as newrelic

        sample_monthly_newrelic_monitor_downtime = newrelic.MonitorDowntime("sampleMonthlyNewrelicMonitorDowntime",
            end_repeat=newrelic.MonitorDowntimeEndRepeatArgs(
                on_repeat=6,
            ),
            end_time="2024-01-04T19:15:00",
            frequency=newrelic.MonitorDowntimeFrequencyArgs(
                days_of_week=newrelic.MonitorDowntimeFrequencyDaysOfWeekArgs(
                    ordinal_day_of_month="SECOND",
                    week_day="SATURDAY",
                ),
            ),
            mode="MONTHLY",
            monitor_guids=[
                "<GUID-1>",
                "<GUID-2>",
            ],
            start_time="2023-12-04T07:15:00",
            time_zone="Europe/Dublin")
        ```
        However, the `frequency` block in monthly monitor downtimes may also be specified with its other nested argument, `days_of_month`, as shown in the example below - though both `days_of_month` and `days_of_week` cannot be specified together, as they are mutually exclusive.
        ```python
        import pulumi
        import pulumi_newrelic as newrelic

        sample_monthly_newrelic_monitor_downtime = newrelic.MonitorDowntime("sampleMonthlyNewrelicMonitorDowntime",
            end_repeat=newrelic.MonitorDowntimeEndRepeatArgs(
                on_repeat=6,
            ),
            end_time="2024-01-04T19:15:00",
            frequency=newrelic.MonitorDowntimeFrequencyArgs(
                days_of_months=[
                    3,
                    6,
                    14,
                    23,
                ],
            ),
            mode="MONTHLY",
            monitor_guids=[
                "<GUID-1>",
                "<GUID-2>",
            ],
            start_time="2023-12-04T07:15:00",
            time_zone="Europe/Dublin")
        ```

        ## Import

        A monitor downtime can be imported into Terraform configuration using its `guid`, i.e. bash

        ```sh
         $ pulumi import newrelic:index/monitorDowntime:MonitorDowntime monitor <guid>
        ```

        :param str resource_name: The name of the resource.
        :param MonitorDowntimeArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(MonitorDowntimeArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 account_id: Optional[pulumi.Input[str]] = None,
                 end_repeat: Optional[pulumi.Input[pulumi.InputType['MonitorDowntimeEndRepeatArgs']]] = None,
                 end_time: Optional[pulumi.Input[str]] = None,
                 frequency: Optional[pulumi.Input[pulumi.InputType['MonitorDowntimeFrequencyArgs']]] = None,
                 maintenance_days: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 monitor_guids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = MonitorDowntimeArgs.__new__(MonitorDowntimeArgs)

            __props__.__dict__["account_id"] = account_id
            __props__.__dict__["end_repeat"] = end_repeat
            if end_time is None and not opts.urn:
                raise TypeError("Missing required property 'end_time'")
            __props__.__dict__["end_time"] = end_time
            __props__.__dict__["frequency"] = frequency
            __props__.__dict__["maintenance_days"] = maintenance_days
            if mode is None and not opts.urn:
                raise TypeError("Missing required property 'mode'")
            __props__.__dict__["mode"] = mode
            __props__.__dict__["monitor_guids"] = monitor_guids
            __props__.__dict__["name"] = name
            if start_time is None and not opts.urn:
                raise TypeError("Missing required property 'start_time'")
            __props__.__dict__["start_time"] = start_time
            if time_zone is None and not opts.urn:
                raise TypeError("Missing required property 'time_zone'")
            __props__.__dict__["time_zone"] = time_zone
        super(MonitorDowntime, __self__).__init__(
            'newrelic:index/monitorDowntime:MonitorDowntime',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            account_id: Optional[pulumi.Input[str]] = None,
            end_repeat: Optional[pulumi.Input[pulumi.InputType['MonitorDowntimeEndRepeatArgs']]] = None,
            end_time: Optional[pulumi.Input[str]] = None,
            frequency: Optional[pulumi.Input[pulumi.InputType['MonitorDowntimeFrequencyArgs']]] = None,
            maintenance_days: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            mode: Optional[pulumi.Input[str]] = None,
            monitor_guids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            name: Optional[pulumi.Input[str]] = None,
            start_time: Optional[pulumi.Input[str]] = None,
            time_zone: Optional[pulumi.Input[str]] = None) -> 'MonitorDowntime':
        """
        Get an existing MonitorDowntime resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] account_id: The account in which the monitor downtime would be created. Defaults to the value of the environment variable `NEW_RELIC_ACCOUNT_ID` (or the `account_id` specified in the `provider{}`), if not specified.
        :param pulumi.Input[pulumi.InputType['MonitorDowntimeEndRepeatArgs']] end_repeat: Options which may be used to specify when the repeat cycle of the monitor should end. This argument comprises the following nested arguments -
        :param pulumi.Input[str] end_time: The time at which the monitor downtime would end operating, a timestamp specified in the ISO 8601 format without the offset/timezone - for instance, `2024-01-05T14:27:07`.
        :param pulumi.Input[pulumi.InputType['MonitorDowntimeFrequencyArgs']] frequency: Options which may be used to specify the configuration of a monthly monitor downtime. This argument comprises the following nested arguments -
        :param pulumi.Input[Sequence[pulumi.Input[str]]] maintenance_days: A list of days on which weekly monitor downtimes would function. Valid values which go into this list would be `"SUNDAY"`, `"MONDAY"`, `"TUESDAY"`, `"WEDNESDAY"`, `"THURSDAY"`, `"FRIDAY"` and/or `"SATURDAY"`.
               
               > **NOTE:** `maintenance_days` **can only be used with the mode** `WEEKLY`, and **is a required argument** with weekly monitor downtimes (i.e. if the `mode` is `WEEKLY`).
        :param pulumi.Input[str] mode: One of the four modes of operation of monitor downtimes - `ONE_TIME`, `DAILY`, `MONTHLY` or `WEEKLY`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] monitor_guids: A list of GUIDs of synthetic monitors the monitor downtime would need to be applied to.
        :param pulumi.Input[str] name: Name of the monitor downtime to be created.
        :param pulumi.Input[str] start_time: The time at which the monitor downtime would begin to operate, a timestamp specified in the ISO 8601 format without the offset/timezone - for instance, `2023-12-20T10:48:53`.
        :param pulumi.Input[str] time_zone: The timezone that applies to the Monitor Downtime schedule.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _MonitorDowntimeState.__new__(_MonitorDowntimeState)

        __props__.__dict__["account_id"] = account_id
        __props__.__dict__["end_repeat"] = end_repeat
        __props__.__dict__["end_time"] = end_time
        __props__.__dict__["frequency"] = frequency
        __props__.__dict__["maintenance_days"] = maintenance_days
        __props__.__dict__["mode"] = mode
        __props__.__dict__["monitor_guids"] = monitor_guids
        __props__.__dict__["name"] = name
        __props__.__dict__["start_time"] = start_time
        __props__.__dict__["time_zone"] = time_zone
        return MonitorDowntime(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> pulumi.Output[Optional[str]]:
        """
        The account in which the monitor downtime would be created. Defaults to the value of the environment variable `NEW_RELIC_ACCOUNT_ID` (or the `account_id` specified in the `provider{}`), if not specified.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="endRepeat")
    def end_repeat(self) -> pulumi.Output[Optional['outputs.MonitorDowntimeEndRepeat']]:
        """
        Options which may be used to specify when the repeat cycle of the monitor should end. This argument comprises the following nested arguments -
        """
        return pulumi.get(self, "end_repeat")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> pulumi.Output[str]:
        """
        The time at which the monitor downtime would end operating, a timestamp specified in the ISO 8601 format without the offset/timezone - for instance, `2024-01-05T14:27:07`.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter
    def frequency(self) -> pulumi.Output[Optional['outputs.MonitorDowntimeFrequency']]:
        """
        Options which may be used to specify the configuration of a monthly monitor downtime. This argument comprises the following nested arguments -
        """
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter(name="maintenanceDays")
    def maintenance_days(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        A list of days on which weekly monitor downtimes would function. Valid values which go into this list would be `"SUNDAY"`, `"MONDAY"`, `"TUESDAY"`, `"WEDNESDAY"`, `"THURSDAY"`, `"FRIDAY"` and/or `"SATURDAY"`.

        > **NOTE:** `maintenance_days` **can only be used with the mode** `WEEKLY`, and **is a required argument** with weekly monitor downtimes (i.e. if the `mode` is `WEEKLY`).
        """
        return pulumi.get(self, "maintenance_days")

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Output[str]:
        """
        One of the four modes of operation of monitor downtimes - `ONE_TIME`, `DAILY`, `MONTHLY` or `WEEKLY`.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="monitorGuids")
    def monitor_guids(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        A list of GUIDs of synthetic monitors the monitor downtime would need to be applied to.
        """
        return pulumi.get(self, "monitor_guids")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        """
        Name of the monitor downtime to be created.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Output[str]:
        """
        The time at which the monitor downtime would begin to operate, a timestamp specified in the ISO 8601 format without the offset/timezone - for instance, `2023-12-20T10:48:53`.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> pulumi.Output[str]:
        """
        The timezone that applies to the Monitor Downtime schedule.
        """
        return pulumi.get(self, "time_zone")

