# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'ApplicationSettingsErrorCollector',
    'ApplicationSettingsTransactionTracer',
    'ApplicationSettingsTransactionTracerExplainQueryPlan',
    'ApplicationSettingsTransactionTracerSql',
    'WorkloadEntitySearchQuery',
    'WorkloadStatusConfigAutomatic',
    'WorkloadStatusConfigAutomaticRemainingEntitiesRule',
    'WorkloadStatusConfigAutomaticRemainingEntitiesRuleRemainingEntitiesRuleRollup',
    'WorkloadStatusConfigAutomaticRule',
    'WorkloadStatusConfigAutomaticRuleNrqlQuery',
    'WorkloadStatusConfigAutomaticRuleRollup',
    'WorkloadStatusConfigStatic',
]

@pulumi.output_type
class ApplicationSettingsErrorCollector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expectedErrorClasses":
            suggest = "expected_error_classes"
        elif key == "expectedErrorCodes":
            suggest = "expected_error_codes"
        elif key == "ignoredErrorClasses":
            suggest = "ignored_error_classes"
        elif key == "ignoredErrorCodes":
            suggest = "ignored_error_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationSettingsErrorCollector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationSettingsErrorCollector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationSettingsErrorCollector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expected_error_classes: Optional[Sequence[str]] = None,
                 expected_error_codes: Optional[Sequence[str]] = None,
                 ignored_error_classes: Optional[Sequence[str]] = None,
                 ignored_error_codes: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] expected_error_classes: A list of expected error classes.
        :param Sequence[str] expected_error_codes: A list of expected error codes(any status code between 100-900).
        :param Sequence[str] ignored_error_classes: A list of ignored error classes.
        :param Sequence[str] ignored_error_codes: A list of ignored error codes(any status code between 100-900).
        """
        if expected_error_classes is not None:
            pulumi.set(__self__, "expected_error_classes", expected_error_classes)
        if expected_error_codes is not None:
            pulumi.set(__self__, "expected_error_codes", expected_error_codes)
        if ignored_error_classes is not None:
            pulumi.set(__self__, "ignored_error_classes", ignored_error_classes)
        if ignored_error_codes is not None:
            pulumi.set(__self__, "ignored_error_codes", ignored_error_codes)

    @property
    @pulumi.getter(name="expectedErrorClasses")
    def expected_error_classes(self) -> Optional[Sequence[str]]:
        """
        A list of expected error classes.
        """
        return pulumi.get(self, "expected_error_classes")

    @property
    @pulumi.getter(name="expectedErrorCodes")
    def expected_error_codes(self) -> Optional[Sequence[str]]:
        """
        A list of expected error codes(any status code between 100-900).
        """
        return pulumi.get(self, "expected_error_codes")

    @property
    @pulumi.getter(name="ignoredErrorClasses")
    def ignored_error_classes(self) -> Optional[Sequence[str]]:
        """
        A list of ignored error classes.
        """
        return pulumi.get(self, "ignored_error_classes")

    @property
    @pulumi.getter(name="ignoredErrorCodes")
    def ignored_error_codes(self) -> Optional[Sequence[str]]:
        """
        A list of ignored error codes(any status code between 100-900).
        """
        return pulumi.get(self, "ignored_error_codes")


@pulumi.output_type
class ApplicationSettingsTransactionTracer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "explainQueryPlans":
            suggest = "explain_query_plans"
        elif key == "stackTraceThresholdValue":
            suggest = "stack_trace_threshold_value"
        elif key == "transactionThresholdType":
            suggest = "transaction_threshold_type"
        elif key == "transactionThresholdValue":
            suggest = "transaction_threshold_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationSettingsTransactionTracer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationSettingsTransactionTracer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationSettingsTransactionTracer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 explain_query_plans: Optional[Sequence['outputs.ApplicationSettingsTransactionTracerExplainQueryPlan']] = None,
                 sql: Optional['outputs.ApplicationSettingsTransactionTracerSql'] = None,
                 stack_trace_threshold_value: Optional[float] = None,
                 transaction_threshold_type: Optional[str] = None,
                 transaction_threshold_value: Optional[float] = None):
        """
        :param Sequence['ApplicationSettingsTransactionTracerExplainQueryPlanArgs'] explain_query_plans: Configuration block for query plans. Including this block enables the capture of query plans. The following arguments are supported:
        :param 'ApplicationSettingsTransactionTracerSqlArgs' sql: Configuration block for SQL logging.  Including this block enables SQL logging. The following arguments are supported:
        :param float stack_trace_threshold_value: The response time threshold for collecting stack traces.
        :param str transaction_threshold_type: The type of threshold for transactions. Valid values are `VALUE`,`APDEX_F`(4 times your apdex target)
        :param float transaction_threshold_value: The threshold value for transactions(in seconds).
        """
        if explain_query_plans is not None:
            pulumi.set(__self__, "explain_query_plans", explain_query_plans)
        if sql is not None:
            pulumi.set(__self__, "sql", sql)
        if stack_trace_threshold_value is not None:
            pulumi.set(__self__, "stack_trace_threshold_value", stack_trace_threshold_value)
        if transaction_threshold_type is not None:
            pulumi.set(__self__, "transaction_threshold_type", transaction_threshold_type)
        if transaction_threshold_value is not None:
            pulumi.set(__self__, "transaction_threshold_value", transaction_threshold_value)

    @property
    @pulumi.getter(name="explainQueryPlans")
    def explain_query_plans(self) -> Optional[Sequence['outputs.ApplicationSettingsTransactionTracerExplainQueryPlan']]:
        """
        Configuration block for query plans. Including this block enables the capture of query plans. The following arguments are supported:
        """
        return pulumi.get(self, "explain_query_plans")

    @property
    @pulumi.getter
    def sql(self) -> Optional['outputs.ApplicationSettingsTransactionTracerSql']:
        """
        Configuration block for SQL logging.  Including this block enables SQL logging. The following arguments are supported:
        """
        return pulumi.get(self, "sql")

    @property
    @pulumi.getter(name="stackTraceThresholdValue")
    def stack_trace_threshold_value(self) -> Optional[float]:
        """
        The response time threshold for collecting stack traces.
        """
        return pulumi.get(self, "stack_trace_threshold_value")

    @property
    @pulumi.getter(name="transactionThresholdType")
    def transaction_threshold_type(self) -> Optional[str]:
        """
        The type of threshold for transactions. Valid values are `VALUE`,`APDEX_F`(4 times your apdex target)
        """
        return pulumi.get(self, "transaction_threshold_type")

    @property
    @pulumi.getter(name="transactionThresholdValue")
    def transaction_threshold_value(self) -> Optional[float]:
        """
        The threshold value for transactions(in seconds).
        """
        return pulumi.get(self, "transaction_threshold_value")


@pulumi.output_type
class ApplicationSettingsTransactionTracerExplainQueryPlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryPlanThresholdType":
            suggest = "query_plan_threshold_type"
        elif key == "queryPlanThresholdValue":
            suggest = "query_plan_threshold_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationSettingsTransactionTracerExplainQueryPlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationSettingsTransactionTracerExplainQueryPlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationSettingsTransactionTracerExplainQueryPlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_plan_threshold_type: Optional[str] = None,
                 query_plan_threshold_value: Optional[float] = None):
        """
        :param str query_plan_threshold_type: The type of threshold for query plans. Valid values are `VALUE`,`APDEX_F`(4 times your apdex target)
        :param float query_plan_threshold_value: The response time threshold for capturing query plans(in seconds).
        """
        if query_plan_threshold_type is not None:
            pulumi.set(__self__, "query_plan_threshold_type", query_plan_threshold_type)
        if query_plan_threshold_value is not None:
            pulumi.set(__self__, "query_plan_threshold_value", query_plan_threshold_value)

    @property
    @pulumi.getter(name="queryPlanThresholdType")
    def query_plan_threshold_type(self) -> Optional[str]:
        """
        The type of threshold for query plans. Valid values are `VALUE`,`APDEX_F`(4 times your apdex target)
        """
        return pulumi.get(self, "query_plan_threshold_type")

    @property
    @pulumi.getter(name="queryPlanThresholdValue")
    def query_plan_threshold_value(self) -> Optional[float]:
        """
        The response time threshold for capturing query plans(in seconds).
        """
        return pulumi.get(self, "query_plan_threshold_value")


@pulumi.output_type
class ApplicationSettingsTransactionTracerSql(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recordSql":
            suggest = "record_sql"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationSettingsTransactionTracerSql. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationSettingsTransactionTracerSql.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationSettingsTransactionTracerSql.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 record_sql: str):
        """
        :param str record_sql: The level of SQL recording. Valid values ar `OBFUSCATED`,`OFF`,`RAW` (Mandatory attribute when `sql` block is provided).
        """
        pulumi.set(__self__, "record_sql", record_sql)

    @property
    @pulumi.getter(name="recordSql")
    def record_sql(self) -> str:
        """
        The level of SQL recording. Valid values ar `OBFUSCATED`,`OFF`,`RAW` (Mandatory attribute when `sql` block is provided).
        """
        return pulumi.get(self, "record_sql")


@pulumi.output_type
class WorkloadEntitySearchQuery(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: A valid entity search query; empty, and null values are considered invalid.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        A valid entity search query; empty, and null values are considered invalid.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class WorkloadStatusConfigAutomatic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "remainingEntitiesRule":
            suggest = "remaining_entities_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadStatusConfigAutomatic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadStatusConfigAutomatic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadStatusConfigAutomatic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 remaining_entities_rule: Optional['outputs.WorkloadStatusConfigAutomaticRemainingEntitiesRule'] = None,
                 rules: Optional[Sequence['outputs.WorkloadStatusConfigAutomaticRule']] = None):
        """
        :param bool enabled: Whether the automatic status configuration is enabled or not.
        :param 'WorkloadStatusConfigAutomaticRemainingEntitiesRuleArgs' remaining_entities_rule: An additional meta-rule that can consider all entities that haven't been evaluated by any other rule.
        :param Sequence['WorkloadStatusConfigAutomaticRuleArgs'] rules: A list of rules.
        """
        pulumi.set(__self__, "enabled", enabled)
        if remaining_entities_rule is not None:
            pulumi.set(__self__, "remaining_entities_rule", remaining_entities_rule)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether the automatic status configuration is enabled or not.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="remainingEntitiesRule")
    def remaining_entities_rule(self) -> Optional['outputs.WorkloadStatusConfigAutomaticRemainingEntitiesRule']:
        """
        An additional meta-rule that can consider all entities that haven't been evaluated by any other rule.
        """
        return pulumi.get(self, "remaining_entities_rule")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.WorkloadStatusConfigAutomaticRule']]:
        """
        A list of rules.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class WorkloadStatusConfigAutomaticRemainingEntitiesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "remainingEntitiesRuleRollup":
            suggest = "remaining_entities_rule_rollup"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadStatusConfigAutomaticRemainingEntitiesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadStatusConfigAutomaticRemainingEntitiesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadStatusConfigAutomaticRemainingEntitiesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 remaining_entities_rule_rollup: 'outputs.WorkloadStatusConfigAutomaticRemainingEntitiesRuleRemainingEntitiesRuleRollup'):
        """
        :param 'WorkloadStatusConfigAutomaticRemainingEntitiesRuleRemainingEntitiesRuleRollupArgs' remaining_entities_rule_rollup: The input object used to represent a rollup strategy.
        """
        pulumi.set(__self__, "remaining_entities_rule_rollup", remaining_entities_rule_rollup)

    @property
    @pulumi.getter(name="remainingEntitiesRuleRollup")
    def remaining_entities_rule_rollup(self) -> 'outputs.WorkloadStatusConfigAutomaticRemainingEntitiesRuleRemainingEntitiesRuleRollup':
        """
        The input object used to represent a rollup strategy.
        """
        return pulumi.get(self, "remaining_entities_rule_rollup")


@pulumi.output_type
class WorkloadStatusConfigAutomaticRemainingEntitiesRuleRemainingEntitiesRuleRollup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBy":
            suggest = "group_by"
        elif key == "thresholdType":
            suggest = "threshold_type"
        elif key == "thresholdValue":
            suggest = "threshold_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadStatusConfigAutomaticRemainingEntitiesRuleRemainingEntitiesRuleRollup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadStatusConfigAutomaticRemainingEntitiesRuleRemainingEntitiesRuleRollup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadStatusConfigAutomaticRemainingEntitiesRuleRemainingEntitiesRuleRollup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_by: str,
                 strategy: str,
                 threshold_type: Optional[str] = None,
                 threshold_value: Optional[int] = None):
        """
        :param str group_by: The grouping to be applied to the remaining entities.
        :param str strategy: The rollup strategy that is applied to a group of entities.
        :param str threshold_type: Type of threshold defined for the rule. This is an optional field that only applies when strategy is WORST_STATUS_WINS. Use a threshold to roll up the worst status only after a certain amount of entities are not operational.
        :param int threshold_value: Threshold value defined for the rule. This optional field is used in combination with thresholdType. If the threshold type is null, the threshold value will be ignored.
        """
        pulumi.set(__self__, "group_by", group_by)
        pulumi.set(__self__, "strategy", strategy)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)
        if threshold_value is not None:
            pulumi.set(__self__, "threshold_value", threshold_value)

    @property
    @pulumi.getter(name="groupBy")
    def group_by(self) -> str:
        """
        The grouping to be applied to the remaining entities.
        """
        return pulumi.get(self, "group_by")

    @property
    @pulumi.getter
    def strategy(self) -> str:
        """
        The rollup strategy that is applied to a group of entities.
        """
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[str]:
        """
        Type of threshold defined for the rule. This is an optional field that only applies when strategy is WORST_STATUS_WINS. Use a threshold to roll up the worst status only after a certain amount of entities are not operational.
        """
        return pulumi.get(self, "threshold_type")

    @property
    @pulumi.getter(name="thresholdValue")
    def threshold_value(self) -> Optional[int]:
        """
        Threshold value defined for the rule. This optional field is used in combination with thresholdType. If the threshold type is null, the threshold value will be ignored.
        """
        return pulumi.get(self, "threshold_value")


@pulumi.output_type
class WorkloadStatusConfigAutomaticRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityGuids":
            suggest = "entity_guids"
        elif key == "nrqlQueries":
            suggest = "nrql_queries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadStatusConfigAutomaticRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadStatusConfigAutomaticRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadStatusConfigAutomaticRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rollup: 'outputs.WorkloadStatusConfigAutomaticRuleRollup',
                 entity_guids: Optional[Sequence[str]] = None,
                 nrql_queries: Optional[Sequence['outputs.WorkloadStatusConfigAutomaticRuleNrqlQuery']] = None):
        """
        :param 'WorkloadStatusConfigAutomaticRuleRollupArgs' rollup: The input object used to represent a rollup strategy. See Nested rollup blocks below for details.
        :param Sequence[str] entity_guids: A list of entity GUIDs composing the rule. At least one of `entity_guids` or `nrql_query` must be defined.
        :param Sequence['WorkloadStatusConfigAutomaticRuleNrqlQueryArgs'] nrql_queries: A list of entity search queries used to retrieve the entities that compose the rule. See Nested nrql_query blocks below for details. At least one of `entity_guids` or `nrql_query` must be defined.
        """
        pulumi.set(__self__, "rollup", rollup)
        if entity_guids is not None:
            pulumi.set(__self__, "entity_guids", entity_guids)
        if nrql_queries is not None:
            pulumi.set(__self__, "nrql_queries", nrql_queries)

    @property
    @pulumi.getter
    def rollup(self) -> 'outputs.WorkloadStatusConfigAutomaticRuleRollup':
        """
        The input object used to represent a rollup strategy. See Nested rollup blocks below for details.
        """
        return pulumi.get(self, "rollup")

    @property
    @pulumi.getter(name="entityGuids")
    def entity_guids(self) -> Optional[Sequence[str]]:
        """
        A list of entity GUIDs composing the rule. At least one of `entity_guids` or `nrql_query` must be defined.
        """
        return pulumi.get(self, "entity_guids")

    @property
    @pulumi.getter(name="nrqlQueries")
    def nrql_queries(self) -> Optional[Sequence['outputs.WorkloadStatusConfigAutomaticRuleNrqlQuery']]:
        """
        A list of entity search queries used to retrieve the entities that compose the rule. See Nested nrql_query blocks below for details. At least one of `entity_guids` or `nrql_query` must be defined.
        """
        return pulumi.get(self, "nrql_queries")


@pulumi.output_type
class WorkloadStatusConfigAutomaticRuleNrqlQuery(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The entity search query that is used to perform the search of a group of entities.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The entity search query that is used to perform the search of a group of entities.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class WorkloadStatusConfigAutomaticRuleRollup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdType":
            suggest = "threshold_type"
        elif key == "thresholdValue":
            suggest = "threshold_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadStatusConfigAutomaticRuleRollup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadStatusConfigAutomaticRuleRollup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadStatusConfigAutomaticRuleRollup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 strategy: str,
                 threshold_type: Optional[str] = None,
                 threshold_value: Optional[int] = None):
        """
        :param str strategy: The rollup strategy that is applied to a group of entities.
        :param str threshold_type: Type of threshold defined for the rule. This is an optional field that only applies when strategy is WORST_STATUS_WINS. Use a threshold to roll up the worst status only after a certain amount of entities are not operational.
        :param int threshold_value: Threshold value defined for the rule. This optional field is used in combination with thresholdType. If the threshold type is null, the threshold value will be ignored.
        """
        pulumi.set(__self__, "strategy", strategy)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)
        if threshold_value is not None:
            pulumi.set(__self__, "threshold_value", threshold_value)

    @property
    @pulumi.getter
    def strategy(self) -> str:
        """
        The rollup strategy that is applied to a group of entities.
        """
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[str]:
        """
        Type of threshold defined for the rule. This is an optional field that only applies when strategy is WORST_STATUS_WINS. Use a threshold to roll up the worst status only after a certain amount of entities are not operational.
        """
        return pulumi.get(self, "threshold_type")

    @property
    @pulumi.getter(name="thresholdValue")
    def threshold_value(self) -> Optional[int]:
        """
        Threshold value defined for the rule. This optional field is used in combination with thresholdType. If the threshold type is null, the threshold value will be ignored.
        """
        return pulumi.get(self, "threshold_value")


@pulumi.output_type
class WorkloadStatusConfigStatic(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 status: str,
                 description: Optional[str] = None,
                 summary: Optional[str] = None):
        """
        :param bool enabled: Whether the static status configuration is enabled or not.
        :param str status: The status of the workload.
        :param str description: Relevant information about the workload.
        :param str summary: A short description of the status of the workload.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "status", status)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if summary is not None:
            pulumi.set(__self__, "summary", summary)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether the static status configuration is enabled or not.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the workload.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Relevant information about the workload.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def summary(self) -> Optional[str]:
        """
        A short description of the status of the workload.
        """
        return pulumi.get(self, "summary")


