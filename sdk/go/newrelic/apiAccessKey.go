// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package newrelic

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Import
//
// Existing API access keys can be imported using a composite ID of `<api_access_key_id>:<key_type>`, where `<key_type>` is either `INGEST` or `USER`. Refer to the considerations listed in the Important Considerations section above regarding limitations on importing the actual key value.
//
// For example:
//
// ```sh
// $ pulumi import newrelic:index/apiAccessKey:ApiAccessKey foobar "131313133A331313130B5F13DF01313FDB13B13133EE5E133D13EAAB3A3C13D3:INGEST"
// ```
//
// For customers using Terraform v1.5 and above, it is recommended to use the `import {}` block in your Terraform configuration. This allows Terraform to generate the resource configuration automatically during the import process by running a `pulumi preview -generate-config-out=<filename>.tf`, reducing manual effort and ensuring accuracy.
//
// For example:
//
// hcl
//
// import {
//
//	id = "131313133A331313130B5F13DF01313FDB13B13133EE5E133D13EAAB3A3C13D3:INGEST"
//
//	to = newrelic_api_access_key.foobar
//
// }
//
// This approach simplifies the import process and ensures that the resource configuration aligns with the imported state.
type ApiAccessKey struct {
	pulumi.CustomResourceState

	// The New Relic account ID where the API access key will be created.
	AccountId pulumi.StringPtrOutput `pulumi:"accountId"`
	// Required if `keyType` is `INGEST`. Valid options are `BROWSER` or `LICENSE` (case-sensitive).
	IngestType pulumi.StringOutput `pulumi:"ingestType"`
	// The actual API key.
	// - <span style="color:tomato;">It is important to exercise caution when exporting the value of `key`, as it is sensitive information</span>. Avoid logging or exposing it inappropriately.
	Key pulumi.StringOutput `pulumi:"key"`
	// The type of API key to create. Valid options are `INGEST` or `USER` (case-sensitive).
	// - If `keyType` is `INGEST`, then `ingestType` must be specified.
	// - If `keyType` is `USER`, then `userId` must be specified.
	KeyType pulumi.StringOutput `pulumi:"keyType"`
	Name    pulumi.StringOutput `pulumi:"name"`
	// Additional notes about the API access key.
	Notes pulumi.StringOutput `pulumi:"notes"`
	// Required if `keyType` is `USER`. The New Relic user ID for which the API access key will be created.
	UserId pulumi.StringOutput `pulumi:"userId"`
}

// NewApiAccessKey registers a new resource with the given unique name, arguments, and options.
func NewApiAccessKey(ctx *pulumi.Context,
	name string, args *ApiAccessKeyArgs, opts ...pulumi.ResourceOption) (*ApiAccessKey, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.KeyType == nil {
		return nil, errors.New("invalid value for required argument 'KeyType'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ApiAccessKey
	err := ctx.RegisterResource("newrelic:index/apiAccessKey:ApiAccessKey", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetApiAccessKey gets an existing ApiAccessKey resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetApiAccessKey(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ApiAccessKeyState, opts ...pulumi.ResourceOption) (*ApiAccessKey, error) {
	var resource ApiAccessKey
	err := ctx.ReadResource("newrelic:index/apiAccessKey:ApiAccessKey", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ApiAccessKey resources.
type apiAccessKeyState struct {
	// The New Relic account ID where the API access key will be created.
	AccountId *string `pulumi:"accountId"`
	// Required if `keyType` is `INGEST`. Valid options are `BROWSER` or `LICENSE` (case-sensitive).
	IngestType *string `pulumi:"ingestType"`
	// The actual API key.
	// - <span style="color:tomato;">It is important to exercise caution when exporting the value of `key`, as it is sensitive information</span>. Avoid logging or exposing it inappropriately.
	Key *string `pulumi:"key"`
	// The type of API key to create. Valid options are `INGEST` or `USER` (case-sensitive).
	// - If `keyType` is `INGEST`, then `ingestType` must be specified.
	// - If `keyType` is `USER`, then `userId` must be specified.
	KeyType *string `pulumi:"keyType"`
	Name    *string `pulumi:"name"`
	// Additional notes about the API access key.
	Notes *string `pulumi:"notes"`
	// Required if `keyType` is `USER`. The New Relic user ID for which the API access key will be created.
	UserId *string `pulumi:"userId"`
}

type ApiAccessKeyState struct {
	// The New Relic account ID where the API access key will be created.
	AccountId pulumi.StringPtrInput
	// Required if `keyType` is `INGEST`. Valid options are `BROWSER` or `LICENSE` (case-sensitive).
	IngestType pulumi.StringPtrInput
	// The actual API key.
	// - <span style="color:tomato;">It is important to exercise caution when exporting the value of `key`, as it is sensitive information</span>. Avoid logging or exposing it inappropriately.
	Key pulumi.StringPtrInput
	// The type of API key to create. Valid options are `INGEST` or `USER` (case-sensitive).
	// - If `keyType` is `INGEST`, then `ingestType` must be specified.
	// - If `keyType` is `USER`, then `userId` must be specified.
	KeyType pulumi.StringPtrInput
	Name    pulumi.StringPtrInput
	// Additional notes about the API access key.
	Notes pulumi.StringPtrInput
	// Required if `keyType` is `USER`. The New Relic user ID for which the API access key will be created.
	UserId pulumi.StringPtrInput
}

func (ApiAccessKeyState) ElementType() reflect.Type {
	return reflect.TypeOf((*apiAccessKeyState)(nil)).Elem()
}

type apiAccessKeyArgs struct {
	// The New Relic account ID where the API access key will be created.
	AccountId *string `pulumi:"accountId"`
	// Required if `keyType` is `INGEST`. Valid options are `BROWSER` or `LICENSE` (case-sensitive).
	IngestType *string `pulumi:"ingestType"`
	// The type of API key to create. Valid options are `INGEST` or `USER` (case-sensitive).
	// - If `keyType` is `INGEST`, then `ingestType` must be specified.
	// - If `keyType` is `USER`, then `userId` must be specified.
	KeyType string  `pulumi:"keyType"`
	Name    *string `pulumi:"name"`
	// Additional notes about the API access key.
	Notes *string `pulumi:"notes"`
	// Required if `keyType` is `USER`. The New Relic user ID for which the API access key will be created.
	UserId *string `pulumi:"userId"`
}

// The set of arguments for constructing a ApiAccessKey resource.
type ApiAccessKeyArgs struct {
	// The New Relic account ID where the API access key will be created.
	AccountId pulumi.StringPtrInput
	// Required if `keyType` is `INGEST`. Valid options are `BROWSER` or `LICENSE` (case-sensitive).
	IngestType pulumi.StringPtrInput
	// The type of API key to create. Valid options are `INGEST` or `USER` (case-sensitive).
	// - If `keyType` is `INGEST`, then `ingestType` must be specified.
	// - If `keyType` is `USER`, then `userId` must be specified.
	KeyType pulumi.StringInput
	Name    pulumi.StringPtrInput
	// Additional notes about the API access key.
	Notes pulumi.StringPtrInput
	// Required if `keyType` is `USER`. The New Relic user ID for which the API access key will be created.
	UserId pulumi.StringPtrInput
}

func (ApiAccessKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*apiAccessKeyArgs)(nil)).Elem()
}

type ApiAccessKeyInput interface {
	pulumi.Input

	ToApiAccessKeyOutput() ApiAccessKeyOutput
	ToApiAccessKeyOutputWithContext(ctx context.Context) ApiAccessKeyOutput
}

func (*ApiAccessKey) ElementType() reflect.Type {
	return reflect.TypeOf((**ApiAccessKey)(nil)).Elem()
}

func (i *ApiAccessKey) ToApiAccessKeyOutput() ApiAccessKeyOutput {
	return i.ToApiAccessKeyOutputWithContext(context.Background())
}

func (i *ApiAccessKey) ToApiAccessKeyOutputWithContext(ctx context.Context) ApiAccessKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApiAccessKeyOutput)
}

// ApiAccessKeyArrayInput is an input type that accepts ApiAccessKeyArray and ApiAccessKeyArrayOutput values.
// You can construct a concrete instance of `ApiAccessKeyArrayInput` via:
//
//	ApiAccessKeyArray{ ApiAccessKeyArgs{...} }
type ApiAccessKeyArrayInput interface {
	pulumi.Input

	ToApiAccessKeyArrayOutput() ApiAccessKeyArrayOutput
	ToApiAccessKeyArrayOutputWithContext(context.Context) ApiAccessKeyArrayOutput
}

type ApiAccessKeyArray []ApiAccessKeyInput

func (ApiAccessKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ApiAccessKey)(nil)).Elem()
}

func (i ApiAccessKeyArray) ToApiAccessKeyArrayOutput() ApiAccessKeyArrayOutput {
	return i.ToApiAccessKeyArrayOutputWithContext(context.Background())
}

func (i ApiAccessKeyArray) ToApiAccessKeyArrayOutputWithContext(ctx context.Context) ApiAccessKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApiAccessKeyArrayOutput)
}

// ApiAccessKeyMapInput is an input type that accepts ApiAccessKeyMap and ApiAccessKeyMapOutput values.
// You can construct a concrete instance of `ApiAccessKeyMapInput` via:
//
//	ApiAccessKeyMap{ "key": ApiAccessKeyArgs{...} }
type ApiAccessKeyMapInput interface {
	pulumi.Input

	ToApiAccessKeyMapOutput() ApiAccessKeyMapOutput
	ToApiAccessKeyMapOutputWithContext(context.Context) ApiAccessKeyMapOutput
}

type ApiAccessKeyMap map[string]ApiAccessKeyInput

func (ApiAccessKeyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ApiAccessKey)(nil)).Elem()
}

func (i ApiAccessKeyMap) ToApiAccessKeyMapOutput() ApiAccessKeyMapOutput {
	return i.ToApiAccessKeyMapOutputWithContext(context.Background())
}

func (i ApiAccessKeyMap) ToApiAccessKeyMapOutputWithContext(ctx context.Context) ApiAccessKeyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApiAccessKeyMapOutput)
}

type ApiAccessKeyOutput struct{ *pulumi.OutputState }

func (ApiAccessKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApiAccessKey)(nil)).Elem()
}

func (o ApiAccessKeyOutput) ToApiAccessKeyOutput() ApiAccessKeyOutput {
	return o
}

func (o ApiAccessKeyOutput) ToApiAccessKeyOutputWithContext(ctx context.Context) ApiAccessKeyOutput {
	return o
}

// The New Relic account ID where the API access key will be created.
func (o ApiAccessKeyOutput) AccountId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApiAccessKey) pulumi.StringPtrOutput { return v.AccountId }).(pulumi.StringPtrOutput)
}

// Required if `keyType` is `INGEST`. Valid options are `BROWSER` or `LICENSE` (case-sensitive).
func (o ApiAccessKeyOutput) IngestType() pulumi.StringOutput {
	return o.ApplyT(func(v *ApiAccessKey) pulumi.StringOutput { return v.IngestType }).(pulumi.StringOutput)
}

// The actual API key.
// - <span style="color:tomato;">It is important to exercise caution when exporting the value of `key`, as it is sensitive information</span>. Avoid logging or exposing it inappropriately.
func (o ApiAccessKeyOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v *ApiAccessKey) pulumi.StringOutput { return v.Key }).(pulumi.StringOutput)
}

// The type of API key to create. Valid options are `INGEST` or `USER` (case-sensitive).
// - If `keyType` is `INGEST`, then `ingestType` must be specified.
// - If `keyType` is `USER`, then `userId` must be specified.
func (o ApiAccessKeyOutput) KeyType() pulumi.StringOutput {
	return o.ApplyT(func(v *ApiAccessKey) pulumi.StringOutput { return v.KeyType }).(pulumi.StringOutput)
}

func (o ApiAccessKeyOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ApiAccessKey) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Additional notes about the API access key.
func (o ApiAccessKeyOutput) Notes() pulumi.StringOutput {
	return o.ApplyT(func(v *ApiAccessKey) pulumi.StringOutput { return v.Notes }).(pulumi.StringOutput)
}

// Required if `keyType` is `USER`. The New Relic user ID for which the API access key will be created.
func (o ApiAccessKeyOutput) UserId() pulumi.StringOutput {
	return o.ApplyT(func(v *ApiAccessKey) pulumi.StringOutput { return v.UserId }).(pulumi.StringOutput)
}

type ApiAccessKeyArrayOutput struct{ *pulumi.OutputState }

func (ApiAccessKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ApiAccessKey)(nil)).Elem()
}

func (o ApiAccessKeyArrayOutput) ToApiAccessKeyArrayOutput() ApiAccessKeyArrayOutput {
	return o
}

func (o ApiAccessKeyArrayOutput) ToApiAccessKeyArrayOutputWithContext(ctx context.Context) ApiAccessKeyArrayOutput {
	return o
}

func (o ApiAccessKeyArrayOutput) Index(i pulumi.IntInput) ApiAccessKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ApiAccessKey {
		return vs[0].([]*ApiAccessKey)[vs[1].(int)]
	}).(ApiAccessKeyOutput)
}

type ApiAccessKeyMapOutput struct{ *pulumi.OutputState }

func (ApiAccessKeyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ApiAccessKey)(nil)).Elem()
}

func (o ApiAccessKeyMapOutput) ToApiAccessKeyMapOutput() ApiAccessKeyMapOutput {
	return o
}

func (o ApiAccessKeyMapOutput) ToApiAccessKeyMapOutputWithContext(ctx context.Context) ApiAccessKeyMapOutput {
	return o
}

func (o ApiAccessKeyMapOutput) MapIndex(k pulumi.StringInput) ApiAccessKeyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ApiAccessKey {
		return vs[0].(map[string]*ApiAccessKey)[vs[1].(string)]
	}).(ApiAccessKeyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ApiAccessKeyInput)(nil)).Elem(), &ApiAccessKey{})
	pulumi.RegisterInputType(reflect.TypeOf((*ApiAccessKeyArrayInput)(nil)).Elem(), ApiAccessKeyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ApiAccessKeyMapInput)(nil)).Elem(), ApiAccessKeyMap{})
	pulumi.RegisterOutputType(ApiAccessKeyOutput{})
	pulumi.RegisterOutputType(ApiAccessKeyArrayOutput{})
	pulumi.RegisterOutputType(ApiAccessKeyMapOutput{})
}
