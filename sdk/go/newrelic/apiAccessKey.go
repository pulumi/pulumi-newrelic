// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package newrelic

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Use this resource to programmatically create and manage the following types of keys in New Relic:
// - [User API keys](https://docs.newrelic.com/docs/apis/get-started/intro-apis/types-new-relic-api-keys#user-api-key)
// - License (or ingest) keys, including:
//   - General (Ingest) [license keys](https://docs.newrelic.com/docs/accounts/install-new-relic/account-setup/license-key) used for APM
//   - [Browser license keys](https://docs.newrelic.com/docs/browser/new-relic-browser/configuration/copy-browser-monitoring-license-key-app-id)
//
// Refer to the New Relic article ['Use NerdGraph to manage license keys and User API keys'](https://docs.newrelic.com/docs/apis/nerdgraph/examples/use-nerdgraph-manage-license-keys-user-keys) for detailed information.
//
// > **WARNING:** When creating a User API key, if a <span style="color:tomato;">truncated API key</span> appears in the state after the first `pulumi up`, it is likely because the API key was created for a user other than the one running Terraform. This is a security measure by the New Relic API to _prevent exposing the full key value when an API key is created for another user_. See the Important Considerations section below for more details.
//
// ## Example Usage
//
// ### Example: Creating a User API Key
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := newrelic.NewApiAccessKey(ctx, "user_api_key", &newrelic.ApiAccessKeyArgs{
//				AccountId: pulumi.String("1234321"),
//				KeyType:   pulumi.String("USER"),
//				UserId:    pulumi.String("1001111101"),
//				Name:      pulumi.String("User API Key for Admin Access"),
//				Notes:     pulumi.String("This key is used for managing user-level API access."),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Example: Creating an Ingest License Key
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := newrelic.NewApiAccessKey(ctx, "ingest_license_key", &newrelic.ApiAccessKeyArgs{
//				AccountId:  pulumi.String("1234321"),
//				KeyType:    pulumi.String("INGEST"),
//				IngestType: pulumi.String("LICENSE"),
//				Name:       pulumi.String("Ingest License Key for App Monitoring"),
//				Notes:      pulumi.String("This key is used for APM and other ingest purposes."),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Example: Creating an Ingest Browser Key
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := newrelic.NewApiAccessKey(ctx, "ingest_browser_key", &newrelic.ApiAccessKeyArgs{
//				AccountId:  pulumi.String("1234321"),
//				KeyType:    pulumi.String("INGEST"),
//				IngestType: pulumi.String("BROWSER"),
//				Name:       pulumi.String("Browser Monitoring Key"),
//				Notes:      pulumi.String("This key is used for browser monitoring and analytics."),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Important Considerations
//
// #### Updating Existing Keys
// - Only `name` and `notes` can be updated in place. Changes to other attributes will recreate the key (the `ApiAccessKey` resource), invalidating the existing one.
//
// #### Creating API Keys for Other Users
// - If an API key is created for a user other than the owner of the API key used to run Terraform, the full key value will not be returned by the API for security reasons. Instead, a truncated version of the key will be provided. To retrieve the full key, ensure the necessary capabilities and access management settings are applied to the user running Terraform. For more details, contact New Relic Support.
//
// #### Importing Existing Keys into Terraform State
// - A key may be imported with its ID using the syntax described in the Import section below. However, the actual value of the key _cannot be imported_ if the key being fetched was created by a user other than the one whose API key is being used to run Terraform. In such cases, the API returns a truncated key for security reasons. For more details, see [Use NerdGraph to manage license keys and User API keys](https://docs.newrelic.com/docs/apis/nerdgraph/examples/use-nerdgraph-manage-license-keys-user-keys/#query-keys).
//
// #### Account Type Restrictions for Ingest Keys
// - Creating `INGEST` keys requires a New Relic user with core or full platform access. See [user types](https://docs.newrelic.com/docs/accounts/accounts-billing/new-relic-one-user-management/user-type/#api-access).
//
// ## Import
//
// Existing API access keys can be imported using a composite ID of `<api_access_key_id>:<key_type>`, where `<key_type>` is either `INGEST` or `USER`. Refer to the considerations listed in the Important Considerations section above regarding limitations on importing the actual key value.
//
// For example:
// ```sh
// $ pulumi import newrelic:index/apiAccessKey:ApiAccessKey foobar "131313133A331313130B5F13DF01313FDB13B13133EE5E133D13EAAB3A3C13D3:INGEST"
// ```
//
// For customers using Terraform v1.5 and above, it is recommended to use the `import {}` block in your Terraform configuration. This allows Terraform to generate the resource configuration automatically during the import process by running a `pulumi preview -generate-config-out=<filename>.tf`, reducing manual effort and ensuring accuracy.
//
// For example:
type ApiAccessKey struct {
	pulumi.CustomResourceState

	// The New Relic account ID where the API access key will be created.
	AccountId pulumi.StringPtrOutput `pulumi:"accountId"`
	// Required if `keyType` is `INGEST`. Valid options are `BROWSER` or `LICENSE` (case-sensitive).
	IngestType pulumi.StringOutput `pulumi:"ingestType"`
	// The actual API key.
	// - <span style="color:tomato;">It is important to exercise caution when exporting the value of `key`, as it is sensitive information</span>. Avoid logging or exposing it inappropriately.
	Key pulumi.StringOutput `pulumi:"key"`
	// The type of API key to create. Valid options are `INGEST` or `USER` (case-sensitive).
	// - If `keyType` is `INGEST`, then `ingestType` must be specified.
	// - If `keyType` is `USER`, then `userId` must be specified.
	KeyType pulumi.StringOutput `pulumi:"keyType"`
	// The name of the API key.
	// - **Note**: While `name` is optional, it is <b style="color:red;">\*\*strongly recommended\*\*</b> to provide a meaningful name for easier identification and management of keys. If a `name` is not provided, the API will assign a default name when processing the request to create the API key, which may cause unexpected drift in your Terraform state. To prevent this, it is best practice to always specify a `name`.
	Name pulumi.StringOutput `pulumi:"name"`
	// Additional notes about the API access key.
	Notes pulumi.StringOutput `pulumi:"notes"`
	// Required if `keyType` is `USER`. The New Relic user ID for which the API access key will be created.
	UserId pulumi.StringOutput `pulumi:"userId"`
}

// NewApiAccessKey registers a new resource with the given unique name, arguments, and options.
func NewApiAccessKey(ctx *pulumi.Context,
	name string, args *ApiAccessKeyArgs, opts ...pulumi.ResourceOption) (*ApiAccessKey, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.KeyType == nil {
		return nil, errors.New("invalid value for required argument 'KeyType'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ApiAccessKey
	err := ctx.RegisterResource("newrelic:index/apiAccessKey:ApiAccessKey", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetApiAccessKey gets an existing ApiAccessKey resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetApiAccessKey(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ApiAccessKeyState, opts ...pulumi.ResourceOption) (*ApiAccessKey, error) {
	var resource ApiAccessKey
	err := ctx.ReadResource("newrelic:index/apiAccessKey:ApiAccessKey", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ApiAccessKey resources.
type apiAccessKeyState struct {
	// The New Relic account ID where the API access key will be created.
	AccountId *string `pulumi:"accountId"`
	// Required if `keyType` is `INGEST`. Valid options are `BROWSER` or `LICENSE` (case-sensitive).
	IngestType *string `pulumi:"ingestType"`
	// The actual API key.
	// - <span style="color:tomato;">It is important to exercise caution when exporting the value of `key`, as it is sensitive information</span>. Avoid logging or exposing it inappropriately.
	Key *string `pulumi:"key"`
	// The type of API key to create. Valid options are `INGEST` or `USER` (case-sensitive).
	// - If `keyType` is `INGEST`, then `ingestType` must be specified.
	// - If `keyType` is `USER`, then `userId` must be specified.
	KeyType *string `pulumi:"keyType"`
	// The name of the API key.
	// - **Note**: While `name` is optional, it is <b style="color:red;">\*\*strongly recommended\*\*</b> to provide a meaningful name for easier identification and management of keys. If a `name` is not provided, the API will assign a default name when processing the request to create the API key, which may cause unexpected drift in your Terraform state. To prevent this, it is best practice to always specify a `name`.
	Name *string `pulumi:"name"`
	// Additional notes about the API access key.
	Notes *string `pulumi:"notes"`
	// Required if `keyType` is `USER`. The New Relic user ID for which the API access key will be created.
	UserId *string `pulumi:"userId"`
}

type ApiAccessKeyState struct {
	// The New Relic account ID where the API access key will be created.
	AccountId pulumi.StringPtrInput
	// Required if `keyType` is `INGEST`. Valid options are `BROWSER` or `LICENSE` (case-sensitive).
	IngestType pulumi.StringPtrInput
	// The actual API key.
	// - <span style="color:tomato;">It is important to exercise caution when exporting the value of `key`, as it is sensitive information</span>. Avoid logging or exposing it inappropriately.
	Key pulumi.StringPtrInput
	// The type of API key to create. Valid options are `INGEST` or `USER` (case-sensitive).
	// - If `keyType` is `INGEST`, then `ingestType` must be specified.
	// - If `keyType` is `USER`, then `userId` must be specified.
	KeyType pulumi.StringPtrInput
	// The name of the API key.
	// - **Note**: While `name` is optional, it is <b style="color:red;">\*\*strongly recommended\*\*</b> to provide a meaningful name for easier identification and management of keys. If a `name` is not provided, the API will assign a default name when processing the request to create the API key, which may cause unexpected drift in your Terraform state. To prevent this, it is best practice to always specify a `name`.
	Name pulumi.StringPtrInput
	// Additional notes about the API access key.
	Notes pulumi.StringPtrInput
	// Required if `keyType` is `USER`. The New Relic user ID for which the API access key will be created.
	UserId pulumi.StringPtrInput
}

func (ApiAccessKeyState) ElementType() reflect.Type {
	return reflect.TypeOf((*apiAccessKeyState)(nil)).Elem()
}

type apiAccessKeyArgs struct {
	// The New Relic account ID where the API access key will be created.
	AccountId *string `pulumi:"accountId"`
	// Required if `keyType` is `INGEST`. Valid options are `BROWSER` or `LICENSE` (case-sensitive).
	IngestType *string `pulumi:"ingestType"`
	// The type of API key to create. Valid options are `INGEST` or `USER` (case-sensitive).
	// - If `keyType` is `INGEST`, then `ingestType` must be specified.
	// - If `keyType` is `USER`, then `userId` must be specified.
	KeyType string `pulumi:"keyType"`
	// The name of the API key.
	// - **Note**: While `name` is optional, it is <b style="color:red;">\*\*strongly recommended\*\*</b> to provide a meaningful name for easier identification and management of keys. If a `name` is not provided, the API will assign a default name when processing the request to create the API key, which may cause unexpected drift in your Terraform state. To prevent this, it is best practice to always specify a `name`.
	Name *string `pulumi:"name"`
	// Additional notes about the API access key.
	Notes *string `pulumi:"notes"`
	// Required if `keyType` is `USER`. The New Relic user ID for which the API access key will be created.
	UserId *string `pulumi:"userId"`
}

// The set of arguments for constructing a ApiAccessKey resource.
type ApiAccessKeyArgs struct {
	// The New Relic account ID where the API access key will be created.
	AccountId pulumi.StringPtrInput
	// Required if `keyType` is `INGEST`. Valid options are `BROWSER` or `LICENSE` (case-sensitive).
	IngestType pulumi.StringPtrInput
	// The type of API key to create. Valid options are `INGEST` or `USER` (case-sensitive).
	// - If `keyType` is `INGEST`, then `ingestType` must be specified.
	// - If `keyType` is `USER`, then `userId` must be specified.
	KeyType pulumi.StringInput
	// The name of the API key.
	// - **Note**: While `name` is optional, it is <b style="color:red;">\*\*strongly recommended\*\*</b> to provide a meaningful name for easier identification and management of keys. If a `name` is not provided, the API will assign a default name when processing the request to create the API key, which may cause unexpected drift in your Terraform state. To prevent this, it is best practice to always specify a `name`.
	Name pulumi.StringPtrInput
	// Additional notes about the API access key.
	Notes pulumi.StringPtrInput
	// Required if `keyType` is `USER`. The New Relic user ID for which the API access key will be created.
	UserId pulumi.StringPtrInput
}

func (ApiAccessKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*apiAccessKeyArgs)(nil)).Elem()
}

type ApiAccessKeyInput interface {
	pulumi.Input

	ToApiAccessKeyOutput() ApiAccessKeyOutput
	ToApiAccessKeyOutputWithContext(ctx context.Context) ApiAccessKeyOutput
}

func (*ApiAccessKey) ElementType() reflect.Type {
	return reflect.TypeOf((**ApiAccessKey)(nil)).Elem()
}

func (i *ApiAccessKey) ToApiAccessKeyOutput() ApiAccessKeyOutput {
	return i.ToApiAccessKeyOutputWithContext(context.Background())
}

func (i *ApiAccessKey) ToApiAccessKeyOutputWithContext(ctx context.Context) ApiAccessKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApiAccessKeyOutput)
}

// ApiAccessKeyArrayInput is an input type that accepts ApiAccessKeyArray and ApiAccessKeyArrayOutput values.
// You can construct a concrete instance of `ApiAccessKeyArrayInput` via:
//
//	ApiAccessKeyArray{ ApiAccessKeyArgs{...} }
type ApiAccessKeyArrayInput interface {
	pulumi.Input

	ToApiAccessKeyArrayOutput() ApiAccessKeyArrayOutput
	ToApiAccessKeyArrayOutputWithContext(context.Context) ApiAccessKeyArrayOutput
}

type ApiAccessKeyArray []ApiAccessKeyInput

func (ApiAccessKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ApiAccessKey)(nil)).Elem()
}

func (i ApiAccessKeyArray) ToApiAccessKeyArrayOutput() ApiAccessKeyArrayOutput {
	return i.ToApiAccessKeyArrayOutputWithContext(context.Background())
}

func (i ApiAccessKeyArray) ToApiAccessKeyArrayOutputWithContext(ctx context.Context) ApiAccessKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApiAccessKeyArrayOutput)
}

// ApiAccessKeyMapInput is an input type that accepts ApiAccessKeyMap and ApiAccessKeyMapOutput values.
// You can construct a concrete instance of `ApiAccessKeyMapInput` via:
//
//	ApiAccessKeyMap{ "key": ApiAccessKeyArgs{...} }
type ApiAccessKeyMapInput interface {
	pulumi.Input

	ToApiAccessKeyMapOutput() ApiAccessKeyMapOutput
	ToApiAccessKeyMapOutputWithContext(context.Context) ApiAccessKeyMapOutput
}

type ApiAccessKeyMap map[string]ApiAccessKeyInput

func (ApiAccessKeyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ApiAccessKey)(nil)).Elem()
}

func (i ApiAccessKeyMap) ToApiAccessKeyMapOutput() ApiAccessKeyMapOutput {
	return i.ToApiAccessKeyMapOutputWithContext(context.Background())
}

func (i ApiAccessKeyMap) ToApiAccessKeyMapOutputWithContext(ctx context.Context) ApiAccessKeyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApiAccessKeyMapOutput)
}

type ApiAccessKeyOutput struct{ *pulumi.OutputState }

func (ApiAccessKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApiAccessKey)(nil)).Elem()
}

func (o ApiAccessKeyOutput) ToApiAccessKeyOutput() ApiAccessKeyOutput {
	return o
}

func (o ApiAccessKeyOutput) ToApiAccessKeyOutputWithContext(ctx context.Context) ApiAccessKeyOutput {
	return o
}

// The New Relic account ID where the API access key will be created.
func (o ApiAccessKeyOutput) AccountId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApiAccessKey) pulumi.StringPtrOutput { return v.AccountId }).(pulumi.StringPtrOutput)
}

// Required if `keyType` is `INGEST`. Valid options are `BROWSER` or `LICENSE` (case-sensitive).
func (o ApiAccessKeyOutput) IngestType() pulumi.StringOutput {
	return o.ApplyT(func(v *ApiAccessKey) pulumi.StringOutput { return v.IngestType }).(pulumi.StringOutput)
}

// The actual API key.
// - <span style="color:tomato;">It is important to exercise caution when exporting the value of `key`, as it is sensitive information</span>. Avoid logging or exposing it inappropriately.
func (o ApiAccessKeyOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v *ApiAccessKey) pulumi.StringOutput { return v.Key }).(pulumi.StringOutput)
}

// The type of API key to create. Valid options are `INGEST` or `USER` (case-sensitive).
// - If `keyType` is `INGEST`, then `ingestType` must be specified.
// - If `keyType` is `USER`, then `userId` must be specified.
func (o ApiAccessKeyOutput) KeyType() pulumi.StringOutput {
	return o.ApplyT(func(v *ApiAccessKey) pulumi.StringOutput { return v.KeyType }).(pulumi.StringOutput)
}

// The name of the API key.
// - **Note**: While `name` is optional, it is <b style="color:red;">\*\*strongly recommended\*\*</b> to provide a meaningful name for easier identification and management of keys. If a `name` is not provided, the API will assign a default name when processing the request to create the API key, which may cause unexpected drift in your Terraform state. To prevent this, it is best practice to always specify a `name`.
func (o ApiAccessKeyOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ApiAccessKey) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Additional notes about the API access key.
func (o ApiAccessKeyOutput) Notes() pulumi.StringOutput {
	return o.ApplyT(func(v *ApiAccessKey) pulumi.StringOutput { return v.Notes }).(pulumi.StringOutput)
}

// Required if `keyType` is `USER`. The New Relic user ID for which the API access key will be created.
func (o ApiAccessKeyOutput) UserId() pulumi.StringOutput {
	return o.ApplyT(func(v *ApiAccessKey) pulumi.StringOutput { return v.UserId }).(pulumi.StringOutput)
}

type ApiAccessKeyArrayOutput struct{ *pulumi.OutputState }

func (ApiAccessKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ApiAccessKey)(nil)).Elem()
}

func (o ApiAccessKeyArrayOutput) ToApiAccessKeyArrayOutput() ApiAccessKeyArrayOutput {
	return o
}

func (o ApiAccessKeyArrayOutput) ToApiAccessKeyArrayOutputWithContext(ctx context.Context) ApiAccessKeyArrayOutput {
	return o
}

func (o ApiAccessKeyArrayOutput) Index(i pulumi.IntInput) ApiAccessKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ApiAccessKey {
		return vs[0].([]*ApiAccessKey)[vs[1].(int)]
	}).(ApiAccessKeyOutput)
}

type ApiAccessKeyMapOutput struct{ *pulumi.OutputState }

func (ApiAccessKeyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ApiAccessKey)(nil)).Elem()
}

func (o ApiAccessKeyMapOutput) ToApiAccessKeyMapOutput() ApiAccessKeyMapOutput {
	return o
}

func (o ApiAccessKeyMapOutput) ToApiAccessKeyMapOutputWithContext(ctx context.Context) ApiAccessKeyMapOutput {
	return o
}

func (o ApiAccessKeyMapOutput) MapIndex(k pulumi.StringInput) ApiAccessKeyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ApiAccessKey {
		return vs[0].(map[string]*ApiAccessKey)[vs[1].(string)]
	}).(ApiAccessKeyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ApiAccessKeyInput)(nil)).Elem(), &ApiAccessKey{})
	pulumi.RegisterInputType(reflect.TypeOf((*ApiAccessKeyArrayInput)(nil)).Elem(), ApiAccessKeyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ApiAccessKeyMapInput)(nil)).Elem(), ApiAccessKeyMap{})
	pulumi.RegisterOutputType(ApiAccessKeyOutput{})
	pulumi.RegisterOutputType(ApiAccessKeyArrayOutput{})
	pulumi.RegisterOutputType(ApiAccessKeyMapOutput{})
}
