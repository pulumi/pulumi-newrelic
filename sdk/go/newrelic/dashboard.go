// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package newrelic

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// Use this resource to create and manage New Relic dashboards.
//
// ## Example Usage
// ### Create A New Relic Dashboard
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-newrelic/sdk/v3/go/newrelic"
// 	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		opt0 := "APPLICATION"
// 		opt1 := "APM"
// 		myApplication, err := newrelic.GetEntity(ctx, &newrelic.GetEntityArgs{
// 			Name:   "My Application",
// 			Type:   &opt0,
// 			Domain: &opt1,
// 		}, nil)
// 		if err != nil {
// 			return err
// 		}
// 		_, err = newrelic.NewDashboard(ctx, "exampledash", &newrelic.DashboardArgs{
// 			Title: pulumi.String("New Relic Terraform Example"),
// 			Filter: &newrelic.DashboardFilterArgs{
// 				EventTypes: pulumi.StringArray{
// 					pulumi.String("Transaction"),
// 				},
// 				Attributes: pulumi.StringArray{
// 					pulumi.String("appName"),
// 					pulumi.String("name"),
// 				},
// 			},
// 			Widgets: newrelic.DashboardWidgetArray{
// 				&newrelic.DashboardWidgetArgs{
// 					Title:         pulumi.String("Requests per minute"),
// 					Visualization: pulumi.String("billboard"),
// 					Nrql:          pulumi.String("SELECT rate(count(*), 1 minute) FROM Transaction"),
// 					Row:           pulumi.Int(1),
// 					Column:        pulumi.Int(1),
// 				},
// 				&newrelic.DashboardWidgetArgs{
// 					Title:         pulumi.String("Error rate"),
// 					Visualization: pulumi.String("gauge"),
// 					Nrql:          pulumi.String("SELECT percentage(count(*), WHERE error IS True) FROM Transaction"),
// 					ThresholdRed:  pulumi.Float64(2.5),
// 					Row:           pulumi.Int(1),
// 					Column:        pulumi.Int(2),
// 				},
// 				&newrelic.DashboardWidgetArgs{
// 					Title:         pulumi.String("Average transaction duration, by application"),
// 					Visualization: pulumi.String("facet_bar_chart"),
// 					Nrql:          pulumi.String("SELECT average(duration) FROM Transaction FACET appName"),
// 					Row:           pulumi.Int(1),
// 					Column:        pulumi.Int(3),
// 				},
// 				&newrelic.DashboardWidgetArgs{
// 					Title:         pulumi.String("Apdex, top 5 by host"),
// 					Duration:      pulumi.Int(1800000),
// 					Visualization: pulumi.String("metric_line_chart"),
// 					EntityIds: pulumi.IntArray{
// 						pulumi.Int(myApplication.ApplicationId),
// 					},
// 					Metrics: newrelic.DashboardWidgetMetricArray{
// 						&newrelic.DashboardWidgetMetricArgs{
// 							Name: pulumi.String("Apdex"),
// 							Values: pulumi.StringArray{
// 								pulumi.String("score"),
// 							},
// 						},
// 					},
// 					Facet:   pulumi.String("host"),
// 					Limit:   pulumi.Int(5),
// 					OrderBy: pulumi.String("score"),
// 					Row:     pulumi.Int(2),
// 					Column:  pulumi.Int(1),
// 				},
// 				&newrelic.DashboardWidgetArgs{
// 					Title:         pulumi.String("Requests per minute, by transaction"),
// 					Visualization: pulumi.String("facet_table"),
// 					Nrql:          pulumi.String("SELECT rate(count(*), 1 minute) FROM Transaction FACET name"),
// 					Row:           pulumi.Int(2),
// 					Column:        pulumi.Int(2),
// 				},
// 				&newrelic.DashboardWidgetArgs{
// 					Title:         pulumi.String("Dashboard Note"),
// 					Visualization: pulumi.String("markdown"),
// 					Source:        pulumi.String("### Helpful Links\n\n* [New Relic One](https://one.newrelic.com)\n* [Developer Portal](https://developer.newrelic.com)"),
// 					Row:           pulumi.Int(2),
// 					Column:        pulumi.Int(3),
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// See additional examples.
// ## Additional Examples
//
// ### Create cross-account widgets in your dashboard.
//
// The example below shows how you can display data for an application from a primary account and an application from a subaccount. In order to create cross-account widgets, you must use an API key from a user with admin permissions in the primary account. Please see the `widget` attribute documentation for more details.
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-newrelic/sdk/v3/go/newrelic"
// 	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		opt0 := "APPLICATION"
// 		opt1 := "APM"
// 		primaryAccountApplication, err := newrelic.GetEntity(ctx, &newrelic.GetEntityArgs{
// 			Name:   "Main Account Application Name",
// 			Type:   &opt0,
// 			Domain: &opt1,
// 		}, nil)
// 		if err != nil {
// 			return err
// 		}
// 		opt2 := "APPLICATION"
// 		opt3 := "APM"
// 		subaccountApplication, err := newrelic.GetEntity(ctx, &newrelic.GetEntityArgs{
// 			Name:   "Subaccount Application Name",
// 			Type:   &opt2,
// 			Domain: &opt3,
// 		}, nil)
// 		if err != nil {
// 			return err
// 		}
// 		_, err = newrelic.NewDashboard(ctx, "crossAccountWidgetExample", &newrelic.DashboardArgs{
// 			Title: pulumi.String("tf-test-cross-account-widget-dashboard"),
// 			Filter: &newrelic.DashboardFilterArgs{
// 				EventTypes: pulumi.StringArray{
// 					pulumi.String("Transaction"),
// 				},
// 				Attributes: pulumi.StringArray{
// 					pulumi.String("appName"),
// 					pulumi.String("envName"),
// 				},
// 			},
// 			GridColumnCount: pulumi.Int(12),
// 			Widgets: newrelic.DashboardWidgetArray{
// 				&newrelic.DashboardWidgetArgs{
// 					Title:         pulumi.String("Apdex (primary account)"),
// 					Row:           pulumi.Int(1),
// 					Column:        pulumi.Int(1),
// 					Width:         pulumi.Int(6),
// 					Height:        pulumi.Int(3),
// 					Visualization: pulumi.String("metric_line_chart"),
// 					Duration:      pulumi.Int(1800000),
// 					Metrics: newrelic.DashboardWidgetMetricArray{
// 						&newrelic.DashboardWidgetMetricArgs{
// 							Name: pulumi.String("Apdex"),
// 							Values: pulumi.StringArray{
// 								pulumi.String("score"),
// 							},
// 						},
// 					},
// 					EntityIds: pulumi.IntArray{
// 						pulumi.Int(primaryAccountApplication.ApplicationId),
// 					},
// 				},
// 				&newrelic.DashboardWidgetArgs{
// 					AccountId:     pulumi.Any(_var.Subaccount_id),
// 					Title:         pulumi.String("Apdex (subaccount)"),
// 					Row:           pulumi.Int(1),
// 					Column:        pulumi.Int(7),
// 					Width:         pulumi.Int(6),
// 					Height:        pulumi.Int(3),
// 					Visualization: pulumi.String("metric_line_chart"),
// 					Duration:      pulumi.Int(1800000),
// 					Metrics: newrelic.DashboardWidgetMetricArray{
// 						&newrelic.DashboardWidgetMetricArgs{
// 							Name: pulumi.String("Apdex"),
// 							Values: pulumi.StringArray{
// 								pulumi.String("score"),
// 							},
// 						},
// 					},
// 					EntityIds: pulumi.IntArray{
// 						pulumi.Int(subaccountApplication.ApplicationId),
// 					},
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// New Relic dashboards can be imported using their ID, e.g.
//
// ```sh
//  $ pulumi import newrelic:index/dashboard:Dashboard my_dashboard 8675309
// ```
//
//  ~> **NOTE** Due to API restrictions, importing a dashboard resource will set the `grid_column_count` attribute to `3`. If your dashboard is a New Relic One dashboard _and_ uses a 12 column grid, you will need to make sure `grid_column_count` is set to `12` in your configuration, then run `terraform apply` after importing to sync remote state with Terraform state. Also note, cross-account widgets cannot be imported due to API restrictions.
type Dashboard struct {
	pulumi.CustomResourceState

	// The URL for viewing the dashboard.
	DashboardUrl pulumi.StringOutput `pulumi:"dashboardUrl"`
	// Determines who can edit the dashboard in an account. Valid values are `all`,  `editableByAll`, `editableByOwner`, or `readOnly`.  Defaults to `editableByAll`.
	Editable pulumi.StringPtrOutput `pulumi:"editable"`
	// A nested block that describes a dashboard filter.  Exactly one nested `filter` block is allowed. See Nested filter block below for details.
	Filter DashboardFilterPtrOutput `pulumi:"filter"`
	// The number of columns to use when organizing and displaying widgets. New Relic One supports a 3 column grid and a 12 column grid. New Relic Insights supports a 3 column grid.
	GridColumnCount pulumi.IntPtrOutput `pulumi:"gridColumnCount"`
	// The icon for the dashboard.  Valid values are `adjust`, `archive`, `bar-chart`, `bell`, `bolt`, `bug`, `bullhorn`, `bullseye`, `clock-o`, `cloud`, `cog`, `comments-o`, `crosshairs`, `dashboard`, `envelope`, `fire`, `flag`, `flask`, `globe`, `heart`, `leaf`, `legal`, `life-ring`, `line-chart`, `magic`, `mobile`, `money`, `none`, `paper-plane`, `pie-chart`, `puzzle-piece`, `road`, `rocket`, `shopping-cart`, `sitemap`, `sliders`, `tablet`, `thumbs-down`, `thumbs-up`, `trophy`, `usd`, `user`, and `users`.  Defaults to `bar-chart`.
	Icon pulumi.StringPtrOutput `pulumi:"icon"`
	// The title of the dashboard.
	Title pulumi.StringOutput `pulumi:"title"`
	// Determines who can see the dashboard in an account. Valid values are `all` or `owner`.  Defaults to `all`.
	Visibility pulumi.StringPtrOutput `pulumi:"visibility"`
	// A nested block that describes a visualization.  Up to 300 `widget` blocks are allowed in a dashboard definition. See Nested widget blocks below for details.
	Widgets DashboardWidgetArrayOutput `pulumi:"widgets"`
}

// NewDashboard registers a new resource with the given unique name, arguments, and options.
func NewDashboard(ctx *pulumi.Context,
	name string, args *DashboardArgs, opts ...pulumi.ResourceOption) (*Dashboard, error) {
	if args == nil || args.Title == nil {
		return nil, errors.New("missing required argument 'Title'")
	}
	if args == nil {
		args = &DashboardArgs{}
	}
	var resource Dashboard
	err := ctx.RegisterResource("newrelic:index/dashboard:Dashboard", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDashboard gets an existing Dashboard resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDashboard(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DashboardState, opts ...pulumi.ResourceOption) (*Dashboard, error) {
	var resource Dashboard
	err := ctx.ReadResource("newrelic:index/dashboard:Dashboard", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Dashboard resources.
type dashboardState struct {
	// The URL for viewing the dashboard.
	DashboardUrl *string `pulumi:"dashboardUrl"`
	// Determines who can edit the dashboard in an account. Valid values are `all`,  `editableByAll`, `editableByOwner`, or `readOnly`.  Defaults to `editableByAll`.
	Editable *string `pulumi:"editable"`
	// A nested block that describes a dashboard filter.  Exactly one nested `filter` block is allowed. See Nested filter block below for details.
	Filter *DashboardFilter `pulumi:"filter"`
	// The number of columns to use when organizing and displaying widgets. New Relic One supports a 3 column grid and a 12 column grid. New Relic Insights supports a 3 column grid.
	GridColumnCount *int `pulumi:"gridColumnCount"`
	// The icon for the dashboard.  Valid values are `adjust`, `archive`, `bar-chart`, `bell`, `bolt`, `bug`, `bullhorn`, `bullseye`, `clock-o`, `cloud`, `cog`, `comments-o`, `crosshairs`, `dashboard`, `envelope`, `fire`, `flag`, `flask`, `globe`, `heart`, `leaf`, `legal`, `life-ring`, `line-chart`, `magic`, `mobile`, `money`, `none`, `paper-plane`, `pie-chart`, `puzzle-piece`, `road`, `rocket`, `shopping-cart`, `sitemap`, `sliders`, `tablet`, `thumbs-down`, `thumbs-up`, `trophy`, `usd`, `user`, and `users`.  Defaults to `bar-chart`.
	Icon *string `pulumi:"icon"`
	// The title of the dashboard.
	Title *string `pulumi:"title"`
	// Determines who can see the dashboard in an account. Valid values are `all` or `owner`.  Defaults to `all`.
	Visibility *string `pulumi:"visibility"`
	// A nested block that describes a visualization.  Up to 300 `widget` blocks are allowed in a dashboard definition. See Nested widget blocks below for details.
	Widgets []DashboardWidget `pulumi:"widgets"`
}

type DashboardState struct {
	// The URL for viewing the dashboard.
	DashboardUrl pulumi.StringPtrInput
	// Determines who can edit the dashboard in an account. Valid values are `all`,  `editableByAll`, `editableByOwner`, or `readOnly`.  Defaults to `editableByAll`.
	Editable pulumi.StringPtrInput
	// A nested block that describes a dashboard filter.  Exactly one nested `filter` block is allowed. See Nested filter block below for details.
	Filter DashboardFilterPtrInput
	// The number of columns to use when organizing and displaying widgets. New Relic One supports a 3 column grid and a 12 column grid. New Relic Insights supports a 3 column grid.
	GridColumnCount pulumi.IntPtrInput
	// The icon for the dashboard.  Valid values are `adjust`, `archive`, `bar-chart`, `bell`, `bolt`, `bug`, `bullhorn`, `bullseye`, `clock-o`, `cloud`, `cog`, `comments-o`, `crosshairs`, `dashboard`, `envelope`, `fire`, `flag`, `flask`, `globe`, `heart`, `leaf`, `legal`, `life-ring`, `line-chart`, `magic`, `mobile`, `money`, `none`, `paper-plane`, `pie-chart`, `puzzle-piece`, `road`, `rocket`, `shopping-cart`, `sitemap`, `sliders`, `tablet`, `thumbs-down`, `thumbs-up`, `trophy`, `usd`, `user`, and `users`.  Defaults to `bar-chart`.
	Icon pulumi.StringPtrInput
	// The title of the dashboard.
	Title pulumi.StringPtrInput
	// Determines who can see the dashboard in an account. Valid values are `all` or `owner`.  Defaults to `all`.
	Visibility pulumi.StringPtrInput
	// A nested block that describes a visualization.  Up to 300 `widget` blocks are allowed in a dashboard definition. See Nested widget blocks below for details.
	Widgets DashboardWidgetArrayInput
}

func (DashboardState) ElementType() reflect.Type {
	return reflect.TypeOf((*dashboardState)(nil)).Elem()
}

type dashboardArgs struct {
	// Determines who can edit the dashboard in an account. Valid values are `all`,  `editableByAll`, `editableByOwner`, or `readOnly`.  Defaults to `editableByAll`.
	Editable *string `pulumi:"editable"`
	// A nested block that describes a dashboard filter.  Exactly one nested `filter` block is allowed. See Nested filter block below for details.
	Filter *DashboardFilter `pulumi:"filter"`
	// The number of columns to use when organizing and displaying widgets. New Relic One supports a 3 column grid and a 12 column grid. New Relic Insights supports a 3 column grid.
	GridColumnCount *int `pulumi:"gridColumnCount"`
	// The icon for the dashboard.  Valid values are `adjust`, `archive`, `bar-chart`, `bell`, `bolt`, `bug`, `bullhorn`, `bullseye`, `clock-o`, `cloud`, `cog`, `comments-o`, `crosshairs`, `dashboard`, `envelope`, `fire`, `flag`, `flask`, `globe`, `heart`, `leaf`, `legal`, `life-ring`, `line-chart`, `magic`, `mobile`, `money`, `none`, `paper-plane`, `pie-chart`, `puzzle-piece`, `road`, `rocket`, `shopping-cart`, `sitemap`, `sliders`, `tablet`, `thumbs-down`, `thumbs-up`, `trophy`, `usd`, `user`, and `users`.  Defaults to `bar-chart`.
	Icon *string `pulumi:"icon"`
	// The title of the dashboard.
	Title string `pulumi:"title"`
	// Determines who can see the dashboard in an account. Valid values are `all` or `owner`.  Defaults to `all`.
	Visibility *string `pulumi:"visibility"`
	// A nested block that describes a visualization.  Up to 300 `widget` blocks are allowed in a dashboard definition. See Nested widget blocks below for details.
	Widgets []DashboardWidget `pulumi:"widgets"`
}

// The set of arguments for constructing a Dashboard resource.
type DashboardArgs struct {
	// Determines who can edit the dashboard in an account. Valid values are `all`,  `editableByAll`, `editableByOwner`, or `readOnly`.  Defaults to `editableByAll`.
	Editable pulumi.StringPtrInput
	// A nested block that describes a dashboard filter.  Exactly one nested `filter` block is allowed. See Nested filter block below for details.
	Filter DashboardFilterPtrInput
	// The number of columns to use when organizing and displaying widgets. New Relic One supports a 3 column grid and a 12 column grid. New Relic Insights supports a 3 column grid.
	GridColumnCount pulumi.IntPtrInput
	// The icon for the dashboard.  Valid values are `adjust`, `archive`, `bar-chart`, `bell`, `bolt`, `bug`, `bullhorn`, `bullseye`, `clock-o`, `cloud`, `cog`, `comments-o`, `crosshairs`, `dashboard`, `envelope`, `fire`, `flag`, `flask`, `globe`, `heart`, `leaf`, `legal`, `life-ring`, `line-chart`, `magic`, `mobile`, `money`, `none`, `paper-plane`, `pie-chart`, `puzzle-piece`, `road`, `rocket`, `shopping-cart`, `sitemap`, `sliders`, `tablet`, `thumbs-down`, `thumbs-up`, `trophy`, `usd`, `user`, and `users`.  Defaults to `bar-chart`.
	Icon pulumi.StringPtrInput
	// The title of the dashboard.
	Title pulumi.StringInput
	// Determines who can see the dashboard in an account. Valid values are `all` or `owner`.  Defaults to `all`.
	Visibility pulumi.StringPtrInput
	// A nested block that describes a visualization.  Up to 300 `widget` blocks are allowed in a dashboard definition. See Nested widget blocks below for details.
	Widgets DashboardWidgetArrayInput
}

func (DashboardArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*dashboardArgs)(nil)).Elem()
}

type DashboardInput interface {
	pulumi.Input

	ToDashboardOutput() DashboardOutput
	ToDashboardOutputWithContext(ctx context.Context) DashboardOutput
}

func (Dashboard) ElementType() reflect.Type {
	return reflect.TypeOf((*Dashboard)(nil)).Elem()
}

func (i Dashboard) ToDashboardOutput() DashboardOutput {
	return i.ToDashboardOutputWithContext(context.Background())
}

func (i Dashboard) ToDashboardOutputWithContext(ctx context.Context) DashboardOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DashboardOutput)
}

type DashboardOutput struct {
	*pulumi.OutputState
}

func (DashboardOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DashboardOutput)(nil)).Elem()
}

func (o DashboardOutput) ToDashboardOutput() DashboardOutput {
	return o
}

func (o DashboardOutput) ToDashboardOutputWithContext(ctx context.Context) DashboardOutput {
	return o
}

func init() {
	pulumi.RegisterOutputType(DashboardOutput{})
}
