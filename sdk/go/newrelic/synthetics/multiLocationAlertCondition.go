// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package synthetics

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// Use this resource to create, update, and delete a New Relic Synthetics Location Alerts.
//
// > **NOTE:** The NrqlAlertCondition resource is preferred for configuring alerts conditions. In most cases feature parity can be achieved with a NRQL query. Other condition types may be deprecated in the future and receive fewer product updates.
//
// ## Import
//
// New Relic Synthetics MultiLocation Conditions can be imported using a concatenated string of the format
//
// `<policy_id>:<condition_id>`, e.g. bash
//
// ```sh
//  $ pulumi import newrelic:synthetics/multiLocationAlertCondition:MultiLocationAlertCondition example 12345678:1456
// ```
type MultiLocationAlertCondition struct {
	pulumi.CustomResourceState

	// A condition term with the priority set to critical.
	Critical MultiLocationAlertConditionCriticalOutput `pulumi:"critical"`
	// Set whether to enable the alert condition.  Defaults to true.
	Enabled pulumi.BoolPtrOutput `pulumi:"enabled"`
	// The GUIDs of the Synthetics monitors to alert on.
	Entities pulumi.StringArrayOutput `pulumi:"entities"`
	// The title of the condition.
	Name pulumi.StringOutput `pulumi:"name"`
	// The ID of the policy where this condition will be used.
	PolicyId pulumi.IntOutput `pulumi:"policyId"`
	// Runbook URL to display in notifications.
	RunbookUrl pulumi.StringPtrOutput `pulumi:"runbookUrl"`
	// The maximum number of seconds a violation can remain open before being closed by the system. Must be one of: 0, 3600,
	// 7200, 14400, 28800, 43200, 86400
	ViolationTimeLimitSeconds pulumi.IntOutput `pulumi:"violationTimeLimitSeconds"`
	// A condition term with the priority set to warning.
	Warning MultiLocationAlertConditionWarningPtrOutput `pulumi:"warning"`
}

// NewMultiLocationAlertCondition registers a new resource with the given unique name, arguments, and options.
func NewMultiLocationAlertCondition(ctx *pulumi.Context,
	name string, args *MultiLocationAlertConditionArgs, opts ...pulumi.ResourceOption) (*MultiLocationAlertCondition, error) {
	if args == nil || args.Critical == nil {
		return nil, errors.New("missing required argument 'Critical'")
	}
	if args == nil || args.Entities == nil {
		return nil, errors.New("missing required argument 'Entities'")
	}
	if args == nil || args.PolicyId == nil {
		return nil, errors.New("missing required argument 'PolicyId'")
	}
	if args == nil || args.ViolationTimeLimitSeconds == nil {
		return nil, errors.New("missing required argument 'ViolationTimeLimitSeconds'")
	}
	if args == nil {
		args = &MultiLocationAlertConditionArgs{}
	}
	var resource MultiLocationAlertCondition
	err := ctx.RegisterResource("newrelic:synthetics/multiLocationAlertCondition:MultiLocationAlertCondition", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMultiLocationAlertCondition gets an existing MultiLocationAlertCondition resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMultiLocationAlertCondition(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MultiLocationAlertConditionState, opts ...pulumi.ResourceOption) (*MultiLocationAlertCondition, error) {
	var resource MultiLocationAlertCondition
	err := ctx.ReadResource("newrelic:synthetics/multiLocationAlertCondition:MultiLocationAlertCondition", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering MultiLocationAlertCondition resources.
type multiLocationAlertConditionState struct {
	// A condition term with the priority set to critical.
	Critical *MultiLocationAlertConditionCritical `pulumi:"critical"`
	// Set whether to enable the alert condition.  Defaults to true.
	Enabled *bool `pulumi:"enabled"`
	// The GUIDs of the Synthetics monitors to alert on.
	Entities []string `pulumi:"entities"`
	// The title of the condition.
	Name *string `pulumi:"name"`
	// The ID of the policy where this condition will be used.
	PolicyId *int `pulumi:"policyId"`
	// Runbook URL to display in notifications.
	RunbookUrl *string `pulumi:"runbookUrl"`
	// The maximum number of seconds a violation can remain open before being closed by the system. Must be one of: 0, 3600,
	// 7200, 14400, 28800, 43200, 86400
	ViolationTimeLimitSeconds *int `pulumi:"violationTimeLimitSeconds"`
	// A condition term with the priority set to warning.
	Warning *MultiLocationAlertConditionWarning `pulumi:"warning"`
}

type MultiLocationAlertConditionState struct {
	// A condition term with the priority set to critical.
	Critical MultiLocationAlertConditionCriticalPtrInput
	// Set whether to enable the alert condition.  Defaults to true.
	Enabled pulumi.BoolPtrInput
	// The GUIDs of the Synthetics monitors to alert on.
	Entities pulumi.StringArrayInput
	// The title of the condition.
	Name pulumi.StringPtrInput
	// The ID of the policy where this condition will be used.
	PolicyId pulumi.IntPtrInput
	// Runbook URL to display in notifications.
	RunbookUrl pulumi.StringPtrInput
	// The maximum number of seconds a violation can remain open before being closed by the system. Must be one of: 0, 3600,
	// 7200, 14400, 28800, 43200, 86400
	ViolationTimeLimitSeconds pulumi.IntPtrInput
	// A condition term with the priority set to warning.
	Warning MultiLocationAlertConditionWarningPtrInput
}

func (MultiLocationAlertConditionState) ElementType() reflect.Type {
	return reflect.TypeOf((*multiLocationAlertConditionState)(nil)).Elem()
}

type multiLocationAlertConditionArgs struct {
	// A condition term with the priority set to critical.
	Critical MultiLocationAlertConditionCritical `pulumi:"critical"`
	// Set whether to enable the alert condition.  Defaults to true.
	Enabled *bool `pulumi:"enabled"`
	// The GUIDs of the Synthetics monitors to alert on.
	Entities []string `pulumi:"entities"`
	// The title of the condition.
	Name *string `pulumi:"name"`
	// The ID of the policy where this condition will be used.
	PolicyId int `pulumi:"policyId"`
	// Runbook URL to display in notifications.
	RunbookUrl *string `pulumi:"runbookUrl"`
	// The maximum number of seconds a violation can remain open before being closed by the system. Must be one of: 0, 3600,
	// 7200, 14400, 28800, 43200, 86400
	ViolationTimeLimitSeconds int `pulumi:"violationTimeLimitSeconds"`
	// A condition term with the priority set to warning.
	Warning *MultiLocationAlertConditionWarning `pulumi:"warning"`
}

// The set of arguments for constructing a MultiLocationAlertCondition resource.
type MultiLocationAlertConditionArgs struct {
	// A condition term with the priority set to critical.
	Critical MultiLocationAlertConditionCriticalInput
	// Set whether to enable the alert condition.  Defaults to true.
	Enabled pulumi.BoolPtrInput
	// The GUIDs of the Synthetics monitors to alert on.
	Entities pulumi.StringArrayInput
	// The title of the condition.
	Name pulumi.StringPtrInput
	// The ID of the policy where this condition will be used.
	PolicyId pulumi.IntInput
	// Runbook URL to display in notifications.
	RunbookUrl pulumi.StringPtrInput
	// The maximum number of seconds a violation can remain open before being closed by the system. Must be one of: 0, 3600,
	// 7200, 14400, 28800, 43200, 86400
	ViolationTimeLimitSeconds pulumi.IntInput
	// A condition term with the priority set to warning.
	Warning MultiLocationAlertConditionWarningPtrInput
}

func (MultiLocationAlertConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*multiLocationAlertConditionArgs)(nil)).Elem()
}

type MultiLocationAlertConditionInput interface {
	pulumi.Input

	ToMultiLocationAlertConditionOutput() MultiLocationAlertConditionOutput
	ToMultiLocationAlertConditionOutputWithContext(ctx context.Context) MultiLocationAlertConditionOutput
}

func (MultiLocationAlertCondition) ElementType() reflect.Type {
	return reflect.TypeOf((*MultiLocationAlertCondition)(nil)).Elem()
}

func (i MultiLocationAlertCondition) ToMultiLocationAlertConditionOutput() MultiLocationAlertConditionOutput {
	return i.ToMultiLocationAlertConditionOutputWithContext(context.Background())
}

func (i MultiLocationAlertCondition) ToMultiLocationAlertConditionOutputWithContext(ctx context.Context) MultiLocationAlertConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MultiLocationAlertConditionOutput)
}

type MultiLocationAlertConditionOutput struct {
	*pulumi.OutputState
}

func (MultiLocationAlertConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MultiLocationAlertConditionOutput)(nil)).Elem()
}

func (o MultiLocationAlertConditionOutput) ToMultiLocationAlertConditionOutput() MultiLocationAlertConditionOutput {
	return o
}

func (o MultiLocationAlertConditionOutput) ToMultiLocationAlertConditionOutputWithContext(ctx context.Context) MultiLocationAlertConditionOutput {
	return o
}

func init() {
	pulumi.RegisterOutputType(MultiLocationAlertConditionOutput{})
}
