// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package newrelic

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Use this resource to create and manage New Relic notification destinations. Details regarding supported products and permissions can be found [here](https://docs.newrelic.com/docs/alerts-applied-intelligence/notifications/destinations).
//
// ## Example Usage
//
// ##### [Webhook](https://docs.newrelic.com/docs/alerts-applied-intelligence/notifications/notification-integrations/#webhook)
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := newrelic.NewNotificationDestination(ctx, "foo", &newrelic.NotificationDestinationArgs{
//				AccountId: pulumi.String("12345678"),
//				Name:      pulumi.String("foo"),
//				Type:      pulumi.String("WEBHOOK"),
//				SecureUrl: &newrelic.NotificationDestinationSecureUrlArgs{
//					Prefix:       pulumi.String("https://webhook.mywebhook.com/"),
//					SecureSuffix: pulumi.String("service_id/123456"),
//				},
//				Properties: newrelic.NotificationDestinationPropertyArray{
//					&newrelic.NotificationDestinationPropertyArgs{
//						Key:   pulumi.String("source"),
//						Value: pulumi.String("terraform"),
//					},
//				},
//				AuthCustomHeaders: newrelic.NotificationDestinationAuthCustomHeaderArray{
//					&newrelic.NotificationDestinationAuthCustomHeaderArgs{
//						Key:   pulumi.String("API_KEY"),
//						Value: pulumi.String("test-api-key"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// See additional examples.
//
// ## Additional Examples
//
// > **NOTE:** We support all properties. The mentioned properties are just an example.
//
// #### [WORKFLOW_AUTOMATION]
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := newrelic.NewNotificationDestination(ctx, "foo", &newrelic.NotificationDestinationArgs{
//				AccountId: pulumi.String("12345678"),
//				Name:      pulumi.String("workflow-automation-destination-name"),
//				Type:      pulumi.String("WORKFLOW_AUTOMATION"),
//				Properties: newrelic.NotificationDestinationPropertyArray{
//					&newrelic.NotificationDestinationPropertyArgs{
//						Key:   pulumi.String(""),
//						Value: pulumi.String(""),
//					},
//				},
//				AuthCustomHeaders: newrelic.NotificationDestinationAuthCustomHeaderArray{
//					&newrelic.NotificationDestinationAuthCustomHeaderArgs{
//						Key:   pulumi.String("Api-Key"),
//						Value: pulumi.String("YOUR_NR_USER_API_KEY"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ##### [MICROSOFT_TEAMS](https://docs.newrelic.com/docs/alerts/get-notified/microsoft-teams-integrations/)
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := newrelic.NewNotificationDestination(ctx, "foo", &newrelic.NotificationDestinationArgs{
//				AccountId: pulumi.String("12345678"),
//				Name:      pulumi.String("ms-teams-example"),
//				Type:      pulumi.String("MICROSOFT_TEAMS"),
//				Properties: newrelic.NotificationDestinationPropertyArray{
//					&newrelic.NotificationDestinationPropertyArgs{
//						Key:   pulumi.String("securityCode"),
//						Value: pulumi.String("abcdefgh"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ##### [ServiceNow](https://docs.newrelic.com/docs/alerts-applied-intelligence/notifications/notification-integrations/#servicenow)
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := newrelic.NewNotificationDestination(ctx, "foo", &newrelic.NotificationDestinationArgs{
//				AccountId: pulumi.String("12345678"),
//				Name:      pulumi.String("servicenow-example"),
//				Type:      pulumi.String("SERVICE_NOW"),
//				Properties: newrelic.NotificationDestinationPropertyArray{
//					&newrelic.NotificationDestinationPropertyArgs{
//						Key:   pulumi.String("url"),
//						Value: pulumi.String("https://service-now.com/"),
//					},
//					&newrelic.NotificationDestinationPropertyArgs{
//						Key:   pulumi.String("two_way_integration"),
//						Value: pulumi.String("true"),
//					},
//				},
//				AuthBasic: &newrelic.NotificationDestinationAuthBasicArgs{
//					User:     pulumi.String("username"),
//					Password: pulumi.String("password"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ##### [Email](https://docs.newrelic.com/docs/alerts-applied-intelligence/notifications/notification-integrations/#email)
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := newrelic.NewNotificationDestination(ctx, "foo", &newrelic.NotificationDestinationArgs{
//				AccountId: pulumi.String("12345678"),
//				Name:      pulumi.String("email-example"),
//				Type:      pulumi.String("EMAIL"),
//				Properties: newrelic.NotificationDestinationPropertyArray{
//					&newrelic.NotificationDestinationPropertyArgs{
//						Key:   pulumi.String("email"),
//						Value: pulumi.String("email@email.com,email2@email.com"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ##### [Jira](https://docs.newrelic.com/docs/alerts-applied-intelligence/notifications/notification-integrations/#jira)
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := newrelic.NewNotificationDestination(ctx, "foo", &newrelic.NotificationDestinationArgs{
//				AccountId: pulumi.String("12345678"),
//				Name:      pulumi.String("jira-example"),
//				Type:      pulumi.String("JIRA"),
//				Properties: newrelic.NotificationDestinationPropertyArray{
//					&newrelic.NotificationDestinationPropertyArgs{
//						Key:   pulumi.String("url"),
//						Value: pulumi.String("https://example.atlassian.net"),
//					},
//				},
//				AuthBasic: &newrelic.NotificationDestinationAuthBasicArgs{
//					User:     pulumi.String("example@email.com"),
//					Password: pulumi.String("password"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ##### [PagerDuty with service integration](https://docs.newrelic.com/docs/alerts-applied-intelligence/notifications/notification-integrations/#pagerduty-sli)
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := newrelic.NewNotificationDestination(ctx, "foo", &newrelic.NotificationDestinationArgs{
//				AccountId: pulumi.String("12345678"),
//				Name:      pulumi.String("pagerduty-service-example"),
//				Type:      pulumi.String("PAGERDUTY_SERVICE_INTEGRATION"),
//				Properties: newrelic.NotificationDestinationPropertyArray{
//					&newrelic.NotificationDestinationPropertyArgs{
//						Key:   pulumi.String(""),
//						Value: pulumi.String(""),
//					},
//				},
//				AuthToken: &newrelic.NotificationDestinationAuthTokenArgs{
//					Prefix: pulumi.String("Token token="),
//					Token:  pulumi.String("10567a689d984d03c021034b22a789e2"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ##### [PagerDuty with account integration](https://docs.newrelic.com/docs/alerts-applied-intelligence/notifications/notification-integrations/#pagerduty-ali)
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := newrelic.NewNotificationDestination(ctx, "foo", &newrelic.NotificationDestinationArgs{
//				AccountId: pulumi.String("12345678"),
//				Name:      pulumi.String("pagerduty-account-example"),
//				Type:      pulumi.String("PAGERDUTY_ACCOUNT_INTEGRATION"),
//				Properties: newrelic.NotificationDestinationPropertyArray{
//					&newrelic.NotificationDestinationPropertyArgs{
//						Key:   pulumi.String("two_way_integration"),
//						Value: pulumi.String("true"),
//					},
//				},
//				AuthToken: &newrelic.NotificationDestinationAuthTokenArgs{
//					Prefix: pulumi.String("Token token="),
//					Token:  pulumi.String("u+E8EU3MhsZwLfZ1ic1A"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// #### Mobile Push
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := newrelic.NewNotificationDestination(ctx, "foo", &newrelic.NotificationDestinationArgs{
//				AccountId: pulumi.String("12345678"),
//				Name:      pulumi.String("mobile-push-example"),
//				Type:      pulumi.String("MOBILE_PUSH"),
//				Properties: newrelic.NotificationDestinationPropertyArray{
//					&newrelic.NotificationDestinationPropertyArgs{
//						Key:   pulumi.String("userId"),
//						Value: pulumi.String("12345678"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// #### [AWS Event Bridge](https://docs.newrelic.com/docs/alerts-applied-intelligence/notifications/notification-integrations/#eventBridge)
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := newrelic.NewNotificationDestination(ctx, "foo", &newrelic.NotificationDestinationArgs{
//				AccountId: pulumi.String("12345678"),
//				Name:      pulumi.String("event-bridge-example"),
//				Type:      pulumi.String("EVENT_BRIDGE"),
//				Properties: newrelic.NotificationDestinationPropertyArray{
//					&newrelic.NotificationDestinationPropertyArgs{
//						Key:   pulumi.String("AWSAccountId"),
//						Value: pulumi.String("123456789123456"),
//					},
//					&newrelic.NotificationDestinationPropertyArgs{
//						Key:   pulumi.String("AWSRegion"),
//						Value: pulumi.String("us-east-2"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// #### [Slack](https://docs.newrelic.com/docs/alerts-applied-intelligence/notifications/notification-integrations/#slack)
//
// In order to create a Slack destination, you have to grant our application access to your workspace. This process is [based on OAuth](https://api.slack.com/authentication/oauth-v2) and can only be done through a browser.
// As a result, you cannot set up a Slack destination purely with Terraform code.
// However, if you would like to use Slack-based destinations with other resources in the New Relic Terraform Provider, the data source `NotificationDestination` may be used to fetch the ID of the destination; alternatively, you might want to source the ID of the destination from  NerdGraph, or from the New Relic One UI.
//
// ## Additional Information
//
// More information about destinations integrations can be found in NewRelic [documentation](https://docs.newrelic.com/docs/alerts-applied-intelligence/notifications/notification-integrations/).
// More details about the destinations API can be found [here](https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-api-notifications-destinations).
//
// ### Moving from Legacy Alert Channels to Notification Channels
// As stated in the documentation of this resource and `NotificationChannel`, destinations, created using the resource `NotificationDestination` can be paired with `NotificationChannel` to set up channels. These resources combined, are an alternative to the legacy resource `AlertChannel`, which is **deprecated** and will be **removed in a future major release**, as stated in the documentation of the resource.
//
// If you're currently using `AlertChannel` to manage channels, we **strongly recommend** migrating to these notifications-based resources at the earliest.
//
// Please refer to the examples in this page, or this example for illustrations on setting up channels with these resources.
//
// ## Import
//
// > **WARNING:** Slack-based destinations can only be imported and destroyed; this resource **does not** support creating and updating Slack-based destinations, owing to the reasons stated above, under the **Slack** section.
//
// Destination id can be found in the Destinations page > three dots at the right of the chosen destination > copy destination id to clipboard.
// This example is especially useful for slack destinations which *must* be imported.
//
// 1. Add an empty resource to your terraform file:
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := newrelic.NewNotificationDestination(ctx, "foo", nil)
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//  2. Run import command: `terraform import newrelic_notification_destination.foo <destination_id>`
//  3. Run the following command after the import successfully done and copy the information to your resource:
//     `terraform state show newrelic_notification_destination.foo`
//  4. Add `ignoreChanges` attribute on `all` in your imported resource:
type NotificationDestination struct {
	pulumi.CustomResourceState

	// Determines the New Relic account where the notification destination will be created. Defaults to the account associated with the API key used.
	AccountId pulumi.StringOutput `pulumi:"accountId"`
	// Indicates whether the destination is active.
	Active pulumi.BoolPtrOutput `pulumi:"active"`
	// A nested block that describes a basic username and password authentication credentials. Only one authBasic block is permitted per notification destination definition.  See Nested authBasic blocks below for details.
	AuthBasic NotificationDestinationAuthBasicPtrOutput `pulumi:"authBasic"`
	// A nested block that describes a custom header authentication credentials. This field is required when the destination type is WORKFLOW_AUTOMATION and optional for other destination types. Multiple blocks are permitted per notification destination definition. Nested authCustomHeader blocks below for details.
	AuthCustomHeaders NotificationDestinationAuthCustomHeaderArrayOutput `pulumi:"authCustomHeaders"`
	// A nested block that describes a token authentication credentials. Only one authToken block is permitted per notification destination definition.  See Nested authToken blocks below for details.
	AuthToken NotificationDestinationAuthTokenPtrOutput `pulumi:"authToken"`
	// The unique entity identifier of the destination in New Relic.
	Guid pulumi.StringOutput `pulumi:"guid"`
	// The last time a notification was sent.
	LastSent pulumi.StringOutput `pulumi:"lastSent"`
	// The name of the destination.
	Name pulumi.StringOutput `pulumi:"name"`
	// A nested block that describes a notification destination property. See Nested property blocks below for details.
	Properties NotificationDestinationPropertyArrayOutput `pulumi:"properties"`
	// A nested block that describes a URL that contains sensitive data at the path or parameters. Only one secureUrl block is permitted per notification destination definition. See Nested secureUrl blocks below for details.
	SecureUrl NotificationDestinationSecureUrlPtrOutput `pulumi:"secureUrl"`
	// The status of the destination.
	Status pulumi.StringOutput `pulumi:"status"`
	// The type of destination.  One of: `EMAIL`, `SERVICE_NOW`, `SERVICE_NOW_APP`, `WEBHOOK`, `JIRA`, `MOBILE_PUSH`, `EVENT_BRIDGE`, `PAGERDUTY_ACCOUNT_INTEGRATION` or `PAGERDUTY_SERVICE_INTEGRATION`, `MICROSOFT_TEAMS`, `WORKFLOW_AUTOMATION`. The types `SLACK` and `SLACK_COLLABORATION` can only be imported, updated and destroyed (cannot be created via terraform).
	Type pulumi.StringOutput `pulumi:"type"`
}

// NewNotificationDestination registers a new resource with the given unique name, arguments, and options.
func NewNotificationDestination(ctx *pulumi.Context,
	name string, args *NotificationDestinationArgs, opts ...pulumi.ResourceOption) (*NotificationDestination, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Properties == nil {
		return nil, errors.New("invalid value for required argument 'Properties'")
	}
	if args.Type == nil {
		return nil, errors.New("invalid value for required argument 'Type'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource NotificationDestination
	err := ctx.RegisterResource("newrelic:index/notificationDestination:NotificationDestination", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetNotificationDestination gets an existing NotificationDestination resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetNotificationDestination(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *NotificationDestinationState, opts ...pulumi.ResourceOption) (*NotificationDestination, error) {
	var resource NotificationDestination
	err := ctx.ReadResource("newrelic:index/notificationDestination:NotificationDestination", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering NotificationDestination resources.
type notificationDestinationState struct {
	// Determines the New Relic account where the notification destination will be created. Defaults to the account associated with the API key used.
	AccountId *string `pulumi:"accountId"`
	// Indicates whether the destination is active.
	Active *bool `pulumi:"active"`
	// A nested block that describes a basic username and password authentication credentials. Only one authBasic block is permitted per notification destination definition.  See Nested authBasic blocks below for details.
	AuthBasic *NotificationDestinationAuthBasic `pulumi:"authBasic"`
	// A nested block that describes a custom header authentication credentials. This field is required when the destination type is WORKFLOW_AUTOMATION and optional for other destination types. Multiple blocks are permitted per notification destination definition. Nested authCustomHeader blocks below for details.
	AuthCustomHeaders []NotificationDestinationAuthCustomHeader `pulumi:"authCustomHeaders"`
	// A nested block that describes a token authentication credentials. Only one authToken block is permitted per notification destination definition.  See Nested authToken blocks below for details.
	AuthToken *NotificationDestinationAuthToken `pulumi:"authToken"`
	// The unique entity identifier of the destination in New Relic.
	Guid *string `pulumi:"guid"`
	// The last time a notification was sent.
	LastSent *string `pulumi:"lastSent"`
	// The name of the destination.
	Name *string `pulumi:"name"`
	// A nested block that describes a notification destination property. See Nested property blocks below for details.
	Properties []NotificationDestinationProperty `pulumi:"properties"`
	// A nested block that describes a URL that contains sensitive data at the path or parameters. Only one secureUrl block is permitted per notification destination definition. See Nested secureUrl blocks below for details.
	SecureUrl *NotificationDestinationSecureUrl `pulumi:"secureUrl"`
	// The status of the destination.
	Status *string `pulumi:"status"`
	// The type of destination.  One of: `EMAIL`, `SERVICE_NOW`, `SERVICE_NOW_APP`, `WEBHOOK`, `JIRA`, `MOBILE_PUSH`, `EVENT_BRIDGE`, `PAGERDUTY_ACCOUNT_INTEGRATION` or `PAGERDUTY_SERVICE_INTEGRATION`, `MICROSOFT_TEAMS`, `WORKFLOW_AUTOMATION`. The types `SLACK` and `SLACK_COLLABORATION` can only be imported, updated and destroyed (cannot be created via terraform).
	Type *string `pulumi:"type"`
}

type NotificationDestinationState struct {
	// Determines the New Relic account where the notification destination will be created. Defaults to the account associated with the API key used.
	AccountId pulumi.StringPtrInput
	// Indicates whether the destination is active.
	Active pulumi.BoolPtrInput
	// A nested block that describes a basic username and password authentication credentials. Only one authBasic block is permitted per notification destination definition.  See Nested authBasic blocks below for details.
	AuthBasic NotificationDestinationAuthBasicPtrInput
	// A nested block that describes a custom header authentication credentials. This field is required when the destination type is WORKFLOW_AUTOMATION and optional for other destination types. Multiple blocks are permitted per notification destination definition. Nested authCustomHeader blocks below for details.
	AuthCustomHeaders NotificationDestinationAuthCustomHeaderArrayInput
	// A nested block that describes a token authentication credentials. Only one authToken block is permitted per notification destination definition.  See Nested authToken blocks below for details.
	AuthToken NotificationDestinationAuthTokenPtrInput
	// The unique entity identifier of the destination in New Relic.
	Guid pulumi.StringPtrInput
	// The last time a notification was sent.
	LastSent pulumi.StringPtrInput
	// The name of the destination.
	Name pulumi.StringPtrInput
	// A nested block that describes a notification destination property. See Nested property blocks below for details.
	Properties NotificationDestinationPropertyArrayInput
	// A nested block that describes a URL that contains sensitive data at the path or parameters. Only one secureUrl block is permitted per notification destination definition. See Nested secureUrl blocks below for details.
	SecureUrl NotificationDestinationSecureUrlPtrInput
	// The status of the destination.
	Status pulumi.StringPtrInput
	// The type of destination.  One of: `EMAIL`, `SERVICE_NOW`, `SERVICE_NOW_APP`, `WEBHOOK`, `JIRA`, `MOBILE_PUSH`, `EVENT_BRIDGE`, `PAGERDUTY_ACCOUNT_INTEGRATION` or `PAGERDUTY_SERVICE_INTEGRATION`, `MICROSOFT_TEAMS`, `WORKFLOW_AUTOMATION`. The types `SLACK` and `SLACK_COLLABORATION` can only be imported, updated and destroyed (cannot be created via terraform).
	Type pulumi.StringPtrInput
}

func (NotificationDestinationState) ElementType() reflect.Type {
	return reflect.TypeOf((*notificationDestinationState)(nil)).Elem()
}

type notificationDestinationArgs struct {
	// Determines the New Relic account where the notification destination will be created. Defaults to the account associated with the API key used.
	AccountId *string `pulumi:"accountId"`
	// Indicates whether the destination is active.
	Active *bool `pulumi:"active"`
	// A nested block that describes a basic username and password authentication credentials. Only one authBasic block is permitted per notification destination definition.  See Nested authBasic blocks below for details.
	AuthBasic *NotificationDestinationAuthBasic `pulumi:"authBasic"`
	// A nested block that describes a custom header authentication credentials. This field is required when the destination type is WORKFLOW_AUTOMATION and optional for other destination types. Multiple blocks are permitted per notification destination definition. Nested authCustomHeader blocks below for details.
	AuthCustomHeaders []NotificationDestinationAuthCustomHeader `pulumi:"authCustomHeaders"`
	// A nested block that describes a token authentication credentials. Only one authToken block is permitted per notification destination definition.  See Nested authToken blocks below for details.
	AuthToken *NotificationDestinationAuthToken `pulumi:"authToken"`
	// The name of the destination.
	Name *string `pulumi:"name"`
	// A nested block that describes a notification destination property. See Nested property blocks below for details.
	Properties []NotificationDestinationProperty `pulumi:"properties"`
	// A nested block that describes a URL that contains sensitive data at the path or parameters. Only one secureUrl block is permitted per notification destination definition. See Nested secureUrl blocks below for details.
	SecureUrl *NotificationDestinationSecureUrl `pulumi:"secureUrl"`
	// The type of destination.  One of: `EMAIL`, `SERVICE_NOW`, `SERVICE_NOW_APP`, `WEBHOOK`, `JIRA`, `MOBILE_PUSH`, `EVENT_BRIDGE`, `PAGERDUTY_ACCOUNT_INTEGRATION` or `PAGERDUTY_SERVICE_INTEGRATION`, `MICROSOFT_TEAMS`, `WORKFLOW_AUTOMATION`. The types `SLACK` and `SLACK_COLLABORATION` can only be imported, updated and destroyed (cannot be created via terraform).
	Type string `pulumi:"type"`
}

// The set of arguments for constructing a NotificationDestination resource.
type NotificationDestinationArgs struct {
	// Determines the New Relic account where the notification destination will be created. Defaults to the account associated with the API key used.
	AccountId pulumi.StringPtrInput
	// Indicates whether the destination is active.
	Active pulumi.BoolPtrInput
	// A nested block that describes a basic username and password authentication credentials. Only one authBasic block is permitted per notification destination definition.  See Nested authBasic blocks below for details.
	AuthBasic NotificationDestinationAuthBasicPtrInput
	// A nested block that describes a custom header authentication credentials. This field is required when the destination type is WORKFLOW_AUTOMATION and optional for other destination types. Multiple blocks are permitted per notification destination definition. Nested authCustomHeader blocks below for details.
	AuthCustomHeaders NotificationDestinationAuthCustomHeaderArrayInput
	// A nested block that describes a token authentication credentials. Only one authToken block is permitted per notification destination definition.  See Nested authToken blocks below for details.
	AuthToken NotificationDestinationAuthTokenPtrInput
	// The name of the destination.
	Name pulumi.StringPtrInput
	// A nested block that describes a notification destination property. See Nested property blocks below for details.
	Properties NotificationDestinationPropertyArrayInput
	// A nested block that describes a URL that contains sensitive data at the path or parameters. Only one secureUrl block is permitted per notification destination definition. See Nested secureUrl blocks below for details.
	SecureUrl NotificationDestinationSecureUrlPtrInput
	// The type of destination.  One of: `EMAIL`, `SERVICE_NOW`, `SERVICE_NOW_APP`, `WEBHOOK`, `JIRA`, `MOBILE_PUSH`, `EVENT_BRIDGE`, `PAGERDUTY_ACCOUNT_INTEGRATION` or `PAGERDUTY_SERVICE_INTEGRATION`, `MICROSOFT_TEAMS`, `WORKFLOW_AUTOMATION`. The types `SLACK` and `SLACK_COLLABORATION` can only be imported, updated and destroyed (cannot be created via terraform).
	Type pulumi.StringInput
}

func (NotificationDestinationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*notificationDestinationArgs)(nil)).Elem()
}

type NotificationDestinationInput interface {
	pulumi.Input

	ToNotificationDestinationOutput() NotificationDestinationOutput
	ToNotificationDestinationOutputWithContext(ctx context.Context) NotificationDestinationOutput
}

func (*NotificationDestination) ElementType() reflect.Type {
	return reflect.TypeOf((**NotificationDestination)(nil)).Elem()
}

func (i *NotificationDestination) ToNotificationDestinationOutput() NotificationDestinationOutput {
	return i.ToNotificationDestinationOutputWithContext(context.Background())
}

func (i *NotificationDestination) ToNotificationDestinationOutputWithContext(ctx context.Context) NotificationDestinationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationDestinationOutput)
}

// NotificationDestinationArrayInput is an input type that accepts NotificationDestinationArray and NotificationDestinationArrayOutput values.
// You can construct a concrete instance of `NotificationDestinationArrayInput` via:
//
//	NotificationDestinationArray{ NotificationDestinationArgs{...} }
type NotificationDestinationArrayInput interface {
	pulumi.Input

	ToNotificationDestinationArrayOutput() NotificationDestinationArrayOutput
	ToNotificationDestinationArrayOutputWithContext(context.Context) NotificationDestinationArrayOutput
}

type NotificationDestinationArray []NotificationDestinationInput

func (NotificationDestinationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NotificationDestination)(nil)).Elem()
}

func (i NotificationDestinationArray) ToNotificationDestinationArrayOutput() NotificationDestinationArrayOutput {
	return i.ToNotificationDestinationArrayOutputWithContext(context.Background())
}

func (i NotificationDestinationArray) ToNotificationDestinationArrayOutputWithContext(ctx context.Context) NotificationDestinationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationDestinationArrayOutput)
}

// NotificationDestinationMapInput is an input type that accepts NotificationDestinationMap and NotificationDestinationMapOutput values.
// You can construct a concrete instance of `NotificationDestinationMapInput` via:
//
//	NotificationDestinationMap{ "key": NotificationDestinationArgs{...} }
type NotificationDestinationMapInput interface {
	pulumi.Input

	ToNotificationDestinationMapOutput() NotificationDestinationMapOutput
	ToNotificationDestinationMapOutputWithContext(context.Context) NotificationDestinationMapOutput
}

type NotificationDestinationMap map[string]NotificationDestinationInput

func (NotificationDestinationMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NotificationDestination)(nil)).Elem()
}

func (i NotificationDestinationMap) ToNotificationDestinationMapOutput() NotificationDestinationMapOutput {
	return i.ToNotificationDestinationMapOutputWithContext(context.Background())
}

func (i NotificationDestinationMap) ToNotificationDestinationMapOutputWithContext(ctx context.Context) NotificationDestinationMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationDestinationMapOutput)
}

type NotificationDestinationOutput struct{ *pulumi.OutputState }

func (NotificationDestinationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NotificationDestination)(nil)).Elem()
}

func (o NotificationDestinationOutput) ToNotificationDestinationOutput() NotificationDestinationOutput {
	return o
}

func (o NotificationDestinationOutput) ToNotificationDestinationOutputWithContext(ctx context.Context) NotificationDestinationOutput {
	return o
}

// Determines the New Relic account where the notification destination will be created. Defaults to the account associated with the API key used.
func (o NotificationDestinationOutput) AccountId() pulumi.StringOutput {
	return o.ApplyT(func(v *NotificationDestination) pulumi.StringOutput { return v.AccountId }).(pulumi.StringOutput)
}

// Indicates whether the destination is active.
func (o NotificationDestinationOutput) Active() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *NotificationDestination) pulumi.BoolPtrOutput { return v.Active }).(pulumi.BoolPtrOutput)
}

// A nested block that describes a basic username and password authentication credentials. Only one authBasic block is permitted per notification destination definition.  See Nested authBasic blocks below for details.
func (o NotificationDestinationOutput) AuthBasic() NotificationDestinationAuthBasicPtrOutput {
	return o.ApplyT(func(v *NotificationDestination) NotificationDestinationAuthBasicPtrOutput { return v.AuthBasic }).(NotificationDestinationAuthBasicPtrOutput)
}

// A nested block that describes a custom header authentication credentials. This field is required when the destination type is WORKFLOW_AUTOMATION and optional for other destination types. Multiple blocks are permitted per notification destination definition. Nested authCustomHeader blocks below for details.
func (o NotificationDestinationOutput) AuthCustomHeaders() NotificationDestinationAuthCustomHeaderArrayOutput {
	return o.ApplyT(func(v *NotificationDestination) NotificationDestinationAuthCustomHeaderArrayOutput {
		return v.AuthCustomHeaders
	}).(NotificationDestinationAuthCustomHeaderArrayOutput)
}

// A nested block that describes a token authentication credentials. Only one authToken block is permitted per notification destination definition.  See Nested authToken blocks below for details.
func (o NotificationDestinationOutput) AuthToken() NotificationDestinationAuthTokenPtrOutput {
	return o.ApplyT(func(v *NotificationDestination) NotificationDestinationAuthTokenPtrOutput { return v.AuthToken }).(NotificationDestinationAuthTokenPtrOutput)
}

// The unique entity identifier of the destination in New Relic.
func (o NotificationDestinationOutput) Guid() pulumi.StringOutput {
	return o.ApplyT(func(v *NotificationDestination) pulumi.StringOutput { return v.Guid }).(pulumi.StringOutput)
}

// The last time a notification was sent.
func (o NotificationDestinationOutput) LastSent() pulumi.StringOutput {
	return o.ApplyT(func(v *NotificationDestination) pulumi.StringOutput { return v.LastSent }).(pulumi.StringOutput)
}

// The name of the destination.
func (o NotificationDestinationOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *NotificationDestination) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// A nested block that describes a notification destination property. See Nested property blocks below for details.
func (o NotificationDestinationOutput) Properties() NotificationDestinationPropertyArrayOutput {
	return o.ApplyT(func(v *NotificationDestination) NotificationDestinationPropertyArrayOutput { return v.Properties }).(NotificationDestinationPropertyArrayOutput)
}

// A nested block that describes a URL that contains sensitive data at the path or parameters. Only one secureUrl block is permitted per notification destination definition. See Nested secureUrl blocks below for details.
func (o NotificationDestinationOutput) SecureUrl() NotificationDestinationSecureUrlPtrOutput {
	return o.ApplyT(func(v *NotificationDestination) NotificationDestinationSecureUrlPtrOutput { return v.SecureUrl }).(NotificationDestinationSecureUrlPtrOutput)
}

// The status of the destination.
func (o NotificationDestinationOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *NotificationDestination) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

// The type of destination.  One of: `EMAIL`, `SERVICE_NOW`, `SERVICE_NOW_APP`, `WEBHOOK`, `JIRA`, `MOBILE_PUSH`, `EVENT_BRIDGE`, `PAGERDUTY_ACCOUNT_INTEGRATION` or `PAGERDUTY_SERVICE_INTEGRATION`, `MICROSOFT_TEAMS`, `WORKFLOW_AUTOMATION`. The types `SLACK` and `SLACK_COLLABORATION` can only be imported, updated and destroyed (cannot be created via terraform).
func (o NotificationDestinationOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *NotificationDestination) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

type NotificationDestinationArrayOutput struct{ *pulumi.OutputState }

func (NotificationDestinationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NotificationDestination)(nil)).Elem()
}

func (o NotificationDestinationArrayOutput) ToNotificationDestinationArrayOutput() NotificationDestinationArrayOutput {
	return o
}

func (o NotificationDestinationArrayOutput) ToNotificationDestinationArrayOutputWithContext(ctx context.Context) NotificationDestinationArrayOutput {
	return o
}

func (o NotificationDestinationArrayOutput) Index(i pulumi.IntInput) NotificationDestinationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *NotificationDestination {
		return vs[0].([]*NotificationDestination)[vs[1].(int)]
	}).(NotificationDestinationOutput)
}

type NotificationDestinationMapOutput struct{ *pulumi.OutputState }

func (NotificationDestinationMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NotificationDestination)(nil)).Elem()
}

func (o NotificationDestinationMapOutput) ToNotificationDestinationMapOutput() NotificationDestinationMapOutput {
	return o
}

func (o NotificationDestinationMapOutput) ToNotificationDestinationMapOutputWithContext(ctx context.Context) NotificationDestinationMapOutput {
	return o
}

func (o NotificationDestinationMapOutput) MapIndex(k pulumi.StringInput) NotificationDestinationOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *NotificationDestination {
		return vs[0].(map[string]*NotificationDestination)[vs[1].(string)]
	}).(NotificationDestinationOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*NotificationDestinationInput)(nil)).Elem(), &NotificationDestination{})
	pulumi.RegisterInputType(reflect.TypeOf((*NotificationDestinationArrayInput)(nil)).Elem(), NotificationDestinationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NotificationDestinationMapInput)(nil)).Elem(), NotificationDestinationMap{})
	pulumi.RegisterOutputType(NotificationDestinationOutput{})
	pulumi.RegisterOutputType(NotificationDestinationArrayOutput{})
	pulumi.RegisterOutputType(NotificationDestinationMapOutput{})
}
