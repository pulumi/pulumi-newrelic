// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package newrelic

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Use this resource to create and manage NRQL alert conditions in New Relic.
//
// ## Example Usage
//
// ### Type: `static` (default)
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			foo, err := newrelic.NewAlertPolicy(ctx, "foo", &newrelic.AlertPolicyArgs{
//				Name: pulumi.String("foo"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = newrelic.NewNrqlAlertCondition(ctx, "foo", &newrelic.NrqlAlertConditionArgs{
//				AccountId:                   pulumi.String("12345678"),
//				PolicyId:                    foo.ID(),
//				Type:                        pulumi.String("static"),
//				Name:                        pulumi.String("foo"),
//				Description:                 pulumi.String("Alert when transactions are taking too long"),
//				TitleTemplate:               pulumi.String("Issue in environment: {{ tags.environment }}"),
//				TargetEntity:                pulumi.String("MXxBUE18QVBQTElDQVRJT058MQ"),
//				RunbookUrl:                  pulumi.String("https://www.example.com"),
//				Enabled:                     pulumi.Bool(true),
//				ViolationTimeLimitSeconds:   pulumi.Int(3600),
//				FillOption:                  pulumi.String("static"),
//				FillValue:                   pulumi.Float64(1),
//				AggregationWindow:           pulumi.Int(60),
//				AggregationMethod:           pulumi.String("event_flow"),
//				AggregationDelay:            pulumi.String("120"),
//				ExpirationDuration:          pulumi.Int(120),
//				OpenViolationOnExpiration:   pulumi.Bool(true),
//				CloseViolationsOnExpiration: pulumi.Bool(true),
//				IgnoreOnExpectedTermination: pulumi.Bool(true),
//				SlideBy:                     pulumi.Int(30),
//				Nrql: &newrelic.NrqlAlertConditionNrqlArgs{
//					Query: pulumi.String("SELECT average(duration) FROM Transaction where appName = 'Your App'"),
//				},
//				Critical: &newrelic.NrqlAlertConditionCriticalArgs{
//					Operator:             pulumi.String("above"),
//					Threshold:            pulumi.Float64(5.5),
//					ThresholdDuration:    pulumi.Int(300),
//					ThresholdOccurrences: pulumi.String("ALL"),
//				},
//				Warning: &newrelic.NrqlAlertConditionWarningArgs{
//					Operator:             pulumi.String("above"),
//					Threshold:            pulumi.Float64(3.5),
//					ThresholdDuration:    pulumi.Int(600),
//					ThresholdOccurrences: pulumi.String("ALL"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## NRQL
//
// The `nrql` block supports the following arguments:
//
// - `query` - (Required) The NRQL query to execute for the condition.
// - `dataAccountId` - (Optional) The account ID to use for the alert condition's query as specified in the the `query` field. If `dataAccountId` is not specified, then the condition's query will be evaluated against the `accountId`. Note that the `accountId` must have read privileges for the `dataAccountId` or else the condition will be invalid.
// - `evaluationOffset` - (Optional) **DEPRECATED:** Use `aggregationMethod` instead. Represented in minutes and must be within 1-20 minutes (inclusive). NRQL queries are evaluated based on their `aggregationWindow` size. The start time depends on this value. It's recommended to set this to 3 windows. An offset of less than 3 windows will trigger incidents sooner, but you may see more false positives and negatives due to data latency. With `evaluationOffset` set to 3 windows and an `aggregationWindow` of 60 seconds, the NRQL time window applied to your query will be: `SINCE 3 minutes ago UNTIL 2 minutes ago`. `evaluationOffset` cannot be set with `aggregationMethod`, `aggregationDelay`, or `aggregationTimer`.<br>
// - `sinceValue` - (Optional)  **DEPRECATED:** Use `aggregationMethod` instead. The value to be used in the `SINCE <X> minutes ago` clause for the NRQL query. Must be between 1-20 (inclusive). <br>
//
// ## Terms
//
// > **NOTE:** The direct use of the `term` has been deprecated, and users should use `critical` and `warning` instead.  What follows now applies to the named priority attributes for `critical` and `warning`, but for those attributes the priority is not allowed. At least one `critical` or `warning` term must be defined.
//
// NRQL alert conditions support up to two terms. At least one `term` must have `priority` set to `critical` and the second optional `term` must have `priority` set to `warning`.
//
// The `term` block supports the following arguments:
//
// - `operator` - (Optional) Valid values are `above`, `aboveOrEquals`, `below`, `belowOrEquals`, `equals`, or `notEquals` (case insensitive). Defaults to `equals`. Note that when using a `type` of `baseline`, the only valid option here is `above`.
// - `priority` - (Optional) `critical` or `warning`. Defaults to `critical`.
// - `threshold` - (Required) The value which will trigger an incident.
// <br>For _baseline_ NRQL alert conditions, the value must be in the range [1, 1000]. The value is the number of standard deviations from the baseline that the metric must exceed in order to create an incident.
// - `thresholdDuration` - (Optional) The duration, in seconds, that the threshold must violate in order to create an incident. Value must be a multiple of the `aggregationWindow` (which has a default of 60 seconds).
// <br>For _baseline_ NRQL alert conditions, the value must be within 120-86400 seconds (inclusive).
// <br>For _static_ NRQL alert conditions, the value must be within 60-86400 seconds (inclusive).
//
// - `thresholdOccurrences` - (Optional) The criteria for how many data points must be in violation for the specified threshold duration. Valid values are: `all` or `atLeastOnce` (case insensitive).
// - `duration` - (Optional) **DEPRECATED:** Use `thresholdDuration` instead. The duration of time, in _minutes_, that the threshold must violate for in order to create an incident. Must be within 1-120 (inclusive).
// - `timeFunction` - (Optional) **DEPRECATED:** Use `thresholdOccurrences` instead. The criteria for how many data points must be in violation for the specified threshold duration. Valid values are: `all` or `any`.
// - `prediction` - (Optional) **BETA PREVIEW: the `prediction` field is in limited release and only enabled for preview on a per-account basis.** Use `prediction` to open alerts when your static threshold is predicted to be reached in the future. The `prediction` field is only available for _static_ NRQL alert conditions. See Prediction below for details.
// - `disableHealthStatusReporting` - (Optional) `true` or `false`. Defaults to `false` when field not included in TF config. Violations will not change system health status for this term.
//
// > **NOTE:** When a `critical` or `warning` block is added to this resource, using either `duration` or `thresholdDuration` (one of the two) is mandatory. Both of these should not be specified.
//
// > **NOTE:** When a `critical` or `warning` block is added to this resource, using either `timeFunction` or `thresholdOccurrences` (one of the two) is mandatory. Both of these should not be specified.
//
// ### Prediction
//
// > **BETA PREVIEW:** The `prediction` block is in limited release and only enabled for preview on a per-account basis.
//
// > **NOTE:** The `prediction` block is only available for _static_ NRQL alert conditions.
//
// The `prediction` block supports the following arguments:
//
// - `predictBy` - (Optional) The duration, in seconds, that the prediction should look into the future. Default is 3600 seconds (1 hour).
// - `preferPredictionViolation` - (Optional) If a prediction incident is open when a term's static threshold is breached by the actual signal, default behavior is to close the prediction incident and open a static incident. Setting `preferPredictionViolation` to `true` overrides this behavior leaving the prediction incident open and preventing a static incident from opening. Default is false.
//
// ## Additional Examples
//
// ##### Type: `baseline`
//
// [Baseline NRQL alert conditions](https://docs.newrelic.com/docs/alerts/new-relic-alerts/defining-conditions/create-baseline-alert-conditions) are dynamic in nature and adjust to the behavior of your data. The example below demonstrates a baseline NRQL alert condition for alerting when transaction durations are above a specified threshold and dynamically adjusts based on data trends.
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			foo, err := newrelic.NewAlertPolicy(ctx, "foo", &newrelic.AlertPolicyArgs{
//				Name: pulumi.String("foo"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = newrelic.NewNrqlAlertCondition(ctx, "foo", &newrelic.NrqlAlertConditionArgs{
//				AccountId:                   pulumi.String("your_account_id"),
//				PolicyId:                    foo.ID(),
//				Type:                        pulumi.String("static"),
//				Name:                        pulumi.String("foo"),
//				Description:                 pulumi.String("Alert when transactions are taking too long"),
//				RunbookUrl:                  pulumi.String("https://www.example.com"),
//				Enabled:                     pulumi.Bool(true),
//				ViolationTimeLimitSeconds:   pulumi.Int(3600),
//				FillOption:                  pulumi.String("static"),
//				FillValue:                   pulumi.Float64(1),
//				AggregationWindow:           pulumi.Int(60),
//				AggregationMethod:           pulumi.String("event_flow"),
//				AggregationDelay:            pulumi.String("120"),
//				ExpirationDuration:          pulumi.Int(120),
//				OpenViolationOnExpiration:   pulumi.Bool(true),
//				CloseViolationsOnExpiration: pulumi.Bool(true),
//				SlideBy:                     pulumi.Int(30),
//				Nrql: &newrelic.NrqlAlertConditionNrqlArgs{
//					Query: pulumi.String("SELECT average(duration) FROM Transaction where appName = 'Your App'"),
//				},
//				Critical: &newrelic.NrqlAlertConditionCriticalArgs{
//					Operator:             pulumi.String("above"),
//					Threshold:            pulumi.Float64(5.5),
//					ThresholdDuration:    pulumi.Int(300),
//					ThresholdOccurrences: pulumi.String("ALL"),
//				},
//				Warning: &newrelic.NrqlAlertConditionWarningArgs{
//					Operator:             pulumi.String("above"),
//					Threshold:            pulumi.Float64(3.5),
//					ThresholdDuration:    pulumi.Int(600),
//					ThresholdOccurrences: pulumi.String("ALL"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Tags
//
// Manage NRQL alert condition tags with `EntityTags`. For up-to-date documentation about the tagging resource, please check `EntityTags`.
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			foo, err := newrelic.NewAlertPolicy(ctx, "foo", &newrelic.AlertPolicyArgs{
//				Name: pulumi.String("foo"),
//			})
//			if err != nil {
//				return err
//			}
//			fooNrqlAlertCondition, err := newrelic.NewNrqlAlertCondition(ctx, "foo", &newrelic.NrqlAlertConditionArgs{
//				AccountId:                   pulumi.String("12345678"),
//				PolicyId:                    foo.ID(),
//				Type:                        pulumi.String("static"),
//				Name:                        pulumi.String("foo"),
//				Description:                 pulumi.String("Alert when transactions are taking too long"),
//				RunbookUrl:                  pulumi.String("https://www.example.com"),
//				Enabled:                     pulumi.Bool(true),
//				ViolationTimeLimitSeconds:   pulumi.Int(3600),
//				FillOption:                  pulumi.String("static"),
//				FillValue:                   pulumi.Float64(1),
//				AggregationWindow:           pulumi.Int(60),
//				AggregationMethod:           pulumi.String("event_flow"),
//				AggregationDelay:            pulumi.String("120"),
//				ExpirationDuration:          pulumi.Int(120),
//				OpenViolationOnExpiration:   pulumi.Bool(true),
//				CloseViolationsOnExpiration: pulumi.Bool(true),
//				SlideBy:                     pulumi.Int(30),
//				Nrql: &newrelic.NrqlAlertConditionNrqlArgs{
//					Query: pulumi.String("SELECT average(duration) FROM Transaction where appName = 'Your App'"),
//				},
//				Critical: &newrelic.NrqlAlertConditionCriticalArgs{
//					Operator:             pulumi.String("above"),
//					Threshold:            pulumi.Float64(5.5),
//					ThresholdDuration:    pulumi.Int(300),
//					ThresholdOccurrences: pulumi.String("ALL"),
//				},
//				Warning: &newrelic.NrqlAlertConditionWarningArgs{
//					Operator:             pulumi.String("above"),
//					Threshold:            pulumi.Float64(3.5),
//					ThresholdDuration:    pulumi.Int(600),
//					ThresholdOccurrences: pulumi.String("ALL"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = newrelic.NewEntityTags(ctx, "my_condition_entity_tags", &newrelic.EntityTagsArgs{
//				Guid: fooNrqlAlertCondition.EntityGuid,
//				Tags: newrelic.EntityTagsTagArray{
//					&newrelic.EntityTagsTagArgs{
//						Key: pulumi.String("my-key"),
//						Values: pulumi.StringArray{
//							pulumi.String("my-value"),
//							pulumi.String("my-other-value"),
//						},
//					},
//					&newrelic.EntityTagsTagArgs{
//						Key: pulumi.String("my-key-2"),
//						Values: pulumi.StringArray{
//							pulumi.String("my-value-2"),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// <small>alerts.newrelic.com/accounts/**\<account_id\>**/policies/**\<policy_id\>**/conditions/**\<condition_id\>**/edit</small>
//
// ## Upgrade from 1.x to 2.x
//
// There have been several deprecations in the `NrqlAlertCondition`
// resource. Users will need to make some updates in order to have a smooth
// upgrade.
//
// An example resource from 1.x might look like the following.
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := newrelic.NewNrqlAlertCondition(ctx, "z", &newrelic.NrqlAlertConditionArgs{
//				PolicyId:           pulumi.Any(zNewrelicAlertPolicy.Id),
//				Name:               pulumi.String("zleslie-test"),
//				Type:               pulumi.String("static"),
//				RunbookUrl:         pulumi.String("https://localhost"),
//				Enabled:            pulumi.Bool(true),
//				ViolationTimeLimit: pulumi.String("TWENTY_FOUR_HOURS"),
//				Critical: &newrelic.NrqlAlertConditionCriticalArgs{
//					Operator:             pulumi.String("above"),
//					ThresholdDuration:    pulumi.Int(120),
//					Threshold:            pulumi.Float64(3),
//					ThresholdOccurrences: pulumi.String("AT_LEAST_ONCE"),
//				},
//				Nrql: &newrelic.NrqlAlertConditionNrqlArgs{
//					Query: pulumi.String("SELECT count(*) FROM TransactionError WHERE appName like '%Dummy App%' FACET appName"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// After making the appropriate adjustments mentioned in the deprecation warnings,
// the resource now looks like the following.
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := newrelic.NewNrqlAlertCondition(ctx, "z", &newrelic.NrqlAlertConditionArgs{
//				PolicyId:                  pulumi.Any(zNewrelicAlertPolicy.Id),
//				Name:                      pulumi.String("zleslie-test"),
//				Type:                      pulumi.String("static"),
//				RunbookUrl:                pulumi.String("https://localhost"),
//				Enabled:                   pulumi.Bool(true),
//				ViolationTimeLimitSeconds: pulumi.Int(86400),
//				Terms: newrelic.NrqlAlertConditionTermArray{
//					&newrelic.NrqlAlertConditionTermArgs{
//						Priority:     pulumi.String("critical"),
//						Operator:     pulumi.String("above"),
//						Threshold:    pulumi.Float64(3),
//						Duration:     pulumi.Int(5),
//						TimeFunction: pulumi.String("any"),
//					},
//				},
//				Nrql: &newrelic.NrqlAlertConditionNrqlArgs{
//					Query: pulumi.String("SELECT count(*) FROM TransactionError WHERE appName like '%Dummy App%' FACET appName"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// NRQL alert conditions can be imported using a composite ID of `<policy_id>:<condition_id>:<conditionType>`, e.g.
//
// // For `baseline` conditions
//
// ```sh
// $ pulumi import newrelic:index/nrqlAlertCondition:NrqlAlertCondition foo 538291:6789035:baseline
// ```
//
// // For `static` conditions
//
// ```sh
// $ pulumi import newrelic:index/nrqlAlertCondition:NrqlAlertCondition foo 538291:6789035:static
// ```
type NrqlAlertCondition struct {
	pulumi.CustomResourceState

	// The New Relic account ID of the account you wish to create the condition. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
	AccountId pulumi.StringOutput `pulumi:"accountId"`
	// How long we wait for data that belongs in each aggregation window. Depending on your data, a longer delay may increase accuracy but delay notifications. Use `aggregationDelay` with the `eventFlow` and `cadence` methods. The maximum delay is 1200 seconds (20 minutes) when using `eventFlow` and 3600 seconds (60 minutes) when using `cadence`. In both cases, the minimum delay is 0 seconds and the default is 120 seconds. `aggregationDelay` cannot be set with `nrql.evaluation_offset`.
	AggregationDelay pulumi.StringPtrOutput `pulumi:"aggregationDelay"`
	// Determines when we consider an aggregation window to be complete so that we can evaluate the signal for incidents. Possible values are `cadence`, `eventFlow` or `eventTimer`. Default is `eventFlow`. `aggregationMethod` cannot be set with `nrql.evaluation_offset`.
	AggregationMethod pulumi.StringPtrOutput `pulumi:"aggregationMethod"`
	// How long we wait after each data point arrives to make sure we've processed the whole batch. Use `aggregationTimer` with the `eventTimer` method. The timer value can range from 0 seconds to 1200 seconds (20 minutes); the default is 60 seconds. `aggregationTimer` cannot be set with `nrql.evaluation_offset`.
	AggregationTimer pulumi.StringPtrOutput `pulumi:"aggregationTimer"`
	// The duration of the time window used to evaluate the NRQL query, in seconds. The value must be at least 30 seconds, and no more than 21600 seconds (6 hours). Default is 60 seconds.
	AggregationWindow pulumi.IntOutput `pulumi:"aggregationWindow"`
	// The baseline direction of a _baseline_ NRQL alert condition. Valid values are: `lowerOnly`, `upperAndLower`, `upperOnly` (case insensitive).
	BaselineDirection pulumi.StringPtrOutput `pulumi:"baselineDirection"`
	// Whether to close all open incidents when the signal expires.
	CloseViolationsOnExpiration pulumi.BoolPtrOutput `pulumi:"closeViolationsOnExpiration"`
	// A list containing the `critical` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
	Critical NrqlAlertConditionCriticalPtrOutput `pulumi:"critical"`
	// The description of the NRQL alert condition.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Whether to enable the alert condition. Valid values are `true` and `false`. Defaults to `true`.
	Enabled pulumi.BoolPtrOutput `pulumi:"enabled"`
	// The unique entity identifier of the NRQL Condition in New Relic.
	EntityGuid pulumi.StringOutput `pulumi:"entityGuid"`
	// How long we wait until the signal starts evaluating. The maximum delay is 7200 seconds (120 minutes).
	EvaluationDelay pulumi.IntPtrOutput `pulumi:"evaluationDelay"`
	// The amount of time (in seconds) to wait before considering the signal expired. The value must be at least 30 seconds, and no more than 172800 seconds (48 hours).
	ExpirationDuration pulumi.IntPtrOutput `pulumi:"expirationDuration"`
	// Which strategy to use when filling gaps in the signal. Possible values are `none`, `lastValue` or `static`. If `static`, the `fillValue` field will be used for filling gaps in the signal.
	FillOption pulumi.StringPtrOutput `pulumi:"fillOption"`
	// This value will be used for filling gaps in the signal.
	FillValue pulumi.Float64PtrOutput `pulumi:"fillValue"`
	// Whether an alert condition should ignore expected termination of a signal when considering whether to create a loss of signal incident. Defaults to false.
	IgnoreOnExpectedTermination pulumi.BoolPtrOutput `pulumi:"ignoreOnExpectedTermination"`
	// The title of the condition.
	Name pulumi.StringOutput `pulumi:"name"`
	// A NRQL query. See NRQL below for details.
	Nrql NrqlAlertConditionNrqlOutput `pulumi:"nrql"`
	// Whether to create a new incident to capture that the signal expired.
	OpenViolationOnExpiration pulumi.BoolPtrOutput `pulumi:"openViolationOnExpiration"`
	// The ID of the policy where this condition should be used.
	PolicyId pulumi.StringOutput `pulumi:"policyId"`
	// Runbook URL to display in notifications.
	RunbookUrl pulumi.StringPtrOutput `pulumi:"runbookUrl"`
	// Seasonality under which a condition's signal(s) are evaluated. Only available for baseline conditions. Valid values are: `NEW_RELIC_CALCULATION`, `HOURLY`, `DAILY`, `WEEKLY`, or `NONE`. To have New Relic calculate seasonality automatically, set to `NEW_RELIC_CALCULATION`. To turn off seasonality completely, set to `NONE`.
	SignalSeasonality pulumi.StringPtrOutput `pulumi:"signalSeasonality"`
	// Gathers data in overlapping time windows to smooth the chart line, making it easier to spot trends. The `slideBy` value is specified in seconds and must be smaller than and a factor of the `aggregationWindow`.
	SlideBy pulumi.IntPtrOutput `pulumi:"slideBy"`
	// BETA PREVIEW: The GUID of the entity explicitly targeted by the condition. Issues triggered by this condition will affect the health status of this entity instead of having the affected entity detected automatically. The entity's account ID must be either `accountId` or `nrql.data_account_id`.
	TargetEntity pulumi.StringPtrOutput `pulumi:"targetEntity"`
	// **DEPRECATED** Use `critical`, and `warning` instead. A list of terms for this condition. See Terms below for details.
	//
	// Deprecated: use `critical` and `warning` attributes instead
	Terms NrqlAlertConditionTermArrayOutput `pulumi:"terms"`
	// The custom title to be used when incidents are opened by the condition. Setting this field will override the default title. Must be [Handlebars](https://handlebarsjs.com/) format.
	TitleTemplate pulumi.StringPtrOutput `pulumi:"titleTemplate"`
	// The type of the condition. Valid values are `static` or `baseline`. Defaults to `static`.
	Type pulumi.StringPtrOutput `pulumi:"type"`
	// **DEPRECATED:** Use `violationTimeLimitSeconds` instead. Sets a time limit, in hours, that will automatically force-close a long-lasting incident after the time limit you select. Possible values are `ONE_HOUR`, `TWO_HOURS`, `FOUR_HOURS`, `EIGHT_HOURS`, `TWELVE_HOURS`, `TWENTY_FOUR_HOURS`, `THIRTY_DAYS` (case insensitive).<br>
	// <small>\***Note**: One of `violationTimeLimit` _or_ `violationTimeLimitSeconds` must be set, but not both.</small>
	//
	// Deprecated: use `violationTimeLimitSeconds` attribute instead
	ViolationTimeLimit pulumi.StringOutput `pulumi:"violationTimeLimit"`
	// Sets a time limit, in seconds, that will automatically force-close a long-lasting incident after the time limit you select. The value must be between 300 seconds (5 minutes) to 2592000 seconds (30 days) (inclusive). <br>
	// <small>\***Note**: One of `violationTimeLimit` _or_ `violationTimeLimitSeconds` must be set, but not both.</small>
	ViolationTimeLimitSeconds pulumi.IntPtrOutput `pulumi:"violationTimeLimitSeconds"`
	// A list containing the `warning` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
	Warning NrqlAlertConditionWarningPtrOutput `pulumi:"warning"`
}

// NewNrqlAlertCondition registers a new resource with the given unique name, arguments, and options.
func NewNrqlAlertCondition(ctx *pulumi.Context,
	name string, args *NrqlAlertConditionArgs, opts ...pulumi.ResourceOption) (*NrqlAlertCondition, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Nrql == nil {
		return nil, errors.New("invalid value for required argument 'Nrql'")
	}
	if args.PolicyId == nil {
		return nil, errors.New("invalid value for required argument 'PolicyId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource NrqlAlertCondition
	err := ctx.RegisterResource("newrelic:index/nrqlAlertCondition:NrqlAlertCondition", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetNrqlAlertCondition gets an existing NrqlAlertCondition resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetNrqlAlertCondition(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *NrqlAlertConditionState, opts ...pulumi.ResourceOption) (*NrqlAlertCondition, error) {
	var resource NrqlAlertCondition
	err := ctx.ReadResource("newrelic:index/nrqlAlertCondition:NrqlAlertCondition", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering NrqlAlertCondition resources.
type nrqlAlertConditionState struct {
	// The New Relic account ID of the account you wish to create the condition. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
	AccountId *string `pulumi:"accountId"`
	// How long we wait for data that belongs in each aggregation window. Depending on your data, a longer delay may increase accuracy but delay notifications. Use `aggregationDelay` with the `eventFlow` and `cadence` methods. The maximum delay is 1200 seconds (20 minutes) when using `eventFlow` and 3600 seconds (60 minutes) when using `cadence`. In both cases, the minimum delay is 0 seconds and the default is 120 seconds. `aggregationDelay` cannot be set with `nrql.evaluation_offset`.
	AggregationDelay *string `pulumi:"aggregationDelay"`
	// Determines when we consider an aggregation window to be complete so that we can evaluate the signal for incidents. Possible values are `cadence`, `eventFlow` or `eventTimer`. Default is `eventFlow`. `aggregationMethod` cannot be set with `nrql.evaluation_offset`.
	AggregationMethod *string `pulumi:"aggregationMethod"`
	// How long we wait after each data point arrives to make sure we've processed the whole batch. Use `aggregationTimer` with the `eventTimer` method. The timer value can range from 0 seconds to 1200 seconds (20 minutes); the default is 60 seconds. `aggregationTimer` cannot be set with `nrql.evaluation_offset`.
	AggregationTimer *string `pulumi:"aggregationTimer"`
	// The duration of the time window used to evaluate the NRQL query, in seconds. The value must be at least 30 seconds, and no more than 21600 seconds (6 hours). Default is 60 seconds.
	AggregationWindow *int `pulumi:"aggregationWindow"`
	// The baseline direction of a _baseline_ NRQL alert condition. Valid values are: `lowerOnly`, `upperAndLower`, `upperOnly` (case insensitive).
	BaselineDirection *string `pulumi:"baselineDirection"`
	// Whether to close all open incidents when the signal expires.
	CloseViolationsOnExpiration *bool `pulumi:"closeViolationsOnExpiration"`
	// A list containing the `critical` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
	Critical *NrqlAlertConditionCritical `pulumi:"critical"`
	// The description of the NRQL alert condition.
	Description *string `pulumi:"description"`
	// Whether to enable the alert condition. Valid values are `true` and `false`. Defaults to `true`.
	Enabled *bool `pulumi:"enabled"`
	// The unique entity identifier of the NRQL Condition in New Relic.
	EntityGuid *string `pulumi:"entityGuid"`
	// How long we wait until the signal starts evaluating. The maximum delay is 7200 seconds (120 minutes).
	EvaluationDelay *int `pulumi:"evaluationDelay"`
	// The amount of time (in seconds) to wait before considering the signal expired. The value must be at least 30 seconds, and no more than 172800 seconds (48 hours).
	ExpirationDuration *int `pulumi:"expirationDuration"`
	// Which strategy to use when filling gaps in the signal. Possible values are `none`, `lastValue` or `static`. If `static`, the `fillValue` field will be used for filling gaps in the signal.
	FillOption *string `pulumi:"fillOption"`
	// This value will be used for filling gaps in the signal.
	FillValue *float64 `pulumi:"fillValue"`
	// Whether an alert condition should ignore expected termination of a signal when considering whether to create a loss of signal incident. Defaults to false.
	IgnoreOnExpectedTermination *bool `pulumi:"ignoreOnExpectedTermination"`
	// The title of the condition.
	Name *string `pulumi:"name"`
	// A NRQL query. See NRQL below for details.
	Nrql *NrqlAlertConditionNrql `pulumi:"nrql"`
	// Whether to create a new incident to capture that the signal expired.
	OpenViolationOnExpiration *bool `pulumi:"openViolationOnExpiration"`
	// The ID of the policy where this condition should be used.
	PolicyId *string `pulumi:"policyId"`
	// Runbook URL to display in notifications.
	RunbookUrl *string `pulumi:"runbookUrl"`
	// Seasonality under which a condition's signal(s) are evaluated. Only available for baseline conditions. Valid values are: `NEW_RELIC_CALCULATION`, `HOURLY`, `DAILY`, `WEEKLY`, or `NONE`. To have New Relic calculate seasonality automatically, set to `NEW_RELIC_CALCULATION`. To turn off seasonality completely, set to `NONE`.
	SignalSeasonality *string `pulumi:"signalSeasonality"`
	// Gathers data in overlapping time windows to smooth the chart line, making it easier to spot trends. The `slideBy` value is specified in seconds and must be smaller than and a factor of the `aggregationWindow`.
	SlideBy *int `pulumi:"slideBy"`
	// BETA PREVIEW: The GUID of the entity explicitly targeted by the condition. Issues triggered by this condition will affect the health status of this entity instead of having the affected entity detected automatically. The entity's account ID must be either `accountId` or `nrql.data_account_id`.
	TargetEntity *string `pulumi:"targetEntity"`
	// **DEPRECATED** Use `critical`, and `warning` instead. A list of terms for this condition. See Terms below for details.
	//
	// Deprecated: use `critical` and `warning` attributes instead
	Terms []NrqlAlertConditionTerm `pulumi:"terms"`
	// The custom title to be used when incidents are opened by the condition. Setting this field will override the default title. Must be [Handlebars](https://handlebarsjs.com/) format.
	TitleTemplate *string `pulumi:"titleTemplate"`
	// The type of the condition. Valid values are `static` or `baseline`. Defaults to `static`.
	Type *string `pulumi:"type"`
	// **DEPRECATED:** Use `violationTimeLimitSeconds` instead. Sets a time limit, in hours, that will automatically force-close a long-lasting incident after the time limit you select. Possible values are `ONE_HOUR`, `TWO_HOURS`, `FOUR_HOURS`, `EIGHT_HOURS`, `TWELVE_HOURS`, `TWENTY_FOUR_HOURS`, `THIRTY_DAYS` (case insensitive).<br>
	// <small>\***Note**: One of `violationTimeLimit` _or_ `violationTimeLimitSeconds` must be set, but not both.</small>
	//
	// Deprecated: use `violationTimeLimitSeconds` attribute instead
	ViolationTimeLimit *string `pulumi:"violationTimeLimit"`
	// Sets a time limit, in seconds, that will automatically force-close a long-lasting incident after the time limit you select. The value must be between 300 seconds (5 minutes) to 2592000 seconds (30 days) (inclusive). <br>
	// <small>\***Note**: One of `violationTimeLimit` _or_ `violationTimeLimitSeconds` must be set, but not both.</small>
	ViolationTimeLimitSeconds *int `pulumi:"violationTimeLimitSeconds"`
	// A list containing the `warning` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
	Warning *NrqlAlertConditionWarning `pulumi:"warning"`
}

type NrqlAlertConditionState struct {
	// The New Relic account ID of the account you wish to create the condition. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
	AccountId pulumi.StringPtrInput
	// How long we wait for data that belongs in each aggregation window. Depending on your data, a longer delay may increase accuracy but delay notifications. Use `aggregationDelay` with the `eventFlow` and `cadence` methods. The maximum delay is 1200 seconds (20 minutes) when using `eventFlow` and 3600 seconds (60 minutes) when using `cadence`. In both cases, the minimum delay is 0 seconds and the default is 120 seconds. `aggregationDelay` cannot be set with `nrql.evaluation_offset`.
	AggregationDelay pulumi.StringPtrInput
	// Determines when we consider an aggregation window to be complete so that we can evaluate the signal for incidents. Possible values are `cadence`, `eventFlow` or `eventTimer`. Default is `eventFlow`. `aggregationMethod` cannot be set with `nrql.evaluation_offset`.
	AggregationMethod pulumi.StringPtrInput
	// How long we wait after each data point arrives to make sure we've processed the whole batch. Use `aggregationTimer` with the `eventTimer` method. The timer value can range from 0 seconds to 1200 seconds (20 minutes); the default is 60 seconds. `aggregationTimer` cannot be set with `nrql.evaluation_offset`.
	AggregationTimer pulumi.StringPtrInput
	// The duration of the time window used to evaluate the NRQL query, in seconds. The value must be at least 30 seconds, and no more than 21600 seconds (6 hours). Default is 60 seconds.
	AggregationWindow pulumi.IntPtrInput
	// The baseline direction of a _baseline_ NRQL alert condition. Valid values are: `lowerOnly`, `upperAndLower`, `upperOnly` (case insensitive).
	BaselineDirection pulumi.StringPtrInput
	// Whether to close all open incidents when the signal expires.
	CloseViolationsOnExpiration pulumi.BoolPtrInput
	// A list containing the `critical` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
	Critical NrqlAlertConditionCriticalPtrInput
	// The description of the NRQL alert condition.
	Description pulumi.StringPtrInput
	// Whether to enable the alert condition. Valid values are `true` and `false`. Defaults to `true`.
	Enabled pulumi.BoolPtrInput
	// The unique entity identifier of the NRQL Condition in New Relic.
	EntityGuid pulumi.StringPtrInput
	// How long we wait until the signal starts evaluating. The maximum delay is 7200 seconds (120 minutes).
	EvaluationDelay pulumi.IntPtrInput
	// The amount of time (in seconds) to wait before considering the signal expired. The value must be at least 30 seconds, and no more than 172800 seconds (48 hours).
	ExpirationDuration pulumi.IntPtrInput
	// Which strategy to use when filling gaps in the signal. Possible values are `none`, `lastValue` or `static`. If `static`, the `fillValue` field will be used for filling gaps in the signal.
	FillOption pulumi.StringPtrInput
	// This value will be used for filling gaps in the signal.
	FillValue pulumi.Float64PtrInput
	// Whether an alert condition should ignore expected termination of a signal when considering whether to create a loss of signal incident. Defaults to false.
	IgnoreOnExpectedTermination pulumi.BoolPtrInput
	// The title of the condition.
	Name pulumi.StringPtrInput
	// A NRQL query. See NRQL below for details.
	Nrql NrqlAlertConditionNrqlPtrInput
	// Whether to create a new incident to capture that the signal expired.
	OpenViolationOnExpiration pulumi.BoolPtrInput
	// The ID of the policy where this condition should be used.
	PolicyId pulumi.StringPtrInput
	// Runbook URL to display in notifications.
	RunbookUrl pulumi.StringPtrInput
	// Seasonality under which a condition's signal(s) are evaluated. Only available for baseline conditions. Valid values are: `NEW_RELIC_CALCULATION`, `HOURLY`, `DAILY`, `WEEKLY`, or `NONE`. To have New Relic calculate seasonality automatically, set to `NEW_RELIC_CALCULATION`. To turn off seasonality completely, set to `NONE`.
	SignalSeasonality pulumi.StringPtrInput
	// Gathers data in overlapping time windows to smooth the chart line, making it easier to spot trends. The `slideBy` value is specified in seconds and must be smaller than and a factor of the `aggregationWindow`.
	SlideBy pulumi.IntPtrInput
	// BETA PREVIEW: The GUID of the entity explicitly targeted by the condition. Issues triggered by this condition will affect the health status of this entity instead of having the affected entity detected automatically. The entity's account ID must be either `accountId` or `nrql.data_account_id`.
	TargetEntity pulumi.StringPtrInput
	// **DEPRECATED** Use `critical`, and `warning` instead. A list of terms for this condition. See Terms below for details.
	//
	// Deprecated: use `critical` and `warning` attributes instead
	Terms NrqlAlertConditionTermArrayInput
	// The custom title to be used when incidents are opened by the condition. Setting this field will override the default title. Must be [Handlebars](https://handlebarsjs.com/) format.
	TitleTemplate pulumi.StringPtrInput
	// The type of the condition. Valid values are `static` or `baseline`. Defaults to `static`.
	Type pulumi.StringPtrInput
	// **DEPRECATED:** Use `violationTimeLimitSeconds` instead. Sets a time limit, in hours, that will automatically force-close a long-lasting incident after the time limit you select. Possible values are `ONE_HOUR`, `TWO_HOURS`, `FOUR_HOURS`, `EIGHT_HOURS`, `TWELVE_HOURS`, `TWENTY_FOUR_HOURS`, `THIRTY_DAYS` (case insensitive).<br>
	// <small>\***Note**: One of `violationTimeLimit` _or_ `violationTimeLimitSeconds` must be set, but not both.</small>
	//
	// Deprecated: use `violationTimeLimitSeconds` attribute instead
	ViolationTimeLimit pulumi.StringPtrInput
	// Sets a time limit, in seconds, that will automatically force-close a long-lasting incident after the time limit you select. The value must be between 300 seconds (5 minutes) to 2592000 seconds (30 days) (inclusive). <br>
	// <small>\***Note**: One of `violationTimeLimit` _or_ `violationTimeLimitSeconds` must be set, but not both.</small>
	ViolationTimeLimitSeconds pulumi.IntPtrInput
	// A list containing the `warning` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
	Warning NrqlAlertConditionWarningPtrInput
}

func (NrqlAlertConditionState) ElementType() reflect.Type {
	return reflect.TypeOf((*nrqlAlertConditionState)(nil)).Elem()
}

type nrqlAlertConditionArgs struct {
	// The New Relic account ID of the account you wish to create the condition. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
	AccountId *string `pulumi:"accountId"`
	// How long we wait for data that belongs in each aggregation window. Depending on your data, a longer delay may increase accuracy but delay notifications. Use `aggregationDelay` with the `eventFlow` and `cadence` methods. The maximum delay is 1200 seconds (20 minutes) when using `eventFlow` and 3600 seconds (60 minutes) when using `cadence`. In both cases, the minimum delay is 0 seconds and the default is 120 seconds. `aggregationDelay` cannot be set with `nrql.evaluation_offset`.
	AggregationDelay *string `pulumi:"aggregationDelay"`
	// Determines when we consider an aggregation window to be complete so that we can evaluate the signal for incidents. Possible values are `cadence`, `eventFlow` or `eventTimer`. Default is `eventFlow`. `aggregationMethod` cannot be set with `nrql.evaluation_offset`.
	AggregationMethod *string `pulumi:"aggregationMethod"`
	// How long we wait after each data point arrives to make sure we've processed the whole batch. Use `aggregationTimer` with the `eventTimer` method. The timer value can range from 0 seconds to 1200 seconds (20 minutes); the default is 60 seconds. `aggregationTimer` cannot be set with `nrql.evaluation_offset`.
	AggregationTimer *string `pulumi:"aggregationTimer"`
	// The duration of the time window used to evaluate the NRQL query, in seconds. The value must be at least 30 seconds, and no more than 21600 seconds (6 hours). Default is 60 seconds.
	AggregationWindow *int `pulumi:"aggregationWindow"`
	// The baseline direction of a _baseline_ NRQL alert condition. Valid values are: `lowerOnly`, `upperAndLower`, `upperOnly` (case insensitive).
	BaselineDirection *string `pulumi:"baselineDirection"`
	// Whether to close all open incidents when the signal expires.
	CloseViolationsOnExpiration *bool `pulumi:"closeViolationsOnExpiration"`
	// A list containing the `critical` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
	Critical *NrqlAlertConditionCritical `pulumi:"critical"`
	// The description of the NRQL alert condition.
	Description *string `pulumi:"description"`
	// Whether to enable the alert condition. Valid values are `true` and `false`. Defaults to `true`.
	Enabled *bool `pulumi:"enabled"`
	// How long we wait until the signal starts evaluating. The maximum delay is 7200 seconds (120 minutes).
	EvaluationDelay *int `pulumi:"evaluationDelay"`
	// The amount of time (in seconds) to wait before considering the signal expired. The value must be at least 30 seconds, and no more than 172800 seconds (48 hours).
	ExpirationDuration *int `pulumi:"expirationDuration"`
	// Which strategy to use when filling gaps in the signal. Possible values are `none`, `lastValue` or `static`. If `static`, the `fillValue` field will be used for filling gaps in the signal.
	FillOption *string `pulumi:"fillOption"`
	// This value will be used for filling gaps in the signal.
	FillValue *float64 `pulumi:"fillValue"`
	// Whether an alert condition should ignore expected termination of a signal when considering whether to create a loss of signal incident. Defaults to false.
	IgnoreOnExpectedTermination *bool `pulumi:"ignoreOnExpectedTermination"`
	// The title of the condition.
	Name *string `pulumi:"name"`
	// A NRQL query. See NRQL below for details.
	Nrql NrqlAlertConditionNrql `pulumi:"nrql"`
	// Whether to create a new incident to capture that the signal expired.
	OpenViolationOnExpiration *bool `pulumi:"openViolationOnExpiration"`
	// The ID of the policy where this condition should be used.
	PolicyId string `pulumi:"policyId"`
	// Runbook URL to display in notifications.
	RunbookUrl *string `pulumi:"runbookUrl"`
	// Seasonality under which a condition's signal(s) are evaluated. Only available for baseline conditions. Valid values are: `NEW_RELIC_CALCULATION`, `HOURLY`, `DAILY`, `WEEKLY`, or `NONE`. To have New Relic calculate seasonality automatically, set to `NEW_RELIC_CALCULATION`. To turn off seasonality completely, set to `NONE`.
	SignalSeasonality *string `pulumi:"signalSeasonality"`
	// Gathers data in overlapping time windows to smooth the chart line, making it easier to spot trends. The `slideBy` value is specified in seconds and must be smaller than and a factor of the `aggregationWindow`.
	SlideBy *int `pulumi:"slideBy"`
	// BETA PREVIEW: The GUID of the entity explicitly targeted by the condition. Issues triggered by this condition will affect the health status of this entity instead of having the affected entity detected automatically. The entity's account ID must be either `accountId` or `nrql.data_account_id`.
	TargetEntity *string `pulumi:"targetEntity"`
	// **DEPRECATED** Use `critical`, and `warning` instead. A list of terms for this condition. See Terms below for details.
	//
	// Deprecated: use `critical` and `warning` attributes instead
	Terms []NrqlAlertConditionTerm `pulumi:"terms"`
	// The custom title to be used when incidents are opened by the condition. Setting this field will override the default title. Must be [Handlebars](https://handlebarsjs.com/) format.
	TitleTemplate *string `pulumi:"titleTemplate"`
	// The type of the condition. Valid values are `static` or `baseline`. Defaults to `static`.
	Type *string `pulumi:"type"`
	// **DEPRECATED:** Use `violationTimeLimitSeconds` instead. Sets a time limit, in hours, that will automatically force-close a long-lasting incident after the time limit you select. Possible values are `ONE_HOUR`, `TWO_HOURS`, `FOUR_HOURS`, `EIGHT_HOURS`, `TWELVE_HOURS`, `TWENTY_FOUR_HOURS`, `THIRTY_DAYS` (case insensitive).<br>
	// <small>\***Note**: One of `violationTimeLimit` _or_ `violationTimeLimitSeconds` must be set, but not both.</small>
	//
	// Deprecated: use `violationTimeLimitSeconds` attribute instead
	ViolationTimeLimit *string `pulumi:"violationTimeLimit"`
	// Sets a time limit, in seconds, that will automatically force-close a long-lasting incident after the time limit you select. The value must be between 300 seconds (5 minutes) to 2592000 seconds (30 days) (inclusive). <br>
	// <small>\***Note**: One of `violationTimeLimit` _or_ `violationTimeLimitSeconds` must be set, but not both.</small>
	ViolationTimeLimitSeconds *int `pulumi:"violationTimeLimitSeconds"`
	// A list containing the `warning` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
	Warning *NrqlAlertConditionWarning `pulumi:"warning"`
}

// The set of arguments for constructing a NrqlAlertCondition resource.
type NrqlAlertConditionArgs struct {
	// The New Relic account ID of the account you wish to create the condition. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
	AccountId pulumi.StringPtrInput
	// How long we wait for data that belongs in each aggregation window. Depending on your data, a longer delay may increase accuracy but delay notifications. Use `aggregationDelay` with the `eventFlow` and `cadence` methods. The maximum delay is 1200 seconds (20 minutes) when using `eventFlow` and 3600 seconds (60 minutes) when using `cadence`. In both cases, the minimum delay is 0 seconds and the default is 120 seconds. `aggregationDelay` cannot be set with `nrql.evaluation_offset`.
	AggregationDelay pulumi.StringPtrInput
	// Determines when we consider an aggregation window to be complete so that we can evaluate the signal for incidents. Possible values are `cadence`, `eventFlow` or `eventTimer`. Default is `eventFlow`. `aggregationMethod` cannot be set with `nrql.evaluation_offset`.
	AggregationMethod pulumi.StringPtrInput
	// How long we wait after each data point arrives to make sure we've processed the whole batch. Use `aggregationTimer` with the `eventTimer` method. The timer value can range from 0 seconds to 1200 seconds (20 minutes); the default is 60 seconds. `aggregationTimer` cannot be set with `nrql.evaluation_offset`.
	AggregationTimer pulumi.StringPtrInput
	// The duration of the time window used to evaluate the NRQL query, in seconds. The value must be at least 30 seconds, and no more than 21600 seconds (6 hours). Default is 60 seconds.
	AggregationWindow pulumi.IntPtrInput
	// The baseline direction of a _baseline_ NRQL alert condition. Valid values are: `lowerOnly`, `upperAndLower`, `upperOnly` (case insensitive).
	BaselineDirection pulumi.StringPtrInput
	// Whether to close all open incidents when the signal expires.
	CloseViolationsOnExpiration pulumi.BoolPtrInput
	// A list containing the `critical` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
	Critical NrqlAlertConditionCriticalPtrInput
	// The description of the NRQL alert condition.
	Description pulumi.StringPtrInput
	// Whether to enable the alert condition. Valid values are `true` and `false`. Defaults to `true`.
	Enabled pulumi.BoolPtrInput
	// How long we wait until the signal starts evaluating. The maximum delay is 7200 seconds (120 minutes).
	EvaluationDelay pulumi.IntPtrInput
	// The amount of time (in seconds) to wait before considering the signal expired. The value must be at least 30 seconds, and no more than 172800 seconds (48 hours).
	ExpirationDuration pulumi.IntPtrInput
	// Which strategy to use when filling gaps in the signal. Possible values are `none`, `lastValue` or `static`. If `static`, the `fillValue` field will be used for filling gaps in the signal.
	FillOption pulumi.StringPtrInput
	// This value will be used for filling gaps in the signal.
	FillValue pulumi.Float64PtrInput
	// Whether an alert condition should ignore expected termination of a signal when considering whether to create a loss of signal incident. Defaults to false.
	IgnoreOnExpectedTermination pulumi.BoolPtrInput
	// The title of the condition.
	Name pulumi.StringPtrInput
	// A NRQL query. See NRQL below for details.
	Nrql NrqlAlertConditionNrqlInput
	// Whether to create a new incident to capture that the signal expired.
	OpenViolationOnExpiration pulumi.BoolPtrInput
	// The ID of the policy where this condition should be used.
	PolicyId pulumi.StringInput
	// Runbook URL to display in notifications.
	RunbookUrl pulumi.StringPtrInput
	// Seasonality under which a condition's signal(s) are evaluated. Only available for baseline conditions. Valid values are: `NEW_RELIC_CALCULATION`, `HOURLY`, `DAILY`, `WEEKLY`, or `NONE`. To have New Relic calculate seasonality automatically, set to `NEW_RELIC_CALCULATION`. To turn off seasonality completely, set to `NONE`.
	SignalSeasonality pulumi.StringPtrInput
	// Gathers data in overlapping time windows to smooth the chart line, making it easier to spot trends. The `slideBy` value is specified in seconds and must be smaller than and a factor of the `aggregationWindow`.
	SlideBy pulumi.IntPtrInput
	// BETA PREVIEW: The GUID of the entity explicitly targeted by the condition. Issues triggered by this condition will affect the health status of this entity instead of having the affected entity detected automatically. The entity's account ID must be either `accountId` or `nrql.data_account_id`.
	TargetEntity pulumi.StringPtrInput
	// **DEPRECATED** Use `critical`, and `warning` instead. A list of terms for this condition. See Terms below for details.
	//
	// Deprecated: use `critical` and `warning` attributes instead
	Terms NrqlAlertConditionTermArrayInput
	// The custom title to be used when incidents are opened by the condition. Setting this field will override the default title. Must be [Handlebars](https://handlebarsjs.com/) format.
	TitleTemplate pulumi.StringPtrInput
	// The type of the condition. Valid values are `static` or `baseline`. Defaults to `static`.
	Type pulumi.StringPtrInput
	// **DEPRECATED:** Use `violationTimeLimitSeconds` instead. Sets a time limit, in hours, that will automatically force-close a long-lasting incident after the time limit you select. Possible values are `ONE_HOUR`, `TWO_HOURS`, `FOUR_HOURS`, `EIGHT_HOURS`, `TWELVE_HOURS`, `TWENTY_FOUR_HOURS`, `THIRTY_DAYS` (case insensitive).<br>
	// <small>\***Note**: One of `violationTimeLimit` _or_ `violationTimeLimitSeconds` must be set, but not both.</small>
	//
	// Deprecated: use `violationTimeLimitSeconds` attribute instead
	ViolationTimeLimit pulumi.StringPtrInput
	// Sets a time limit, in seconds, that will automatically force-close a long-lasting incident after the time limit you select. The value must be between 300 seconds (5 minutes) to 2592000 seconds (30 days) (inclusive). <br>
	// <small>\***Note**: One of `violationTimeLimit` _or_ `violationTimeLimitSeconds` must be set, but not both.</small>
	ViolationTimeLimitSeconds pulumi.IntPtrInput
	// A list containing the `warning` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
	Warning NrqlAlertConditionWarningPtrInput
}

func (NrqlAlertConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*nrqlAlertConditionArgs)(nil)).Elem()
}

type NrqlAlertConditionInput interface {
	pulumi.Input

	ToNrqlAlertConditionOutput() NrqlAlertConditionOutput
	ToNrqlAlertConditionOutputWithContext(ctx context.Context) NrqlAlertConditionOutput
}

func (*NrqlAlertCondition) ElementType() reflect.Type {
	return reflect.TypeOf((**NrqlAlertCondition)(nil)).Elem()
}

func (i *NrqlAlertCondition) ToNrqlAlertConditionOutput() NrqlAlertConditionOutput {
	return i.ToNrqlAlertConditionOutputWithContext(context.Background())
}

func (i *NrqlAlertCondition) ToNrqlAlertConditionOutputWithContext(ctx context.Context) NrqlAlertConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NrqlAlertConditionOutput)
}

// NrqlAlertConditionArrayInput is an input type that accepts NrqlAlertConditionArray and NrqlAlertConditionArrayOutput values.
// You can construct a concrete instance of `NrqlAlertConditionArrayInput` via:
//
//	NrqlAlertConditionArray{ NrqlAlertConditionArgs{...} }
type NrqlAlertConditionArrayInput interface {
	pulumi.Input

	ToNrqlAlertConditionArrayOutput() NrqlAlertConditionArrayOutput
	ToNrqlAlertConditionArrayOutputWithContext(context.Context) NrqlAlertConditionArrayOutput
}

type NrqlAlertConditionArray []NrqlAlertConditionInput

func (NrqlAlertConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NrqlAlertCondition)(nil)).Elem()
}

func (i NrqlAlertConditionArray) ToNrqlAlertConditionArrayOutput() NrqlAlertConditionArrayOutput {
	return i.ToNrqlAlertConditionArrayOutputWithContext(context.Background())
}

func (i NrqlAlertConditionArray) ToNrqlAlertConditionArrayOutputWithContext(ctx context.Context) NrqlAlertConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NrqlAlertConditionArrayOutput)
}

// NrqlAlertConditionMapInput is an input type that accepts NrqlAlertConditionMap and NrqlAlertConditionMapOutput values.
// You can construct a concrete instance of `NrqlAlertConditionMapInput` via:
//
//	NrqlAlertConditionMap{ "key": NrqlAlertConditionArgs{...} }
type NrqlAlertConditionMapInput interface {
	pulumi.Input

	ToNrqlAlertConditionMapOutput() NrqlAlertConditionMapOutput
	ToNrqlAlertConditionMapOutputWithContext(context.Context) NrqlAlertConditionMapOutput
}

type NrqlAlertConditionMap map[string]NrqlAlertConditionInput

func (NrqlAlertConditionMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NrqlAlertCondition)(nil)).Elem()
}

func (i NrqlAlertConditionMap) ToNrqlAlertConditionMapOutput() NrqlAlertConditionMapOutput {
	return i.ToNrqlAlertConditionMapOutputWithContext(context.Background())
}

func (i NrqlAlertConditionMap) ToNrqlAlertConditionMapOutputWithContext(ctx context.Context) NrqlAlertConditionMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NrqlAlertConditionMapOutput)
}

type NrqlAlertConditionOutput struct{ *pulumi.OutputState }

func (NrqlAlertConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NrqlAlertCondition)(nil)).Elem()
}

func (o NrqlAlertConditionOutput) ToNrqlAlertConditionOutput() NrqlAlertConditionOutput {
	return o
}

func (o NrqlAlertConditionOutput) ToNrqlAlertConditionOutputWithContext(ctx context.Context) NrqlAlertConditionOutput {
	return o
}

// The New Relic account ID of the account you wish to create the condition. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
func (o NrqlAlertConditionOutput) AccountId() pulumi.StringOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.StringOutput { return v.AccountId }).(pulumi.StringOutput)
}

// How long we wait for data that belongs in each aggregation window. Depending on your data, a longer delay may increase accuracy but delay notifications. Use `aggregationDelay` with the `eventFlow` and `cadence` methods. The maximum delay is 1200 seconds (20 minutes) when using `eventFlow` and 3600 seconds (60 minutes) when using `cadence`. In both cases, the minimum delay is 0 seconds and the default is 120 seconds. `aggregationDelay` cannot be set with `nrql.evaluation_offset`.
func (o NrqlAlertConditionOutput) AggregationDelay() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.StringPtrOutput { return v.AggregationDelay }).(pulumi.StringPtrOutput)
}

// Determines when we consider an aggregation window to be complete so that we can evaluate the signal for incidents. Possible values are `cadence`, `eventFlow` or `eventTimer`. Default is `eventFlow`. `aggregationMethod` cannot be set with `nrql.evaluation_offset`.
func (o NrqlAlertConditionOutput) AggregationMethod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.StringPtrOutput { return v.AggregationMethod }).(pulumi.StringPtrOutput)
}

// How long we wait after each data point arrives to make sure we've processed the whole batch. Use `aggregationTimer` with the `eventTimer` method. The timer value can range from 0 seconds to 1200 seconds (20 minutes); the default is 60 seconds. `aggregationTimer` cannot be set with `nrql.evaluation_offset`.
func (o NrqlAlertConditionOutput) AggregationTimer() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.StringPtrOutput { return v.AggregationTimer }).(pulumi.StringPtrOutput)
}

// The duration of the time window used to evaluate the NRQL query, in seconds. The value must be at least 30 seconds, and no more than 21600 seconds (6 hours). Default is 60 seconds.
func (o NrqlAlertConditionOutput) AggregationWindow() pulumi.IntOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.IntOutput { return v.AggregationWindow }).(pulumi.IntOutput)
}

// The baseline direction of a _baseline_ NRQL alert condition. Valid values are: `lowerOnly`, `upperAndLower`, `upperOnly` (case insensitive).
func (o NrqlAlertConditionOutput) BaselineDirection() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.StringPtrOutput { return v.BaselineDirection }).(pulumi.StringPtrOutput)
}

// Whether to close all open incidents when the signal expires.
func (o NrqlAlertConditionOutput) CloseViolationsOnExpiration() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.BoolPtrOutput { return v.CloseViolationsOnExpiration }).(pulumi.BoolPtrOutput)
}

// A list containing the `critical` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
func (o NrqlAlertConditionOutput) Critical() NrqlAlertConditionCriticalPtrOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) NrqlAlertConditionCriticalPtrOutput { return v.Critical }).(NrqlAlertConditionCriticalPtrOutput)
}

// The description of the NRQL alert condition.
func (o NrqlAlertConditionOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Whether to enable the alert condition. Valid values are `true` and `false`. Defaults to `true`.
func (o NrqlAlertConditionOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.BoolPtrOutput { return v.Enabled }).(pulumi.BoolPtrOutput)
}

// The unique entity identifier of the NRQL Condition in New Relic.
func (o NrqlAlertConditionOutput) EntityGuid() pulumi.StringOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.StringOutput { return v.EntityGuid }).(pulumi.StringOutput)
}

// How long we wait until the signal starts evaluating. The maximum delay is 7200 seconds (120 minutes).
func (o NrqlAlertConditionOutput) EvaluationDelay() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.IntPtrOutput { return v.EvaluationDelay }).(pulumi.IntPtrOutput)
}

// The amount of time (in seconds) to wait before considering the signal expired. The value must be at least 30 seconds, and no more than 172800 seconds (48 hours).
func (o NrqlAlertConditionOutput) ExpirationDuration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.IntPtrOutput { return v.ExpirationDuration }).(pulumi.IntPtrOutput)
}

// Which strategy to use when filling gaps in the signal. Possible values are `none`, `lastValue` or `static`. If `static`, the `fillValue` field will be used for filling gaps in the signal.
func (o NrqlAlertConditionOutput) FillOption() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.StringPtrOutput { return v.FillOption }).(pulumi.StringPtrOutput)
}

// This value will be used for filling gaps in the signal.
func (o NrqlAlertConditionOutput) FillValue() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.Float64PtrOutput { return v.FillValue }).(pulumi.Float64PtrOutput)
}

// Whether an alert condition should ignore expected termination of a signal when considering whether to create a loss of signal incident. Defaults to false.
func (o NrqlAlertConditionOutput) IgnoreOnExpectedTermination() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.BoolPtrOutput { return v.IgnoreOnExpectedTermination }).(pulumi.BoolPtrOutput)
}

// The title of the condition.
func (o NrqlAlertConditionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// A NRQL query. See NRQL below for details.
func (o NrqlAlertConditionOutput) Nrql() NrqlAlertConditionNrqlOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) NrqlAlertConditionNrqlOutput { return v.Nrql }).(NrqlAlertConditionNrqlOutput)
}

// Whether to create a new incident to capture that the signal expired.
func (o NrqlAlertConditionOutput) OpenViolationOnExpiration() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.BoolPtrOutput { return v.OpenViolationOnExpiration }).(pulumi.BoolPtrOutput)
}

// The ID of the policy where this condition should be used.
func (o NrqlAlertConditionOutput) PolicyId() pulumi.StringOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.StringOutput { return v.PolicyId }).(pulumi.StringOutput)
}

// Runbook URL to display in notifications.
func (o NrqlAlertConditionOutput) RunbookUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.StringPtrOutput { return v.RunbookUrl }).(pulumi.StringPtrOutput)
}

// Seasonality under which a condition's signal(s) are evaluated. Only available for baseline conditions. Valid values are: `NEW_RELIC_CALCULATION`, `HOURLY`, `DAILY`, `WEEKLY`, or `NONE`. To have New Relic calculate seasonality automatically, set to `NEW_RELIC_CALCULATION`. To turn off seasonality completely, set to `NONE`.
func (o NrqlAlertConditionOutput) SignalSeasonality() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.StringPtrOutput { return v.SignalSeasonality }).(pulumi.StringPtrOutput)
}

// Gathers data in overlapping time windows to smooth the chart line, making it easier to spot trends. The `slideBy` value is specified in seconds and must be smaller than and a factor of the `aggregationWindow`.
func (o NrqlAlertConditionOutput) SlideBy() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.IntPtrOutput { return v.SlideBy }).(pulumi.IntPtrOutput)
}

// BETA PREVIEW: The GUID of the entity explicitly targeted by the condition. Issues triggered by this condition will affect the health status of this entity instead of having the affected entity detected automatically. The entity's account ID must be either `accountId` or `nrql.data_account_id`.
func (o NrqlAlertConditionOutput) TargetEntity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.StringPtrOutput { return v.TargetEntity }).(pulumi.StringPtrOutput)
}

// **DEPRECATED** Use `critical`, and `warning` instead. A list of terms for this condition. See Terms below for details.
//
// Deprecated: use `critical` and `warning` attributes instead
func (o NrqlAlertConditionOutput) Terms() NrqlAlertConditionTermArrayOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) NrqlAlertConditionTermArrayOutput { return v.Terms }).(NrqlAlertConditionTermArrayOutput)
}

// The custom title to be used when incidents are opened by the condition. Setting this field will override the default title. Must be [Handlebars](https://handlebarsjs.com/) format.
func (o NrqlAlertConditionOutput) TitleTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.StringPtrOutput { return v.TitleTemplate }).(pulumi.StringPtrOutput)
}

// The type of the condition. Valid values are `static` or `baseline`. Defaults to `static`.
func (o NrqlAlertConditionOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.StringPtrOutput { return v.Type }).(pulumi.StringPtrOutput)
}

// **DEPRECATED:** Use `violationTimeLimitSeconds` instead. Sets a time limit, in hours, that will automatically force-close a long-lasting incident after the time limit you select. Possible values are `ONE_HOUR`, `TWO_HOURS`, `FOUR_HOURS`, `EIGHT_HOURS`, `TWELVE_HOURS`, `TWENTY_FOUR_HOURS`, `THIRTY_DAYS` (case insensitive).<br>
// <small>\***Note**: One of `violationTimeLimit` _or_ `violationTimeLimitSeconds` must be set, but not both.</small>
//
// Deprecated: use `violationTimeLimitSeconds` attribute instead
func (o NrqlAlertConditionOutput) ViolationTimeLimit() pulumi.StringOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.StringOutput { return v.ViolationTimeLimit }).(pulumi.StringOutput)
}

// Sets a time limit, in seconds, that will automatically force-close a long-lasting incident after the time limit you select. The value must be between 300 seconds (5 minutes) to 2592000 seconds (30 days) (inclusive). <br>
// <small>\***Note**: One of `violationTimeLimit` _or_ `violationTimeLimitSeconds` must be set, but not both.</small>
func (o NrqlAlertConditionOutput) ViolationTimeLimitSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) pulumi.IntPtrOutput { return v.ViolationTimeLimitSeconds }).(pulumi.IntPtrOutput)
}

// A list containing the `warning` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
func (o NrqlAlertConditionOutput) Warning() NrqlAlertConditionWarningPtrOutput {
	return o.ApplyT(func(v *NrqlAlertCondition) NrqlAlertConditionWarningPtrOutput { return v.Warning }).(NrqlAlertConditionWarningPtrOutput)
}

type NrqlAlertConditionArrayOutput struct{ *pulumi.OutputState }

func (NrqlAlertConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NrqlAlertCondition)(nil)).Elem()
}

func (o NrqlAlertConditionArrayOutput) ToNrqlAlertConditionArrayOutput() NrqlAlertConditionArrayOutput {
	return o
}

func (o NrqlAlertConditionArrayOutput) ToNrqlAlertConditionArrayOutputWithContext(ctx context.Context) NrqlAlertConditionArrayOutput {
	return o
}

func (o NrqlAlertConditionArrayOutput) Index(i pulumi.IntInput) NrqlAlertConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *NrqlAlertCondition {
		return vs[0].([]*NrqlAlertCondition)[vs[1].(int)]
	}).(NrqlAlertConditionOutput)
}

type NrqlAlertConditionMapOutput struct{ *pulumi.OutputState }

func (NrqlAlertConditionMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NrqlAlertCondition)(nil)).Elem()
}

func (o NrqlAlertConditionMapOutput) ToNrqlAlertConditionMapOutput() NrqlAlertConditionMapOutput {
	return o
}

func (o NrqlAlertConditionMapOutput) ToNrqlAlertConditionMapOutputWithContext(ctx context.Context) NrqlAlertConditionMapOutput {
	return o
}

func (o NrqlAlertConditionMapOutput) MapIndex(k pulumi.StringInput) NrqlAlertConditionOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *NrqlAlertCondition {
		return vs[0].(map[string]*NrqlAlertCondition)[vs[1].(string)]
	}).(NrqlAlertConditionOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*NrqlAlertConditionInput)(nil)).Elem(), &NrqlAlertCondition{})
	pulumi.RegisterInputType(reflect.TypeOf((*NrqlAlertConditionArrayInput)(nil)).Elem(), NrqlAlertConditionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NrqlAlertConditionMapInput)(nil)).Elem(), NrqlAlertConditionMap{})
	pulumi.RegisterOutputType(NrqlAlertConditionOutput{})
	pulumi.RegisterOutputType(NrqlAlertConditionArrayOutput{})
	pulumi.RegisterOutputType(NrqlAlertConditionMapOutput{})
}
