// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package newrelic

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Use this resource to create and manage compound alert conditions in New Relic. Compound conditions allow you to combine multiple alert conditions using logical expressions (AND, OR, NOT) to create more sophisticated alerting logic.
//
// ## Example Usage
//
// ### Basic Compound Condition (AND)
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			example, err := newrelic.NewAlertPolicy(ctx, "example", &newrelic.AlertPolicyArgs{
//				Name: pulumi.String("my-policy"),
//			})
//			if err != nil {
//				return err
//			}
//			// Create component NRQL conditions
//			highResponseTime, err := newrelic.NewNrqlAlertCondition(ctx, "high_response_time", &newrelic.NrqlAlertConditionArgs{
//				PolicyId: example.ID(),
//				Name:     pulumi.String("High Response Time"),
//				Enabled:  pulumi.Bool(true),
//				Nrql: &newrelic.NrqlAlertConditionNrqlArgs{
//					Query: pulumi.String("SELECT average(duration) FROM Transaction WHERE appName = 'MyApp'"),
//				},
//				Critical: &newrelic.NrqlAlertConditionCriticalArgs{
//					Operator:             pulumi.String("above"),
//					Threshold:            pulumi.Float64(5),
//					ThresholdDuration:    pulumi.Int(300),
//					ThresholdOccurrences: pulumi.String("all"),
//				},
//				ViolationTimeLimitSeconds: pulumi.Int(3600),
//			})
//			if err != nil {
//				return err
//			}
//			highErrorRate, err := newrelic.NewNrqlAlertCondition(ctx, "high_error_rate", &newrelic.NrqlAlertConditionArgs{
//				PolicyId: example.ID(),
//				Name:     pulumi.String("High Error Rate"),
//				Enabled:  pulumi.Bool(true),
//				Nrql: &newrelic.NrqlAlertConditionNrqlArgs{
//					Query: pulumi.String("SELECT percentage(count(*), WHERE error IS true) FROM Transaction WHERE appName = 'MyApp'"),
//				},
//				Critical: &newrelic.NrqlAlertConditionCriticalArgs{
//					Operator:             pulumi.String("above"),
//					Threshold:            pulumi.Float64(5),
//					ThresholdDuration:    pulumi.Int(300),
//					ThresholdOccurrences: pulumi.String("all"),
//				},
//				ViolationTimeLimitSeconds: pulumi.Int(3600),
//			})
//			if err != nil {
//				return err
//			}
//			// Create alert compound condition combining both
//			_, err = newrelic.NewAlertCompoundCondition(ctx, "critical_service_health", &newrelic.AlertCompoundConditionArgs{
//				PolicyId:          example.ID(),
//				Name:              pulumi.String("Critical Service Health"),
//				Enabled:           pulumi.Bool(true),
//				TriggerExpression: pulumi.String("A AND B"),
//				RunbookUrl:        pulumi.String("https://example.com/runbooks/critical-health"),
//				ThresholdDuration: pulumi.Int(120),
//				ComponentConditions: newrelic.AlertCompoundConditionComponentConditionArray{
//					&newrelic.AlertCompoundConditionComponentConditionArgs{
//						Id:    highResponseTime.ID(),
//						Alias: pulumi.String("A"),
//					},
//					&newrelic.AlertCompoundConditionComponentConditionArgs{
//						Id:    highErrorRate.ID(),
//						Alias: pulumi.String("B"),
//					},
//				},
//				FacetMatchingBehavior: pulumi.String("FACETS_IGNORED"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Complex Condition with Three Components
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			highCpu, err := newrelic.NewNrqlAlertCondition(ctx, "high_cpu", &newrelic.NrqlAlertConditionArgs{
//				PolicyId: pulumi.Any(example.Id),
//				Name:     pulumi.String("High CPU"),
//				Enabled:  pulumi.Bool(true),
//				Nrql: &newrelic.NrqlAlertConditionNrqlArgs{
//					Query: pulumi.String("SELECT average(cpuPercent) FROM SystemSample WHERE hostname = 'myhost'"),
//				},
//				Critical: &newrelic.NrqlAlertConditionCriticalArgs{
//					Operator:             pulumi.String("above"),
//					Threshold:            pulumi.Float64(80),
//					ThresholdDuration:    pulumi.Int(300),
//					ThresholdOccurrences: pulumi.String("all"),
//				},
//				ViolationTimeLimitSeconds: pulumi.Int(3600),
//			})
//			if err != nil {
//				return err
//			}
//			highMemory, err := newrelic.NewNrqlAlertCondition(ctx, "high_memory", &newrelic.NrqlAlertConditionArgs{
//				PolicyId: pulumi.Any(example.Id),
//				Name:     pulumi.String("High Memory"),
//				Enabled:  pulumi.Bool(true),
//				Nrql: &newrelic.NrqlAlertConditionNrqlArgs{
//					Query: pulumi.String("SELECT average(memoryUsedPercent) FROM SystemSample WHERE hostname = 'myhost'"),
//				},
//				Critical: &newrelic.NrqlAlertConditionCriticalArgs{
//					Operator:             pulumi.String("above"),
//					Threshold:            pulumi.Float64(85),
//					ThresholdDuration:    pulumi.Int(300),
//					ThresholdOccurrences: pulumi.String("all"),
//				},
//				ViolationTimeLimitSeconds: pulumi.Int(3600),
//			})
//			if err != nil {
//				return err
//			}
//			diskFull, err := newrelic.NewNrqlAlertCondition(ctx, "disk_full", &newrelic.NrqlAlertConditionArgs{
//				PolicyId: pulumi.Any(example.Id),
//				Name:     pulumi.String("Disk Full"),
//				Enabled:  pulumi.Bool(true),
//				Nrql: &newrelic.NrqlAlertConditionNrqlArgs{
//					Query: pulumi.String("SELECT average(diskUsedPercent) FROM SystemSample WHERE hostname = 'myhost'"),
//				},
//				Critical: &newrelic.NrqlAlertConditionCriticalArgs{
//					Operator:             pulumi.String("above"),
//					Threshold:            pulumi.Float64(90),
//					ThresholdDuration:    pulumi.Int(300),
//					ThresholdOccurrences: pulumi.String("all"),
//				},
//				ViolationTimeLimitSeconds: pulumi.Int(3600),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = newrelic.NewAlertCompoundCondition(ctx, "complex", &newrelic.AlertCompoundConditionArgs{
//				PolicyId:          pulumi.Any(example.Id),
//				Name:              pulumi.String("Complex Infrastructure Alert"),
//				Enabled:           pulumi.Bool(true),
//				TriggerExpression: pulumi.String("(A AND B) OR C"),
//				ComponentConditions: newrelic.AlertCompoundConditionComponentConditionArray{
//					&newrelic.AlertCompoundConditionComponentConditionArgs{
//						Id:    highCpu.ID(),
//						Alias: pulumi.String("A"),
//					},
//					&newrelic.AlertCompoundConditionComponentConditionArgs{
//						Id:    highMemory.ID(),
//						Alias: pulumi.String("B"),
//					},
//					&newrelic.AlertCompoundConditionComponentConditionArgs{
//						Id:    diskFull.ID(),
//						Alias: pulumi.String("C"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### With Facet Matching
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-newrelic/sdk/v5/go/newrelic"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			highThroughputPerHost, err := newrelic.NewNrqlAlertCondition(ctx, "high_throughput_per_host", &newrelic.NrqlAlertConditionArgs{
//				PolicyId: pulumi.Any(example.Id),
//				Name:     pulumi.String("High Throughput Per Host"),
//				Enabled:  pulumi.Bool(true),
//				Nrql: &newrelic.NrqlAlertConditionNrqlArgs{
//					Query: pulumi.String("SELECT rate(count(*), 1 minute) FROM Transaction FACET host"),
//				},
//				Critical: &newrelic.NrqlAlertConditionCriticalArgs{
//					Operator:             pulumi.String("above"),
//					Threshold:            pulumi.Float64(1000),
//					ThresholdDuration:    pulumi.Int(300),
//					ThresholdOccurrences: pulumi.String("all"),
//				},
//				ViolationTimeLimitSeconds: pulumi.Int(3600),
//			})
//			if err != nil {
//				return err
//			}
//			highErrorRatePerHost, err := newrelic.NewNrqlAlertCondition(ctx, "high_error_rate_per_host", &newrelic.NrqlAlertConditionArgs{
//				PolicyId: pulumi.Any(example.Id),
//				Name:     pulumi.String("High Error Rate Per Host"),
//				Enabled:  pulumi.Bool(true),
//				Nrql: &newrelic.NrqlAlertConditionNrqlArgs{
//					Query: pulumi.String("SELECT percentage(count(*), WHERE error IS true) FROM Transaction FACET host"),
//				},
//				Critical: &newrelic.NrqlAlertConditionCriticalArgs{
//					Operator:             pulumi.String("above"),
//					Threshold:            pulumi.Float64(5),
//					ThresholdDuration:    pulumi.Int(300),
//					ThresholdOccurrences: pulumi.String("all"),
//				},
//				ViolationTimeLimitSeconds: pulumi.Int(3600),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = newrelic.NewAlertCompoundCondition(ctx, "with_facets", &newrelic.AlertCompoundConditionArgs{
//				PolicyId:              pulumi.Any(example.Id),
//				Name:                  pulumi.String("Host-Specific Alert"),
//				Enabled:               pulumi.Bool(true),
//				TriggerExpression:     pulumi.String("A AND B"),
//				FacetMatchingBehavior: pulumi.String("FACETS_MATCH"),
//				ComponentConditions: newrelic.AlertCompoundConditionComponentConditionArray{
//					&newrelic.AlertCompoundConditionComponentConditionArgs{
//						Id:    highThroughputPerHost.ID(),
//						Alias: pulumi.String("A"),
//					},
//					&newrelic.AlertCompoundConditionComponentConditionArgs{
//						Id:    highErrorRatePerHost.ID(),
//						Alias: pulumi.String("B"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Additional Information
//
// ### Understanding Trigger Expressions
//
// Trigger expressions define the logical conditions under which your alert compound condition will activate. Valid operators are:
//
// - **AND** - Both conditions must be true
// - **OR** - Either condition must be true
// - **NOT** - Negates a condition
// - **Parentheses** - Group conditions for complex logic
//
// Examples:
//
// - `"A AND B"` - Activate when both A and B are in violation
// - `"A OR B"` - Activate when either A or B is in violation
// - `"A AND NOT B"` - Activate when A is in violation but B is not
// - `"(A AND B) OR C"` - Activate when both A and B are in violation, OR when C is in violation
// - `"A AND (B OR C) AND NOT D"` - Activate when A is in violation AND either B or C is in violation AND D is not in violation
//
// ### Facet Matching Behavior
//
// When your component NRQL conditions use FACET clauses:
//
// - **FACETS_IGNORED** (Default) - Facets are not taken into consideration when determining when the compound alert condition activates. If component conditions have violations (on any facet), the compound alert condition will activate based on the trigger expression.
// - **FACETS_MATCH** - The compound alert condition will activate only when shared facets have matching values. For example, if condition A fires for `host="server-1"` and condition B fires for `host="server-2"`, the compound alert condition will NOT activate because the facet values don't match.
//
// ### Threshold Duration
//
// The `thresholdDuration` parameter controls how long the trigger expression must remain true before the compound alert condition will activate.
//
// ## Import
//
// Compound alert conditions can be imported using the condition ID, e.g.
//
// ```sh
// $ pulumi import newrelic:index/alertCompoundCondition:AlertCompoundCondition main 789012
// ```
type AlertCompoundCondition struct {
	pulumi.CustomResourceState

	// The New Relic account ID for managing your compound alert conditions. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
	AccountId pulumi.StringOutput `pulumi:"accountId"`
	// The list of conditions to be combined. Each component condition must be enabled. Must include at least 2. See Component Conditions below for details.
	ComponentConditions AlertCompoundConditionComponentConditionArrayOutput `pulumi:"componentConditions"`
	// Whether or not the compound alert condition is enabled. Defaults to `true`.
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// How the compound condition will take into account the component conditions' facets during evaluation. Valid values are:
	// - `FACETS_IGNORED` - (Default) Facets are not taken into consideration when determining when the compound alert condition activates
	// - `FACETS_MATCH` - The compound alert condition will activate only when shared facets have matching values
	FacetMatchingBehavior pulumi.StringOutput `pulumi:"facetMatchingBehavior"`
	// The title of the compound alert condition.
	Name pulumi.StringOutput `pulumi:"name"`
	// The ID of the policy where this alert compound condition should be used.
	PolicyId pulumi.StringOutput `pulumi:"policyId"`
	// Runbook URL to display in notifications.
	RunbookUrl pulumi.StringPtrOutput `pulumi:"runbookUrl"`
	// The duration, in seconds, that the trigger expression must be true before the compound alert condition will activate. Between 30-86400 seconds.
	ThresholdDuration pulumi.IntOutput `pulumi:"thresholdDuration"`
	// Expression that defines how component condition evaluations are combined. Valid operators are 'AND', 'OR', 'NOT'. For more complex expressions, use parentheses. Use the aliases from `componentConditions` to build expressions like `"A AND B"`, `"A OR B"`, `"(A AND B) OR C"`, or `"A AND (B OR C) AND NOT (D AND E)"`.
	TriggerExpression pulumi.StringOutput `pulumi:"triggerExpression"`
}

// NewAlertCompoundCondition registers a new resource with the given unique name, arguments, and options.
func NewAlertCompoundCondition(ctx *pulumi.Context,
	name string, args *AlertCompoundConditionArgs, opts ...pulumi.ResourceOption) (*AlertCompoundCondition, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ComponentConditions == nil {
		return nil, errors.New("invalid value for required argument 'ComponentConditions'")
	}
	if args.Enabled == nil {
		return nil, errors.New("invalid value for required argument 'Enabled'")
	}
	if args.PolicyId == nil {
		return nil, errors.New("invalid value for required argument 'PolicyId'")
	}
	if args.TriggerExpression == nil {
		return nil, errors.New("invalid value for required argument 'TriggerExpression'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource AlertCompoundCondition
	err := ctx.RegisterResource("newrelic:index/alertCompoundCondition:AlertCompoundCondition", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAlertCompoundCondition gets an existing AlertCompoundCondition resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAlertCompoundCondition(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AlertCompoundConditionState, opts ...pulumi.ResourceOption) (*AlertCompoundCondition, error) {
	var resource AlertCompoundCondition
	err := ctx.ReadResource("newrelic:index/alertCompoundCondition:AlertCompoundCondition", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AlertCompoundCondition resources.
type alertCompoundConditionState struct {
	// The New Relic account ID for managing your compound alert conditions. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
	AccountId *string `pulumi:"accountId"`
	// The list of conditions to be combined. Each component condition must be enabled. Must include at least 2. See Component Conditions below for details.
	ComponentConditions []AlertCompoundConditionComponentCondition `pulumi:"componentConditions"`
	// Whether or not the compound alert condition is enabled. Defaults to `true`.
	Enabled *bool `pulumi:"enabled"`
	// How the compound condition will take into account the component conditions' facets during evaluation. Valid values are:
	// - `FACETS_IGNORED` - (Default) Facets are not taken into consideration when determining when the compound alert condition activates
	// - `FACETS_MATCH` - The compound alert condition will activate only when shared facets have matching values
	FacetMatchingBehavior *string `pulumi:"facetMatchingBehavior"`
	// The title of the compound alert condition.
	Name *string `pulumi:"name"`
	// The ID of the policy where this alert compound condition should be used.
	PolicyId *string `pulumi:"policyId"`
	// Runbook URL to display in notifications.
	RunbookUrl *string `pulumi:"runbookUrl"`
	// The duration, in seconds, that the trigger expression must be true before the compound alert condition will activate. Between 30-86400 seconds.
	ThresholdDuration *int `pulumi:"thresholdDuration"`
	// Expression that defines how component condition evaluations are combined. Valid operators are 'AND', 'OR', 'NOT'. For more complex expressions, use parentheses. Use the aliases from `componentConditions` to build expressions like `"A AND B"`, `"A OR B"`, `"(A AND B) OR C"`, or `"A AND (B OR C) AND NOT (D AND E)"`.
	TriggerExpression *string `pulumi:"triggerExpression"`
}

type AlertCompoundConditionState struct {
	// The New Relic account ID for managing your compound alert conditions. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
	AccountId pulumi.StringPtrInput
	// The list of conditions to be combined. Each component condition must be enabled. Must include at least 2. See Component Conditions below for details.
	ComponentConditions AlertCompoundConditionComponentConditionArrayInput
	// Whether or not the compound alert condition is enabled. Defaults to `true`.
	Enabled pulumi.BoolPtrInput
	// How the compound condition will take into account the component conditions' facets during evaluation. Valid values are:
	// - `FACETS_IGNORED` - (Default) Facets are not taken into consideration when determining when the compound alert condition activates
	// - `FACETS_MATCH` - The compound alert condition will activate only when shared facets have matching values
	FacetMatchingBehavior pulumi.StringPtrInput
	// The title of the compound alert condition.
	Name pulumi.StringPtrInput
	// The ID of the policy where this alert compound condition should be used.
	PolicyId pulumi.StringPtrInput
	// Runbook URL to display in notifications.
	RunbookUrl pulumi.StringPtrInput
	// The duration, in seconds, that the trigger expression must be true before the compound alert condition will activate. Between 30-86400 seconds.
	ThresholdDuration pulumi.IntPtrInput
	// Expression that defines how component condition evaluations are combined. Valid operators are 'AND', 'OR', 'NOT'. For more complex expressions, use parentheses. Use the aliases from `componentConditions` to build expressions like `"A AND B"`, `"A OR B"`, `"(A AND B) OR C"`, or `"A AND (B OR C) AND NOT (D AND E)"`.
	TriggerExpression pulumi.StringPtrInput
}

func (AlertCompoundConditionState) ElementType() reflect.Type {
	return reflect.TypeOf((*alertCompoundConditionState)(nil)).Elem()
}

type alertCompoundConditionArgs struct {
	// The New Relic account ID for managing your compound alert conditions. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
	AccountId *string `pulumi:"accountId"`
	// The list of conditions to be combined. Each component condition must be enabled. Must include at least 2. See Component Conditions below for details.
	ComponentConditions []AlertCompoundConditionComponentCondition `pulumi:"componentConditions"`
	// Whether or not the compound alert condition is enabled. Defaults to `true`.
	Enabled bool `pulumi:"enabled"`
	// How the compound condition will take into account the component conditions' facets during evaluation. Valid values are:
	// - `FACETS_IGNORED` - (Default) Facets are not taken into consideration when determining when the compound alert condition activates
	// - `FACETS_MATCH` - The compound alert condition will activate only when shared facets have matching values
	FacetMatchingBehavior *string `pulumi:"facetMatchingBehavior"`
	// The title of the compound alert condition.
	Name *string `pulumi:"name"`
	// The ID of the policy where this alert compound condition should be used.
	PolicyId string `pulumi:"policyId"`
	// Runbook URL to display in notifications.
	RunbookUrl *string `pulumi:"runbookUrl"`
	// The duration, in seconds, that the trigger expression must be true before the compound alert condition will activate. Between 30-86400 seconds.
	ThresholdDuration *int `pulumi:"thresholdDuration"`
	// Expression that defines how component condition evaluations are combined. Valid operators are 'AND', 'OR', 'NOT'. For more complex expressions, use parentheses. Use the aliases from `componentConditions` to build expressions like `"A AND B"`, `"A OR B"`, `"(A AND B) OR C"`, or `"A AND (B OR C) AND NOT (D AND E)"`.
	TriggerExpression string `pulumi:"triggerExpression"`
}

// The set of arguments for constructing a AlertCompoundCondition resource.
type AlertCompoundConditionArgs struct {
	// The New Relic account ID for managing your compound alert conditions. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
	AccountId pulumi.StringPtrInput
	// The list of conditions to be combined. Each component condition must be enabled. Must include at least 2. See Component Conditions below for details.
	ComponentConditions AlertCompoundConditionComponentConditionArrayInput
	// Whether or not the compound alert condition is enabled. Defaults to `true`.
	Enabled pulumi.BoolInput
	// How the compound condition will take into account the component conditions' facets during evaluation. Valid values are:
	// - `FACETS_IGNORED` - (Default) Facets are not taken into consideration when determining when the compound alert condition activates
	// - `FACETS_MATCH` - The compound alert condition will activate only when shared facets have matching values
	FacetMatchingBehavior pulumi.StringPtrInput
	// The title of the compound alert condition.
	Name pulumi.StringPtrInput
	// The ID of the policy where this alert compound condition should be used.
	PolicyId pulumi.StringInput
	// Runbook URL to display in notifications.
	RunbookUrl pulumi.StringPtrInput
	// The duration, in seconds, that the trigger expression must be true before the compound alert condition will activate. Between 30-86400 seconds.
	ThresholdDuration pulumi.IntPtrInput
	// Expression that defines how component condition evaluations are combined. Valid operators are 'AND', 'OR', 'NOT'. For more complex expressions, use parentheses. Use the aliases from `componentConditions` to build expressions like `"A AND B"`, `"A OR B"`, `"(A AND B) OR C"`, or `"A AND (B OR C) AND NOT (D AND E)"`.
	TriggerExpression pulumi.StringInput
}

func (AlertCompoundConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*alertCompoundConditionArgs)(nil)).Elem()
}

type AlertCompoundConditionInput interface {
	pulumi.Input

	ToAlertCompoundConditionOutput() AlertCompoundConditionOutput
	ToAlertCompoundConditionOutputWithContext(ctx context.Context) AlertCompoundConditionOutput
}

func (*AlertCompoundCondition) ElementType() reflect.Type {
	return reflect.TypeOf((**AlertCompoundCondition)(nil)).Elem()
}

func (i *AlertCompoundCondition) ToAlertCompoundConditionOutput() AlertCompoundConditionOutput {
	return i.ToAlertCompoundConditionOutputWithContext(context.Background())
}

func (i *AlertCompoundCondition) ToAlertCompoundConditionOutputWithContext(ctx context.Context) AlertCompoundConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertCompoundConditionOutput)
}

// AlertCompoundConditionArrayInput is an input type that accepts AlertCompoundConditionArray and AlertCompoundConditionArrayOutput values.
// You can construct a concrete instance of `AlertCompoundConditionArrayInput` via:
//
//	AlertCompoundConditionArray{ AlertCompoundConditionArgs{...} }
type AlertCompoundConditionArrayInput interface {
	pulumi.Input

	ToAlertCompoundConditionArrayOutput() AlertCompoundConditionArrayOutput
	ToAlertCompoundConditionArrayOutputWithContext(context.Context) AlertCompoundConditionArrayOutput
}

type AlertCompoundConditionArray []AlertCompoundConditionInput

func (AlertCompoundConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AlertCompoundCondition)(nil)).Elem()
}

func (i AlertCompoundConditionArray) ToAlertCompoundConditionArrayOutput() AlertCompoundConditionArrayOutput {
	return i.ToAlertCompoundConditionArrayOutputWithContext(context.Background())
}

func (i AlertCompoundConditionArray) ToAlertCompoundConditionArrayOutputWithContext(ctx context.Context) AlertCompoundConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertCompoundConditionArrayOutput)
}

// AlertCompoundConditionMapInput is an input type that accepts AlertCompoundConditionMap and AlertCompoundConditionMapOutput values.
// You can construct a concrete instance of `AlertCompoundConditionMapInput` via:
//
//	AlertCompoundConditionMap{ "key": AlertCompoundConditionArgs{...} }
type AlertCompoundConditionMapInput interface {
	pulumi.Input

	ToAlertCompoundConditionMapOutput() AlertCompoundConditionMapOutput
	ToAlertCompoundConditionMapOutputWithContext(context.Context) AlertCompoundConditionMapOutput
}

type AlertCompoundConditionMap map[string]AlertCompoundConditionInput

func (AlertCompoundConditionMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AlertCompoundCondition)(nil)).Elem()
}

func (i AlertCompoundConditionMap) ToAlertCompoundConditionMapOutput() AlertCompoundConditionMapOutput {
	return i.ToAlertCompoundConditionMapOutputWithContext(context.Background())
}

func (i AlertCompoundConditionMap) ToAlertCompoundConditionMapOutputWithContext(ctx context.Context) AlertCompoundConditionMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertCompoundConditionMapOutput)
}

type AlertCompoundConditionOutput struct{ *pulumi.OutputState }

func (AlertCompoundConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AlertCompoundCondition)(nil)).Elem()
}

func (o AlertCompoundConditionOutput) ToAlertCompoundConditionOutput() AlertCompoundConditionOutput {
	return o
}

func (o AlertCompoundConditionOutput) ToAlertCompoundConditionOutputWithContext(ctx context.Context) AlertCompoundConditionOutput {
	return o
}

// The New Relic account ID for managing your compound alert conditions. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
func (o AlertCompoundConditionOutput) AccountId() pulumi.StringOutput {
	return o.ApplyT(func(v *AlertCompoundCondition) pulumi.StringOutput { return v.AccountId }).(pulumi.StringOutput)
}

// The list of conditions to be combined. Each component condition must be enabled. Must include at least 2. See Component Conditions below for details.
func (o AlertCompoundConditionOutput) ComponentConditions() AlertCompoundConditionComponentConditionArrayOutput {
	return o.ApplyT(func(v *AlertCompoundCondition) AlertCompoundConditionComponentConditionArrayOutput {
		return v.ComponentConditions
	}).(AlertCompoundConditionComponentConditionArrayOutput)
}

// Whether or not the compound alert condition is enabled. Defaults to `true`.
func (o AlertCompoundConditionOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *AlertCompoundCondition) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// How the compound condition will take into account the component conditions' facets during evaluation. Valid values are:
// - `FACETS_IGNORED` - (Default) Facets are not taken into consideration when determining when the compound alert condition activates
// - `FACETS_MATCH` - The compound alert condition will activate only when shared facets have matching values
func (o AlertCompoundConditionOutput) FacetMatchingBehavior() pulumi.StringOutput {
	return o.ApplyT(func(v *AlertCompoundCondition) pulumi.StringOutput { return v.FacetMatchingBehavior }).(pulumi.StringOutput)
}

// The title of the compound alert condition.
func (o AlertCompoundConditionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *AlertCompoundCondition) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The ID of the policy where this alert compound condition should be used.
func (o AlertCompoundConditionOutput) PolicyId() pulumi.StringOutput {
	return o.ApplyT(func(v *AlertCompoundCondition) pulumi.StringOutput { return v.PolicyId }).(pulumi.StringOutput)
}

// Runbook URL to display in notifications.
func (o AlertCompoundConditionOutput) RunbookUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AlertCompoundCondition) pulumi.StringPtrOutput { return v.RunbookUrl }).(pulumi.StringPtrOutput)
}

// The duration, in seconds, that the trigger expression must be true before the compound alert condition will activate. Between 30-86400 seconds.
func (o AlertCompoundConditionOutput) ThresholdDuration() pulumi.IntOutput {
	return o.ApplyT(func(v *AlertCompoundCondition) pulumi.IntOutput { return v.ThresholdDuration }).(pulumi.IntOutput)
}

// Expression that defines how component condition evaluations are combined. Valid operators are 'AND', 'OR', 'NOT'. For more complex expressions, use parentheses. Use the aliases from `componentConditions` to build expressions like `"A AND B"`, `"A OR B"`, `"(A AND B) OR C"`, or `"A AND (B OR C) AND NOT (D AND E)"`.
func (o AlertCompoundConditionOutput) TriggerExpression() pulumi.StringOutput {
	return o.ApplyT(func(v *AlertCompoundCondition) pulumi.StringOutput { return v.TriggerExpression }).(pulumi.StringOutput)
}

type AlertCompoundConditionArrayOutput struct{ *pulumi.OutputState }

func (AlertCompoundConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AlertCompoundCondition)(nil)).Elem()
}

func (o AlertCompoundConditionArrayOutput) ToAlertCompoundConditionArrayOutput() AlertCompoundConditionArrayOutput {
	return o
}

func (o AlertCompoundConditionArrayOutput) ToAlertCompoundConditionArrayOutputWithContext(ctx context.Context) AlertCompoundConditionArrayOutput {
	return o
}

func (o AlertCompoundConditionArrayOutput) Index(i pulumi.IntInput) AlertCompoundConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AlertCompoundCondition {
		return vs[0].([]*AlertCompoundCondition)[vs[1].(int)]
	}).(AlertCompoundConditionOutput)
}

type AlertCompoundConditionMapOutput struct{ *pulumi.OutputState }

func (AlertCompoundConditionMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AlertCompoundCondition)(nil)).Elem()
}

func (o AlertCompoundConditionMapOutput) ToAlertCompoundConditionMapOutput() AlertCompoundConditionMapOutput {
	return o
}

func (o AlertCompoundConditionMapOutput) ToAlertCompoundConditionMapOutputWithContext(ctx context.Context) AlertCompoundConditionMapOutput {
	return o
}

func (o AlertCompoundConditionMapOutput) MapIndex(k pulumi.StringInput) AlertCompoundConditionOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AlertCompoundCondition {
		return vs[0].(map[string]*AlertCompoundCondition)[vs[1].(string)]
	}).(AlertCompoundConditionOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AlertCompoundConditionInput)(nil)).Elem(), &AlertCompoundCondition{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlertCompoundConditionArrayInput)(nil)).Elem(), AlertCompoundConditionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlertCompoundConditionMapInput)(nil)).Elem(), AlertCompoundConditionMap{})
	pulumi.RegisterOutputType(AlertCompoundConditionOutput{})
	pulumi.RegisterOutputType(AlertCompoundConditionArrayOutput{})
	pulumi.RegisterOutputType(AlertCompoundConditionMapOutput{})
}
