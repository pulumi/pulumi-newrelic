// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.NewRelic
{
    /// <summary>
    /// Use this resource to create, update, and delete [Monitor Downtimes](https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/) in New Relic.
    /// 
    /// ## Example Usage
    /// 
    /// &lt;!--Start PulumiCodeChooser --&gt;
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using NewRelic = Pulumi.NewRelic;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var foo = new NewRelic.MonitorDowntime("foo", new()
    ///     {
    ///         EndRepeat = new NewRelic.Inputs.MonitorDowntimeEndRepeatArgs
    ///         {
    ///             OnDate = "2023-12-20",
    ///         },
    ///         EndTime = "2023-12-10T02:45:30",
    ///         MaintenanceDays = new[]
    ///         {
    ///             "FRIDAY",
    ///             "SATURDAY",
    ///         },
    ///         Mode = "WEEKLY",
    ///         MonitorGuids = new[]
    ///         {
    ///             "&lt;GUID-1&gt;",
    ///             "&lt;GUID-2&gt;",
    ///         },
    ///         StartTime = "2023-11-30T10:30:00",
    ///         TimeZone = "Asia/Kolkata",
    ///     });
    /// 
    /// });
    /// ```
    /// &lt;!--End PulumiCodeChooser --&gt;
    /// Monitor Downtimes are of four types; **one-time**, **daily**, **weekly** and **monthly**. For more details on each type and the right arguments that go with them, check out the argument reference and examples sections below.
    /// 
    /// ## Examples
    /// 
    /// ### One-Time Monitor Downtime
    /// 
    /// The below example illustrates creating a **one-time** monitor downtime.
    /// 
    /// &lt;!--Start PulumiCodeChooser --&gt;
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using NewRelic = Pulumi.NewRelic;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var sampleOneTimeNewrelicMonitorDowntime = new NewRelic.MonitorDowntime("sampleOneTimeNewrelicMonitorDowntime", new()
    ///     {
    ///         EndTime = "2024-01-04T16:24:30",
    ///         Mode = "ONE_TIME",
    ///         MonitorGuids = new[]
    ///         {
    ///             "&lt;GUID-1&gt;",
    ///             "&lt;GUID-2&gt;",
    ///         },
    ///         StartTime = "2023-12-04T10:15:00",
    ///         TimeZone = "America/Los_Angeles",
    ///     });
    /// 
    /// });
    /// ```
    /// &lt;!--End PulumiCodeChooser --&gt;
    /// 
    /// ### Daily Monitor Downtime
    /// 
    /// The below example illustrates creating a **daily** monitor downtime.
    /// 
    /// Note that `end_repeat` has been specified in the configuration; however, this is optional, in accordance with the rules of `end_repeat` specified in the argument reference section above. This example uses the `on_date` nested argument of `end_repeat`, however, the other nested argument, `on_repeat` may also be used _instead_, as you may see in some of the other examples below; though both `on_date` and `on_repeat` cannot be specified together, as they are mutually exclusive.
    /// 
    /// &lt;!--Start PulumiCodeChooser --&gt;
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using NewRelic = Pulumi.NewRelic;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var sampleDailyNewrelicMonitorDowntime = new NewRelic.MonitorDowntime("sampleDailyNewrelicMonitorDowntime", new()
    ///     {
    ///         EndRepeat = new NewRelic.Inputs.MonitorDowntimeEndRepeatArgs
    ///         {
    ///             OnDate = "2023-12-25",
    ///         },
    ///         EndTime = "2024-01-04T07:15:00",
    ///         Mode = "DAILY",
    ///         MonitorGuids = new[]
    ///         {
    ///             "&lt;GUID-1&gt;",
    ///             "&lt;GUID-2&gt;",
    ///         },
    ///         StartTime = "2023-12-04T18:15:00",
    ///         TimeZone = "Asia/Kolkata",
    ///     });
    /// 
    /// });
    /// ```
    /// &lt;!--End PulumiCodeChooser --&gt;
    /// 
    /// ### Weekly Monitor Downtime
    /// 
    /// The below example illustrates creating a **weekly** monitor downtime.
    /// 
    /// Note that `maintenance_days` has been specified in the configuration as it is required with weekly monitor downtimes; and `end_repeat` has not been specified as it is optional, all in accordance with the rules of these arguments specified in the argument reference section above.
    /// 
    /// &lt;!--Start PulumiCodeChooser --&gt;
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using NewRelic = Pulumi.NewRelic;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var sampleWeeklyNewrelicMonitorDowntime = new NewRelic.MonitorDowntime("sampleWeeklyNewrelicMonitorDowntime", new()
    ///     {
    ///         EndTime = "2024-01-04T23:55:00",
    ///         MaintenanceDays = new[]
    ///         {
    ///             "SATURDAY",
    ///             "SUNDAY",
    ///         },
    ///         Mode = "WEEKLY",
    ///         MonitorGuids = new[]
    ///         {
    ///             "&lt;GUID-1&gt;",
    ///             "&lt;GUID-2&gt;",
    ///         },
    ///         StartTime = "2023-12-04T14:15:00",
    ///         TimeZone = "US/Hawaii",
    ///     });
    /// 
    /// });
    /// ```
    /// &lt;!--End PulumiCodeChooser --&gt;
    /// 
    /// ### Monthly Monitor Downtime
    /// 
    /// The below example illustrates creating a **monthly** monitor downtime.
    /// 
    /// Note that `frequency` has been specified in the configuration as it is required with monthly monitor downtimes, and `end_repeat` has been specified too, though it is optional. `frequency` has been specified with `days_of_week` comprising both of its nested arguments, `ordinal_day_of_month` and `week_day`; all in accordance with the rules of these arguments specified in the argument reference section above.
    /// 
    /// &lt;!--Start PulumiCodeChooser --&gt;
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using NewRelic = Pulumi.NewRelic;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var sampleMonthlyNewrelicMonitorDowntime = new NewRelic.MonitorDowntime("sampleMonthlyNewrelicMonitorDowntime", new()
    ///     {
    ///         EndRepeat = new NewRelic.Inputs.MonitorDowntimeEndRepeatArgs
    ///         {
    ///             OnRepeat = 6,
    ///         },
    ///         EndTime = "2024-01-04T19:15:00",
    ///         Frequency = new NewRelic.Inputs.MonitorDowntimeFrequencyArgs
    ///         {
    ///             DaysOfWeek = new NewRelic.Inputs.MonitorDowntimeFrequencyDaysOfWeekArgs
    ///             {
    ///                 OrdinalDayOfMonth = "SECOND",
    ///                 WeekDay = "SATURDAY",
    ///             },
    ///         },
    ///         Mode = "MONTHLY",
    ///         MonitorGuids = new[]
    ///         {
    ///             "&lt;GUID-1&gt;",
    ///             "&lt;GUID-2&gt;",
    ///         },
    ///         StartTime = "2023-12-04T07:15:00",
    ///         TimeZone = "Europe/Dublin",
    ///     });
    /// 
    /// });
    /// ```
    /// &lt;!--End PulumiCodeChooser --&gt;
    /// However, the `frequency` block in monthly monitor downtimes may also be specified with its other nested argument, `days_of_month`, as shown in the example below - though both `days_of_month` and `days_of_week` cannot be specified together, as they are mutually exclusive.
    /// &lt;!--Start PulumiCodeChooser --&gt;
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using NewRelic = Pulumi.NewRelic;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var sampleMonthlyNewrelicMonitorDowntime = new NewRelic.MonitorDowntime("sampleMonthlyNewrelicMonitorDowntime", new()
    ///     {
    ///         EndRepeat = new NewRelic.Inputs.MonitorDowntimeEndRepeatArgs
    ///         {
    ///             OnRepeat = 6,
    ///         },
    ///         EndTime = "2024-01-04T19:15:00",
    ///         Frequency = new NewRelic.Inputs.MonitorDowntimeFrequencyArgs
    ///         {
    ///             DaysOfMonths = new[]
    ///             {
    ///                 3,
    ///                 6,
    ///                 14,
    ///                 23,
    ///             },
    ///         },
    ///         Mode = "MONTHLY",
    ///         MonitorGuids = new[]
    ///         {
    ///             "&lt;GUID-1&gt;",
    ///             "&lt;GUID-2&gt;",
    ///         },
    ///         StartTime = "2023-12-04T07:15:00",
    ///         TimeZone = "Europe/Dublin",
    ///     });
    /// 
    /// });
    /// ```
    /// &lt;!--End PulumiCodeChooser --&gt;
    /// 
    /// ## Import
    /// 
    /// A monitor downtime can be imported into Terraform configuration using its `guid`, i.e.
    /// 
    /// bash
    /// 
    /// ```sh
    /// $ pulumi import newrelic:index/monitorDowntime:MonitorDowntime monitor &lt;guid&gt;
    /// ```
    /// </summary>
    [NewRelicResourceType("newrelic:index/monitorDowntime:MonitorDowntime")]
    public partial class MonitorDowntime : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The account in which the monitor downtime would be created. Defaults to the value of the environment variable `NEW_RELIC_ACCOUNT_ID` (or the `account_id` specified in the `provider{}`), if not specified.
        /// </summary>
        [Output("accountId")]
        public Output<string> AccountId { get; private set; } = null!;

        /// <summary>
        /// Options which may be used to specify when the repeat cycle of the monitor should end. This argument comprises the following nested arguments -
        /// </summary>
        [Output("endRepeat")]
        public Output<Outputs.MonitorDowntimeEndRepeat?> EndRepeat { get; private set; } = null!;

        /// <summary>
        /// The time at which the monitor downtime would end operating, a timestamp specified in the ISO 8601 format without the offset/timezone - for instance, `2024-01-05T14:27:07`.
        /// </summary>
        [Output("endTime")]
        public Output<string> EndTime { get; private set; } = null!;

        /// <summary>
        /// Options which may be used to specify the configuration of a monthly monitor downtime. This argument comprises the following nested arguments -
        /// </summary>
        [Output("frequency")]
        public Output<Outputs.MonitorDowntimeFrequency?> Frequency { get; private set; } = null!;

        /// <summary>
        /// A list of days on which weekly monitor downtimes would function. Valid values which go into this list would be `"SUNDAY"`, `"MONDAY"`, `"TUESDAY"`, `"WEDNESDAY"`, `"THURSDAY"`, `"FRIDAY"` and/or `"SATURDAY"`.
        /// 
        /// &gt; **NOTE:** `maintenance_days` **can only be used with the mode** `WEEKLY`, and **is a required argument** with weekly monitor downtimes (i.e. if the `mode` is `WEEKLY`).
        /// </summary>
        [Output("maintenanceDays")]
        public Output<ImmutableArray<string>> MaintenanceDays { get; private set; } = null!;

        /// <summary>
        /// One of the four modes of operation of monitor downtimes - `ONE_TIME`, `DAILY`, `MONTHLY` or `WEEKLY`.
        /// </summary>
        [Output("mode")]
        public Output<string> Mode { get; private set; } = null!;

        /// <summary>
        /// A list of GUIDs of synthetic monitors the monitor downtime would need to be applied to.
        /// </summary>
        [Output("monitorGuids")]
        public Output<ImmutableArray<string>> MonitorGuids { get; private set; } = null!;

        /// <summary>
        /// Name of the monitor downtime to be created.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The time at which the monitor downtime would begin to operate, a timestamp specified in the ISO 8601 format without the offset/timezone - for instance, `2023-12-20T10:48:53`.
        /// </summary>
        [Output("startTime")]
        public Output<string> StartTime { get; private set; } = null!;

        /// <summary>
        /// The timezone that applies to the Monitor Downtime schedule.
        /// </summary>
        [Output("timeZone")]
        public Output<string> TimeZone { get; private set; } = null!;


        /// <summary>
        /// Create a MonitorDowntime resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public MonitorDowntime(string name, MonitorDowntimeArgs args, CustomResourceOptions? options = null)
            : base("newrelic:index/monitorDowntime:MonitorDowntime", name, args ?? new MonitorDowntimeArgs(), MakeResourceOptions(options, ""))
        {
        }

        private MonitorDowntime(string name, Input<string> id, MonitorDowntimeState? state = null, CustomResourceOptions? options = null)
            : base("newrelic:index/monitorDowntime:MonitorDowntime", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing MonitorDowntime resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static MonitorDowntime Get(string name, Input<string> id, MonitorDowntimeState? state = null, CustomResourceOptions? options = null)
        {
            return new MonitorDowntime(name, id, state, options);
        }
    }

    public sealed class MonitorDowntimeArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The account in which the monitor downtime would be created. Defaults to the value of the environment variable `NEW_RELIC_ACCOUNT_ID` (or the `account_id` specified in the `provider{}`), if not specified.
        /// </summary>
        [Input("accountId")]
        public Input<string>? AccountId { get; set; }

        /// <summary>
        /// Options which may be used to specify when the repeat cycle of the monitor should end. This argument comprises the following nested arguments -
        /// </summary>
        [Input("endRepeat")]
        public Input<Inputs.MonitorDowntimeEndRepeatArgs>? EndRepeat { get; set; }

        /// <summary>
        /// The time at which the monitor downtime would end operating, a timestamp specified in the ISO 8601 format without the offset/timezone - for instance, `2024-01-05T14:27:07`.
        /// </summary>
        [Input("endTime", required: true)]
        public Input<string> EndTime { get; set; } = null!;

        /// <summary>
        /// Options which may be used to specify the configuration of a monthly monitor downtime. This argument comprises the following nested arguments -
        /// </summary>
        [Input("frequency")]
        public Input<Inputs.MonitorDowntimeFrequencyArgs>? Frequency { get; set; }

        [Input("maintenanceDays")]
        private InputList<string>? _maintenanceDays;

        /// <summary>
        /// A list of days on which weekly monitor downtimes would function. Valid values which go into this list would be `"SUNDAY"`, `"MONDAY"`, `"TUESDAY"`, `"WEDNESDAY"`, `"THURSDAY"`, `"FRIDAY"` and/or `"SATURDAY"`.
        /// 
        /// &gt; **NOTE:** `maintenance_days` **can only be used with the mode** `WEEKLY`, and **is a required argument** with weekly monitor downtimes (i.e. if the `mode` is `WEEKLY`).
        /// </summary>
        public InputList<string> MaintenanceDays
        {
            get => _maintenanceDays ?? (_maintenanceDays = new InputList<string>());
            set => _maintenanceDays = value;
        }

        /// <summary>
        /// One of the four modes of operation of monitor downtimes - `ONE_TIME`, `DAILY`, `MONTHLY` or `WEEKLY`.
        /// </summary>
        [Input("mode", required: true)]
        public Input<string> Mode { get; set; } = null!;

        [Input("monitorGuids")]
        private InputList<string>? _monitorGuids;

        /// <summary>
        /// A list of GUIDs of synthetic monitors the monitor downtime would need to be applied to.
        /// </summary>
        public InputList<string> MonitorGuids
        {
            get => _monitorGuids ?? (_monitorGuids = new InputList<string>());
            set => _monitorGuids = value;
        }

        /// <summary>
        /// Name of the monitor downtime to be created.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The time at which the monitor downtime would begin to operate, a timestamp specified in the ISO 8601 format without the offset/timezone - for instance, `2023-12-20T10:48:53`.
        /// </summary>
        [Input("startTime", required: true)]
        public Input<string> StartTime { get; set; } = null!;

        /// <summary>
        /// The timezone that applies to the Monitor Downtime schedule.
        /// </summary>
        [Input("timeZone", required: true)]
        public Input<string> TimeZone { get; set; } = null!;

        public MonitorDowntimeArgs()
        {
        }
        public static new MonitorDowntimeArgs Empty => new MonitorDowntimeArgs();
    }

    public sealed class MonitorDowntimeState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The account in which the monitor downtime would be created. Defaults to the value of the environment variable `NEW_RELIC_ACCOUNT_ID` (or the `account_id` specified in the `provider{}`), if not specified.
        /// </summary>
        [Input("accountId")]
        public Input<string>? AccountId { get; set; }

        /// <summary>
        /// Options which may be used to specify when the repeat cycle of the monitor should end. This argument comprises the following nested arguments -
        /// </summary>
        [Input("endRepeat")]
        public Input<Inputs.MonitorDowntimeEndRepeatGetArgs>? EndRepeat { get; set; }

        /// <summary>
        /// The time at which the monitor downtime would end operating, a timestamp specified in the ISO 8601 format without the offset/timezone - for instance, `2024-01-05T14:27:07`.
        /// </summary>
        [Input("endTime")]
        public Input<string>? EndTime { get; set; }

        /// <summary>
        /// Options which may be used to specify the configuration of a monthly monitor downtime. This argument comprises the following nested arguments -
        /// </summary>
        [Input("frequency")]
        public Input<Inputs.MonitorDowntimeFrequencyGetArgs>? Frequency { get; set; }

        [Input("maintenanceDays")]
        private InputList<string>? _maintenanceDays;

        /// <summary>
        /// A list of days on which weekly monitor downtimes would function. Valid values which go into this list would be `"SUNDAY"`, `"MONDAY"`, `"TUESDAY"`, `"WEDNESDAY"`, `"THURSDAY"`, `"FRIDAY"` and/or `"SATURDAY"`.
        /// 
        /// &gt; **NOTE:** `maintenance_days` **can only be used with the mode** `WEEKLY`, and **is a required argument** with weekly monitor downtimes (i.e. if the `mode` is `WEEKLY`).
        /// </summary>
        public InputList<string> MaintenanceDays
        {
            get => _maintenanceDays ?? (_maintenanceDays = new InputList<string>());
            set => _maintenanceDays = value;
        }

        /// <summary>
        /// One of the four modes of operation of monitor downtimes - `ONE_TIME`, `DAILY`, `MONTHLY` or `WEEKLY`.
        /// </summary>
        [Input("mode")]
        public Input<string>? Mode { get; set; }

        [Input("monitorGuids")]
        private InputList<string>? _monitorGuids;

        /// <summary>
        /// A list of GUIDs of synthetic monitors the monitor downtime would need to be applied to.
        /// </summary>
        public InputList<string> MonitorGuids
        {
            get => _monitorGuids ?? (_monitorGuids = new InputList<string>());
            set => _monitorGuids = value;
        }

        /// <summary>
        /// Name of the monitor downtime to be created.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The time at which the monitor downtime would begin to operate, a timestamp specified in the ISO 8601 format without the offset/timezone - for instance, `2023-12-20T10:48:53`.
        /// </summary>
        [Input("startTime")]
        public Input<string>? StartTime { get; set; }

        /// <summary>
        /// The timezone that applies to the Monitor Downtime schedule.
        /// </summary>
        [Input("timeZone")]
        public Input<string>? TimeZone { get; set; }

        public MonitorDowntimeState()
        {
        }
        public static new MonitorDowntimeState Empty => new MonitorDowntimeState();
    }
}
