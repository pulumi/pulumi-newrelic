// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.NewRelic
{
    /// <summary>
    /// Use this resource to create and manage NRQL alert conditions in New Relic.
    /// 
    /// ## Example Usage
    /// 
    /// ### Type: `static` (default)
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using NewRelic = Pulumi.NewRelic;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var foo = new NewRelic.AlertPolicy("foo", new()
    ///     {
    ///         Name = "foo",
    ///     });
    /// 
    ///     var fooNrqlAlertCondition = new NewRelic.NrqlAlertCondition("foo", new()
    ///     {
    ///         AccountId = 12345678,
    ///         PolicyId = foo.Id,
    ///         Type = "static",
    ///         Name = "foo",
    ///         Description = "Alert when transactions are taking too long",
    ///         RunbookUrl = "https://www.example.com",
    ///         Enabled = true,
    ///         ViolationTimeLimitSeconds = 3600,
    ///         FillOption = "static",
    ///         FillValue = 1,
    ///         AggregationWindow = 60,
    ///         AggregationMethod = "event_flow",
    ///         AggregationDelay = "120",
    ///         ExpirationDuration = 120,
    ///         OpenViolationOnExpiration = true,
    ///         CloseViolationsOnExpiration = true,
    ///         SlideBy = 30,
    ///         Nrql = new NewRelic.Inputs.NrqlAlertConditionNrqlArgs
    ///         {
    ///             Query = "SELECT average(duration) FROM Transaction where appName = 'Your App'",
    ///         },
    ///         Critical = new NewRelic.Inputs.NrqlAlertConditionCriticalArgs
    ///         {
    ///             Operator = "above",
    ///             Threshold = 5.5,
    ///             ThresholdDuration = 300,
    ///             ThresholdOccurrences = "ALL",
    ///         },
    ///         Warning = new NewRelic.Inputs.NrqlAlertConditionWarningArgs
    ///         {
    ///             Operator = "above",
    ///             Threshold = 3.5,
    ///             ThresholdDuration = 600,
    ///             ThresholdOccurrences = "ALL",
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## NRQL
    /// 
    /// The `nrql` block supports the following arguments:
    /// 
    /// - `query` - (Required) The NRQL query to execute for the condition.
    /// - `evaluation_offset` - (Optional) **DEPRECATED:** Use `aggregation_method` instead. Represented in minutes and must be within 1-20 minutes (inclusive). NRQL queries are evaluated based on their `aggregation_window` size. The start time depends on this value. It's recommended to set this to 3 windows. An offset of less than 3 windows will trigger incidents sooner, but you may see more false positives and negatives due to data latency. With `evaluation_offset` set to 3 windows and an `aggregation_window` of 60 seconds, the NRQL time window applied to your query will be: `SINCE 3 minutes ago UNTIL 2 minutes ago`. `evaluation_offset` cannot be set with `aggregation_method`, `aggregation_delay`, or `aggregation_timer`.&lt;br&gt;
    /// - `since_value` - (Optional)  **DEPRECATED:** Use `aggregation_method` instead. The value to be used in the `SINCE &lt;X&gt; minutes ago` clause for the NRQL query. Must be between 1-20 (inclusive). &lt;br&gt;
    /// 
    /// ## Terms
    /// 
    /// &gt; **NOTE:** The direct use of the `term` has been deprecated, and users should use `critical` and `warning` instead.  What follows now applies to the named priority attributes for `critical` and `warning`, but for those attributes the priority is not allowed. At least one `critical` or `warning` term must be defined.
    /// 
    /// NRQL alert conditions support up to two terms. At least one `term` must have `priority` set to `critical` and the second optional `term` must have `priority` set to `warning`.
    /// 
    /// The `term` block supports the following arguments:
    /// 
    /// - `operator` - (Optional) Valid values are `above`, `above_or_equals`, `below`, `below_or_equals`, `equals`, or `not_equals` (case insensitive). Defaults to `equals`. Note that when using a `type` of `baseline`, the only valid option here is `above`.
    /// - `priority` - (Optional) `critical` or `warning`. Defaults to `critical`.
    /// - `threshold` - (Required) The value which will trigger an incident.
    /// &lt;br&gt;For _baseline_ NRQL alert conditions, the value must be in the range [1, 1000]. The value is the number of standard deviations from the baseline that the metric must exceed in order to create an incident.
    /// - `threshold_duration` - (Optional) The duration, in seconds, that the threshold must violate in order to create an incident. Value must be a multiple of the `aggregation_window` (which has a default of 60 seconds).
    /// &lt;br&gt;For _baseline_ NRQL alert conditions, the value must be within 120-86400 seconds (inclusive).
    /// &lt;br&gt;For _static_ NRQL alert conditions, the value must be within 60-86400 seconds (inclusive).
    /// 
    /// - `threshold_occurrences` - (Optional) The criteria for how many data points must be in violation for the specified threshold duration. Valid values are: `all` or `at_least_once` (case insensitive).
    /// - `duration` - (Optional) **DEPRECATED:** Use `threshold_duration` instead. The duration of time, in _minutes_, that the threshold must violate for in order to create an incident. Must be within 1-120 (inclusive).
    /// - `time_function` - (Optional) **DEPRECATED:** Use `threshold_occurrences` instead. The criteria for how many data points must be in violation for the specified threshold duration. Valid values are: `all` or `any`.
    /// 
    /// &gt; **NOTE:** When a `critical` or `warning` block is added to this resource, using either `duration` or `threshold_duration` (one of the two) is mandatory. Both of these should not be specified.
    /// 
    /// &gt; **NOTE:** When a `critical` or `warning` block is added to this resource, using either `time_function` or `threshold_occurrences` (one of the two) is mandatory. Both of these should not be specified.
    /// 
    /// ## Additional Examples
    /// 
    /// ##### Type: `baseline`
    /// 
    /// [Baseline NRQL alert conditions](https://docs.newrelic.com/docs/alerts/new-relic-alerts/defining-conditions/create-baseline-alert-conditions) are dynamic in nature and adjust to the behavior of your data. The example below demonstrates a baseline NRQL alert condition for alerting when transaction durations are above a specified threshold and dynamically adjusts based on data trends.
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using NewRelic = Pulumi.NewRelic;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var foo = new NewRelic.AlertPolicy("foo", new()
    ///     {
    ///         Name = "foo",
    ///     });
    /// 
    ///     var fooNrqlAlertCondition = new NewRelic.NrqlAlertCondition("foo", new()
    ///     {
    ///         AccountId = "your_account_id",
    ///         PolicyId = foo.Id,
    ///         Type = "static",
    ///         Name = "foo",
    ///         Description = "Alert when transactions are taking too long",
    ///         RunbookUrl = "https://www.example.com",
    ///         Enabled = true,
    ///         ViolationTimeLimitSeconds = 3600,
    ///         FillOption = "static",
    ///         FillValue = 1,
    ///         AggregationWindow = 60,
    ///         AggregationMethod = "event_flow",
    ///         AggregationDelay = "120",
    ///         ExpirationDuration = 120,
    ///         OpenViolationOnExpiration = true,
    ///         CloseViolationsOnExpiration = true,
    ///         SlideBy = 30,
    ///         Nrql = new NewRelic.Inputs.NrqlAlertConditionNrqlArgs
    ///         {
    ///             Query = "SELECT average(duration) FROM Transaction where appName = 'Your App'",
    ///         },
    ///         Critical = new NewRelic.Inputs.NrqlAlertConditionCriticalArgs
    ///         {
    ///             Operator = "above",
    ///             Threshold = 5.5,
    ///             ThresholdDuration = 300,
    ///             ThresholdOccurrences = "ALL",
    ///         },
    ///         Warning = new NewRelic.Inputs.NrqlAlertConditionWarningArgs
    ///         {
    ///             Operator = "above",
    ///             Threshold = 3.5,
    ///             ThresholdDuration = 600,
    ///             ThresholdOccurrences = "ALL",
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Tags
    /// 
    /// Manage NRQL alert condition tags with `newrelic.EntityTags`. For up-to-date documentation about the tagging resource, please check `newrelic.EntityTags`.
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using NewRelic = Pulumi.NewRelic;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var foo = new NewRelic.AlertPolicy("foo", new()
    ///     {
    ///         Name = "foo",
    ///     });
    /// 
    ///     var fooNrqlAlertCondition = new NewRelic.NrqlAlertCondition("foo", new()
    ///     {
    ///         AccountId = 12345678,
    ///         PolicyId = foo.Id,
    ///         Type = "static",
    ///         Name = "foo",
    ///         Description = "Alert when transactions are taking too long",
    ///         RunbookUrl = "https://www.example.com",
    ///         Enabled = true,
    ///         ViolationTimeLimitSeconds = 3600,
    ///         FillOption = "static",
    ///         FillValue = 1,
    ///         AggregationWindow = 60,
    ///         AggregationMethod = "event_flow",
    ///         AggregationDelay = "120",
    ///         ExpirationDuration = 120,
    ///         OpenViolationOnExpiration = true,
    ///         CloseViolationsOnExpiration = true,
    ///         SlideBy = 30,
    ///         Nrql = new NewRelic.Inputs.NrqlAlertConditionNrqlArgs
    ///         {
    ///             Query = "SELECT average(duration) FROM Transaction where appName = 'Your App'",
    ///         },
    ///         Critical = new NewRelic.Inputs.NrqlAlertConditionCriticalArgs
    ///         {
    ///             Operator = "above",
    ///             Threshold = 5.5,
    ///             ThresholdDuration = 300,
    ///             ThresholdOccurrences = "ALL",
    ///         },
    ///         Warning = new NewRelic.Inputs.NrqlAlertConditionWarningArgs
    ///         {
    ///             Operator = "above",
    ///             Threshold = 3.5,
    ///             ThresholdDuration = 600,
    ///             ThresholdOccurrences = "ALL",
    ///         },
    ///     });
    /// 
    ///     var myConditionEntityTags = new NewRelic.EntityTags("my_condition_entity_tags", new()
    ///     {
    ///         Guid = fooNrqlAlertCondition.EntityGuid,
    ///         Tags = new[]
    ///         {
    ///             new NewRelic.Inputs.EntityTagsTagArgs
    ///             {
    ///                 Key = "my-key",
    ///                 Values = new[]
    ///                 {
    ///                     "my-value",
    ///                     "my-other-value",
    ///                 },
    ///             },
    ///             new NewRelic.Inputs.EntityTagsTagArgs
    ///             {
    ///                 Key = "my-key-2",
    ///                 Values = new[]
    ///                 {
    ///                     "my-value-2",
    ///                 },
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// &lt;small&gt;alerts.newrelic.com/accounts/**\&lt;account_id\&gt;**/policies/**\&lt;policy_id\&gt;**/conditions/**\&lt;condition_id\&gt;**/edit&lt;/small&gt;
    /// 
    /// ## Upgrade from 1.x to 2.x
    /// 
    /// There have been several deprecations in the `newrelic.NrqlAlertCondition`
    /// resource. Users will need to make some updates in order to have a smooth
    /// upgrade.
    /// 
    /// An example resource from 1.x might look like the following.
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using NewRelic = Pulumi.NewRelic;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var z = new NewRelic.NrqlAlertCondition("z", new()
    ///     {
    ///         PolicyId = zNewrelicAlertPolicy.Id,
    ///         Name = "zleslie-test",
    ///         Type = "static",
    ///         RunbookUrl = "https://localhost",
    ///         Enabled = true,
    ///         ViolationTimeLimit = "TWENTY_FOUR_HOURS",
    ///         Critical = new NewRelic.Inputs.NrqlAlertConditionCriticalArgs
    ///         {
    ///             Operator = "above",
    ///             ThresholdDuration = 120,
    ///             Threshold = 3,
    ///             ThresholdOccurrences = "AT_LEAST_ONCE",
    ///         },
    ///         Nrql = new NewRelic.Inputs.NrqlAlertConditionNrqlArgs
    ///         {
    ///             Query = "SELECT count(*) FROM TransactionError WHERE appName like '%Dummy App%' FACET appName",
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// After making the appropriate adjustments mentioned in the deprecation warnings,
    /// the resource now looks like the following.
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using NewRelic = Pulumi.NewRelic;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var z = new NewRelic.NrqlAlertCondition("z", new()
    ///     {
    ///         PolicyId = zNewrelicAlertPolicy.Id,
    ///         Name = "zleslie-test",
    ///         Type = "static",
    ///         RunbookUrl = "https://localhost",
    ///         Enabled = true,
    ///         ViolationTimeLimitSeconds = 86400,
    ///         Terms = new[]
    ///         {
    ///             new NewRelic.Inputs.NrqlAlertConditionTermArgs
    ///             {
    ///                 Priority = "critical",
    ///                 Operator = "above",
    ///                 Threshold = 3,
    ///                 Duration = 5,
    ///                 TimeFunction = "any",
    ///             },
    ///         },
    ///         Nrql = new NewRelic.Inputs.NrqlAlertConditionNrqlArgs
    ///         {
    ///             Query = "SELECT count(*) FROM TransactionError WHERE appName like '%Dummy App%' FACET appName",
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// NRQL alert conditions can be imported using a composite ID of `&lt;policy_id&gt;:&lt;condition_id&gt;:&lt;conditionType&gt;`, e.g.
    /// 
    /// // For `baseline` conditions
    /// 
    /// ```sh
    /// $ pulumi import newrelic:index/nrqlAlertCondition:NrqlAlertCondition foo 538291:6789035:baseline
    /// ```
    /// 
    /// // For `static` conditions
    /// 
    /// ```sh
    /// $ pulumi import newrelic:index/nrqlAlertCondition:NrqlAlertCondition foo 538291:6789035:static
    /// ```
    /// </summary>
    [NewRelicResourceType("newrelic:index/nrqlAlertCondition:NrqlAlertCondition")]
    public partial class NrqlAlertCondition : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The New Relic account ID of the account you wish to create the condition. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
        /// </summary>
        [Output("accountId")]
        public Output<int> AccountId { get; private set; } = null!;

        /// <summary>
        /// How long we wait for data that belongs in each aggregation window. Depending on your data, a longer delay may increase accuracy but delay notifications. Use `aggregation_delay` with the `event_flow` and `cadence` methods. The maximum delay is 1200 seconds (20 minutes) when using `event_flow` and 3600 seconds (60 minutes) when using `cadence`. In both cases, the minimum delay is 0 seconds and the default is 120 seconds. `aggregation_delay` cannot be set with `nrql.evaluation_offset`.
        /// </summary>
        [Output("aggregationDelay")]
        public Output<string?> AggregationDelay { get; private set; } = null!;

        /// <summary>
        /// Determines when we consider an aggregation window to be complete so that we can evaluate the signal for incidents. Possible values are `cadence`, `event_flow` or `event_timer`. Default is `event_flow`. `aggregation_method` cannot be set with `nrql.evaluation_offset`.
        /// </summary>
        [Output("aggregationMethod")]
        public Output<string?> AggregationMethod { get; private set; } = null!;

        /// <summary>
        /// How long we wait after each data point arrives to make sure we've processed the whole batch. Use `aggregation_timer` with the `event_timer` method. The timer value can range from 0 seconds to 1200 seconds (20 minutes); the default is 60 seconds. `aggregation_timer` cannot be set with `nrql.evaluation_offset`.
        /// </summary>
        [Output("aggregationTimer")]
        public Output<string?> AggregationTimer { get; private set; } = null!;

        /// <summary>
        /// The duration of the time window used to evaluate the NRQL query, in seconds. The value must be at least 30 seconds, and no more than 21600 seconds (6 hours). Default is 60 seconds.
        /// </summary>
        [Output("aggregationWindow")]
        public Output<int> AggregationWindow { get; private set; } = null!;

        /// <summary>
        /// The baseline direction of a _baseline_ NRQL alert condition. Valid values are: `lower_only`, `upper_and_lower`, `upper_only` (case insensitive).
        /// </summary>
        [Output("baselineDirection")]
        public Output<string?> BaselineDirection { get; private set; } = null!;

        /// <summary>
        /// Whether to close all open incidents when the signal expires.
        /// </summary>
        [Output("closeViolationsOnExpiration")]
        public Output<bool?> CloseViolationsOnExpiration { get; private set; } = null!;

        /// <summary>
        /// A list containing the `critical` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
        /// </summary>
        [Output("critical")]
        public Output<Outputs.NrqlAlertConditionCritical?> Critical { get; private set; } = null!;

        /// <summary>
        /// The description of the NRQL alert condition.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// Whether to enable the alert condition. Valid values are `true` and `false`. Defaults to `true`.
        /// </summary>
        [Output("enabled")]
        public Output<bool?> Enabled { get; private set; } = null!;

        /// <summary>
        /// The unique entity identifier of the NRQL Condition in New Relic.
        /// </summary>
        [Output("entityGuid")]
        public Output<string> EntityGuid { get; private set; } = null!;

        /// <summary>
        /// How long we wait until the signal starts evaluating. The maximum delay is 7200 seconds (120 minutes).
        /// </summary>
        [Output("evaluationDelay")]
        public Output<int?> EvaluationDelay { get; private set; } = null!;

        /// <summary>
        /// The amount of time (in seconds) to wait before considering the signal expired. The value must be at least 30 seconds, and no more than 172800 seconds (48 hours).
        /// </summary>
        [Output("expirationDuration")]
        public Output<int?> ExpirationDuration { get; private set; } = null!;

        /// <summary>
        /// Which strategy to use when filling gaps in the signal. Possible values are `none`, `last_value` or `static`. If `static`, the `fill_value` field will be used for filling gaps in the signal.
        /// </summary>
        [Output("fillOption")]
        public Output<string?> FillOption { get; private set; } = null!;

        /// <summary>
        /// This value will be used for filling gaps in the signal.
        /// </summary>
        [Output("fillValue")]
        public Output<double?> FillValue { get; private set; } = null!;

        /// <summary>
        /// The title of the condition.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// A NRQL query. See NRQL below for details.
        /// </summary>
        [Output("nrql")]
        public Output<Outputs.NrqlAlertConditionNrql> Nrql { get; private set; } = null!;

        /// <summary>
        /// Whether to create a new incident to capture that the signal expired.
        /// </summary>
        [Output("openViolationOnExpiration")]
        public Output<bool?> OpenViolationOnExpiration { get; private set; } = null!;

        /// <summary>
        /// The ID of the policy where this condition should be used.
        /// </summary>
        [Output("policyId")]
        public Output<int> PolicyId { get; private set; } = null!;

        /// <summary>
        /// Runbook URL to display in notifications.
        /// </summary>
        [Output("runbookUrl")]
        public Output<string?> RunbookUrl { get; private set; } = null!;

        /// <summary>
        /// Gathers data in overlapping time windows to smooth the chart line, making it easier to spot trends. The `slide_by` value is specified in seconds and must be smaller than and a factor of the `aggregation_window`.
        /// </summary>
        [Output("slideBy")]
        public Output<int?> SlideBy { get; private set; } = null!;

        /// <summary>
        /// **DEPRECATED** Use `critical`, and `warning` instead. A list of terms for this condition. See Terms below for details.
        /// </summary>
        [Output("terms")]
        public Output<ImmutableArray<Outputs.NrqlAlertConditionTerm>> Terms { get; private set; } = null!;

        /// <summary>
        /// The type of the condition. Valid values are `static` or `baseline`. Defaults to `static`.
        /// </summary>
        [Output("type")]
        public Output<string?> Type { get; private set; } = null!;

        /// <summary>
        /// **DEPRECATED:** Use `violation_time_limit_seconds` instead. Sets a time limit, in hours, that will automatically force-close a long-lasting incident after the time limit you select. Possible values are `ONE_HOUR`, `TWO_HOURS`, `FOUR_HOURS`, `EIGHT_HOURS`, `TWELVE_HOURS`, `TWENTY_FOUR_HOURS`, `THIRTY_DAYS` (case insensitive).&lt;br&gt;
        /// &lt;small&gt;\***Note**: One of `violation_time_limit` _or_ `violation_time_limit_seconds` must be set, but not both.&lt;/small&gt;
        /// </summary>
        [Output("violationTimeLimit")]
        public Output<string> ViolationTimeLimit { get; private set; } = null!;

        /// <summary>
        /// Sets a time limit, in seconds, that will automatically force-close a long-lasting incident after the time limit you select. The value must be between 300 seconds (5 minutes) to 2592000 seconds (30 days) (inclusive). &lt;br&gt;
        /// &lt;small&gt;\***Note**: One of `violation_time_limit` _or_ `violation_time_limit_seconds` must be set, but not both.&lt;/small&gt;
        /// </summary>
        [Output("violationTimeLimitSeconds")]
        public Output<int?> ViolationTimeLimitSeconds { get; private set; } = null!;

        /// <summary>
        /// A list containing the `warning` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
        /// </summary>
        [Output("warning")]
        public Output<Outputs.NrqlAlertConditionWarning?> Warning { get; private set; } = null!;


        /// <summary>
        /// Create a NrqlAlertCondition resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public NrqlAlertCondition(string name, NrqlAlertConditionArgs args, CustomResourceOptions? options = null)
            : base("newrelic:index/nrqlAlertCondition:NrqlAlertCondition", name, args ?? new NrqlAlertConditionArgs(), MakeResourceOptions(options, ""))
        {
        }

        private NrqlAlertCondition(string name, Input<string> id, NrqlAlertConditionState? state = null, CustomResourceOptions? options = null)
            : base("newrelic:index/nrqlAlertCondition:NrqlAlertCondition", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing NrqlAlertCondition resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static NrqlAlertCondition Get(string name, Input<string> id, NrqlAlertConditionState? state = null, CustomResourceOptions? options = null)
        {
            return new NrqlAlertCondition(name, id, state, options);
        }
    }

    public sealed class NrqlAlertConditionArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The New Relic account ID of the account you wish to create the condition. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
        /// </summary>
        [Input("accountId")]
        public Input<int>? AccountId { get; set; }

        /// <summary>
        /// How long we wait for data that belongs in each aggregation window. Depending on your data, a longer delay may increase accuracy but delay notifications. Use `aggregation_delay` with the `event_flow` and `cadence` methods. The maximum delay is 1200 seconds (20 minutes) when using `event_flow` and 3600 seconds (60 minutes) when using `cadence`. In both cases, the minimum delay is 0 seconds and the default is 120 seconds. `aggregation_delay` cannot be set with `nrql.evaluation_offset`.
        /// </summary>
        [Input("aggregationDelay")]
        public Input<string>? AggregationDelay { get; set; }

        /// <summary>
        /// Determines when we consider an aggregation window to be complete so that we can evaluate the signal for incidents. Possible values are `cadence`, `event_flow` or `event_timer`. Default is `event_flow`. `aggregation_method` cannot be set with `nrql.evaluation_offset`.
        /// </summary>
        [Input("aggregationMethod")]
        public Input<string>? AggregationMethod { get; set; }

        /// <summary>
        /// How long we wait after each data point arrives to make sure we've processed the whole batch. Use `aggregation_timer` with the `event_timer` method. The timer value can range from 0 seconds to 1200 seconds (20 minutes); the default is 60 seconds. `aggregation_timer` cannot be set with `nrql.evaluation_offset`.
        /// </summary>
        [Input("aggregationTimer")]
        public Input<string>? AggregationTimer { get; set; }

        /// <summary>
        /// The duration of the time window used to evaluate the NRQL query, in seconds. The value must be at least 30 seconds, and no more than 21600 seconds (6 hours). Default is 60 seconds.
        /// </summary>
        [Input("aggregationWindow")]
        public Input<int>? AggregationWindow { get; set; }

        /// <summary>
        /// The baseline direction of a _baseline_ NRQL alert condition. Valid values are: `lower_only`, `upper_and_lower`, `upper_only` (case insensitive).
        /// </summary>
        [Input("baselineDirection")]
        public Input<string>? BaselineDirection { get; set; }

        /// <summary>
        /// Whether to close all open incidents when the signal expires.
        /// </summary>
        [Input("closeViolationsOnExpiration")]
        public Input<bool>? CloseViolationsOnExpiration { get; set; }

        /// <summary>
        /// A list containing the `critical` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
        /// </summary>
        [Input("critical")]
        public Input<Inputs.NrqlAlertConditionCriticalArgs>? Critical { get; set; }

        /// <summary>
        /// The description of the NRQL alert condition.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// Whether to enable the alert condition. Valid values are `true` and `false`. Defaults to `true`.
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// How long we wait until the signal starts evaluating. The maximum delay is 7200 seconds (120 minutes).
        /// </summary>
        [Input("evaluationDelay")]
        public Input<int>? EvaluationDelay { get; set; }

        /// <summary>
        /// The amount of time (in seconds) to wait before considering the signal expired. The value must be at least 30 seconds, and no more than 172800 seconds (48 hours).
        /// </summary>
        [Input("expirationDuration")]
        public Input<int>? ExpirationDuration { get; set; }

        /// <summary>
        /// Which strategy to use when filling gaps in the signal. Possible values are `none`, `last_value` or `static`. If `static`, the `fill_value` field will be used for filling gaps in the signal.
        /// </summary>
        [Input("fillOption")]
        public Input<string>? FillOption { get; set; }

        /// <summary>
        /// This value will be used for filling gaps in the signal.
        /// </summary>
        [Input("fillValue")]
        public Input<double>? FillValue { get; set; }

        /// <summary>
        /// The title of the condition.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// A NRQL query. See NRQL below for details.
        /// </summary>
        [Input("nrql", required: true)]
        public Input<Inputs.NrqlAlertConditionNrqlArgs> Nrql { get; set; } = null!;

        /// <summary>
        /// Whether to create a new incident to capture that the signal expired.
        /// </summary>
        [Input("openViolationOnExpiration")]
        public Input<bool>? OpenViolationOnExpiration { get; set; }

        /// <summary>
        /// The ID of the policy where this condition should be used.
        /// </summary>
        [Input("policyId", required: true)]
        public Input<int> PolicyId { get; set; } = null!;

        /// <summary>
        /// Runbook URL to display in notifications.
        /// </summary>
        [Input("runbookUrl")]
        public Input<string>? RunbookUrl { get; set; }

        /// <summary>
        /// Gathers data in overlapping time windows to smooth the chart line, making it easier to spot trends. The `slide_by` value is specified in seconds and must be smaller than and a factor of the `aggregation_window`.
        /// </summary>
        [Input("slideBy")]
        public Input<int>? SlideBy { get; set; }

        [Input("terms")]
        private InputList<Inputs.NrqlAlertConditionTermArgs>? _terms;

        /// <summary>
        /// **DEPRECATED** Use `critical`, and `warning` instead. A list of terms for this condition. See Terms below for details.
        /// </summary>
        [Obsolete(@"use `critical` and `warning` attributes instead")]
        public InputList<Inputs.NrqlAlertConditionTermArgs> Terms
        {
            get => _terms ?? (_terms = new InputList<Inputs.NrqlAlertConditionTermArgs>());
            set => _terms = value;
        }

        /// <summary>
        /// The type of the condition. Valid values are `static` or `baseline`. Defaults to `static`.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

        /// <summary>
        /// **DEPRECATED:** Use `violation_time_limit_seconds` instead. Sets a time limit, in hours, that will automatically force-close a long-lasting incident after the time limit you select. Possible values are `ONE_HOUR`, `TWO_HOURS`, `FOUR_HOURS`, `EIGHT_HOURS`, `TWELVE_HOURS`, `TWENTY_FOUR_HOURS`, `THIRTY_DAYS` (case insensitive).&lt;br&gt;
        /// &lt;small&gt;\***Note**: One of `violation_time_limit` _or_ `violation_time_limit_seconds` must be set, but not both.&lt;/small&gt;
        /// </summary>
        [Input("violationTimeLimit")]
        public Input<string>? ViolationTimeLimit { get; set; }

        /// <summary>
        /// Sets a time limit, in seconds, that will automatically force-close a long-lasting incident after the time limit you select. The value must be between 300 seconds (5 minutes) to 2592000 seconds (30 days) (inclusive). &lt;br&gt;
        /// &lt;small&gt;\***Note**: One of `violation_time_limit` _or_ `violation_time_limit_seconds` must be set, but not both.&lt;/small&gt;
        /// </summary>
        [Input("violationTimeLimitSeconds")]
        public Input<int>? ViolationTimeLimitSeconds { get; set; }

        /// <summary>
        /// A list containing the `warning` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
        /// </summary>
        [Input("warning")]
        public Input<Inputs.NrqlAlertConditionWarningArgs>? Warning { get; set; }

        public NrqlAlertConditionArgs()
        {
        }
        public static new NrqlAlertConditionArgs Empty => new NrqlAlertConditionArgs();
    }

    public sealed class NrqlAlertConditionState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The New Relic account ID of the account you wish to create the condition. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
        /// </summary>
        [Input("accountId")]
        public Input<int>? AccountId { get; set; }

        /// <summary>
        /// How long we wait for data that belongs in each aggregation window. Depending on your data, a longer delay may increase accuracy but delay notifications. Use `aggregation_delay` with the `event_flow` and `cadence` methods. The maximum delay is 1200 seconds (20 minutes) when using `event_flow` and 3600 seconds (60 minutes) when using `cadence`. In both cases, the minimum delay is 0 seconds and the default is 120 seconds. `aggregation_delay` cannot be set with `nrql.evaluation_offset`.
        /// </summary>
        [Input("aggregationDelay")]
        public Input<string>? AggregationDelay { get; set; }

        /// <summary>
        /// Determines when we consider an aggregation window to be complete so that we can evaluate the signal for incidents. Possible values are `cadence`, `event_flow` or `event_timer`. Default is `event_flow`. `aggregation_method` cannot be set with `nrql.evaluation_offset`.
        /// </summary>
        [Input("aggregationMethod")]
        public Input<string>? AggregationMethod { get; set; }

        /// <summary>
        /// How long we wait after each data point arrives to make sure we've processed the whole batch. Use `aggregation_timer` with the `event_timer` method. The timer value can range from 0 seconds to 1200 seconds (20 minutes); the default is 60 seconds. `aggregation_timer` cannot be set with `nrql.evaluation_offset`.
        /// </summary>
        [Input("aggregationTimer")]
        public Input<string>? AggregationTimer { get; set; }

        /// <summary>
        /// The duration of the time window used to evaluate the NRQL query, in seconds. The value must be at least 30 seconds, and no more than 21600 seconds (6 hours). Default is 60 seconds.
        /// </summary>
        [Input("aggregationWindow")]
        public Input<int>? AggregationWindow { get; set; }

        /// <summary>
        /// The baseline direction of a _baseline_ NRQL alert condition. Valid values are: `lower_only`, `upper_and_lower`, `upper_only` (case insensitive).
        /// </summary>
        [Input("baselineDirection")]
        public Input<string>? BaselineDirection { get; set; }

        /// <summary>
        /// Whether to close all open incidents when the signal expires.
        /// </summary>
        [Input("closeViolationsOnExpiration")]
        public Input<bool>? CloseViolationsOnExpiration { get; set; }

        /// <summary>
        /// A list containing the `critical` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
        /// </summary>
        [Input("critical")]
        public Input<Inputs.NrqlAlertConditionCriticalGetArgs>? Critical { get; set; }

        /// <summary>
        /// The description of the NRQL alert condition.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// Whether to enable the alert condition. Valid values are `true` and `false`. Defaults to `true`.
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// The unique entity identifier of the NRQL Condition in New Relic.
        /// </summary>
        [Input("entityGuid")]
        public Input<string>? EntityGuid { get; set; }

        /// <summary>
        /// How long we wait until the signal starts evaluating. The maximum delay is 7200 seconds (120 minutes).
        /// </summary>
        [Input("evaluationDelay")]
        public Input<int>? EvaluationDelay { get; set; }

        /// <summary>
        /// The amount of time (in seconds) to wait before considering the signal expired. The value must be at least 30 seconds, and no more than 172800 seconds (48 hours).
        /// </summary>
        [Input("expirationDuration")]
        public Input<int>? ExpirationDuration { get; set; }

        /// <summary>
        /// Which strategy to use when filling gaps in the signal. Possible values are `none`, `last_value` or `static`. If `static`, the `fill_value` field will be used for filling gaps in the signal.
        /// </summary>
        [Input("fillOption")]
        public Input<string>? FillOption { get; set; }

        /// <summary>
        /// This value will be used for filling gaps in the signal.
        /// </summary>
        [Input("fillValue")]
        public Input<double>? FillValue { get; set; }

        /// <summary>
        /// The title of the condition.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// A NRQL query. See NRQL below for details.
        /// </summary>
        [Input("nrql")]
        public Input<Inputs.NrqlAlertConditionNrqlGetArgs>? Nrql { get; set; }

        /// <summary>
        /// Whether to create a new incident to capture that the signal expired.
        /// </summary>
        [Input("openViolationOnExpiration")]
        public Input<bool>? OpenViolationOnExpiration { get; set; }

        /// <summary>
        /// The ID of the policy where this condition should be used.
        /// </summary>
        [Input("policyId")]
        public Input<int>? PolicyId { get; set; }

        /// <summary>
        /// Runbook URL to display in notifications.
        /// </summary>
        [Input("runbookUrl")]
        public Input<string>? RunbookUrl { get; set; }

        /// <summary>
        /// Gathers data in overlapping time windows to smooth the chart line, making it easier to spot trends. The `slide_by` value is specified in seconds and must be smaller than and a factor of the `aggregation_window`.
        /// </summary>
        [Input("slideBy")]
        public Input<int>? SlideBy { get; set; }

        [Input("terms")]
        private InputList<Inputs.NrqlAlertConditionTermGetArgs>? _terms;

        /// <summary>
        /// **DEPRECATED** Use `critical`, and `warning` instead. A list of terms for this condition. See Terms below for details.
        /// </summary>
        [Obsolete(@"use `critical` and `warning` attributes instead")]
        public InputList<Inputs.NrqlAlertConditionTermGetArgs> Terms
        {
            get => _terms ?? (_terms = new InputList<Inputs.NrqlAlertConditionTermGetArgs>());
            set => _terms = value;
        }

        /// <summary>
        /// The type of the condition. Valid values are `static` or `baseline`. Defaults to `static`.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

        /// <summary>
        /// **DEPRECATED:** Use `violation_time_limit_seconds` instead. Sets a time limit, in hours, that will automatically force-close a long-lasting incident after the time limit you select. Possible values are `ONE_HOUR`, `TWO_HOURS`, `FOUR_HOURS`, `EIGHT_HOURS`, `TWELVE_HOURS`, `TWENTY_FOUR_HOURS`, `THIRTY_DAYS` (case insensitive).&lt;br&gt;
        /// &lt;small&gt;\***Note**: One of `violation_time_limit` _or_ `violation_time_limit_seconds` must be set, but not both.&lt;/small&gt;
        /// </summary>
        [Input("violationTimeLimit")]
        public Input<string>? ViolationTimeLimit { get; set; }

        /// <summary>
        /// Sets a time limit, in seconds, that will automatically force-close a long-lasting incident after the time limit you select. The value must be between 300 seconds (5 minutes) to 2592000 seconds (30 days) (inclusive). &lt;br&gt;
        /// &lt;small&gt;\***Note**: One of `violation_time_limit` _or_ `violation_time_limit_seconds` must be set, but not both.&lt;/small&gt;
        /// </summary>
        [Input("violationTimeLimitSeconds")]
        public Input<int>? ViolationTimeLimitSeconds { get; set; }

        /// <summary>
        /// A list containing the `warning` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
        /// </summary>
        [Input("warning")]
        public Input<Inputs.NrqlAlertConditionWarningGetArgs>? Warning { get; set; }

        public NrqlAlertConditionState()
        {
        }
        public static new NrqlAlertConditionState Empty => new NrqlAlertConditionState();
    }
}
