// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.NewRelic
{
    /// <summary>
    /// Use this resource to create and manage compound alert conditions in New Relic. Compound conditions allow you to combine multiple alert conditions using logical expressions (AND, OR, NOT) to create more sophisticated alerting logic.
    /// 
    /// ## Example Usage
    /// 
    /// ### Basic Compound Condition (AND)
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using NewRelic = Pulumi.NewRelic;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var example = new NewRelic.AlertPolicy("example", new()
    ///     {
    ///         Name = "my-policy",
    ///     });
    /// 
    ///     // Create component NRQL conditions
    ///     var highResponseTime = new NewRelic.NrqlAlertCondition("high_response_time", new()
    ///     {
    ///         PolicyId = example.Id,
    ///         Name = "High Response Time",
    ///         Enabled = true,
    ///         Nrql = new NewRelic.Inputs.NrqlAlertConditionNrqlArgs
    ///         {
    ///             Query = "SELECT average(duration) FROM Transaction WHERE appName = 'MyApp'",
    ///         },
    ///         Critical = new NewRelic.Inputs.NrqlAlertConditionCriticalArgs
    ///         {
    ///             Operator = "above",
    ///             Threshold = 5,
    ///             ThresholdDuration = 300,
    ///             ThresholdOccurrences = "all",
    ///         },
    ///         ViolationTimeLimitSeconds = 3600,
    ///     });
    /// 
    ///     var highErrorRate = new NewRelic.NrqlAlertCondition("high_error_rate", new()
    ///     {
    ///         PolicyId = example.Id,
    ///         Name = "High Error Rate",
    ///         Enabled = true,
    ///         Nrql = new NewRelic.Inputs.NrqlAlertConditionNrqlArgs
    ///         {
    ///             Query = "SELECT percentage(count(*), WHERE error IS true) FROM Transaction WHERE appName = 'MyApp'",
    ///         },
    ///         Critical = new NewRelic.Inputs.NrqlAlertConditionCriticalArgs
    ///         {
    ///             Operator = "above",
    ///             Threshold = 5,
    ///             ThresholdDuration = 300,
    ///             ThresholdOccurrences = "all",
    ///         },
    ///         ViolationTimeLimitSeconds = 3600,
    ///     });
    /// 
    ///     // Create alert compound condition combining both
    ///     var criticalServiceHealth = new NewRelic.AlertCompoundCondition("critical_service_health", new()
    ///     {
    ///         PolicyId = example.Id,
    ///         Name = "Critical Service Health",
    ///         Enabled = true,
    ///         TriggerExpression = "A AND B",
    ///         RunbookUrl = "https://example.com/runbooks/critical-health",
    ///         ThresholdDuration = 120,
    ///         ComponentConditions = new[]
    ///         {
    ///             new NewRelic.Inputs.AlertCompoundConditionComponentConditionArgs
    ///             {
    ///                 Id = highResponseTime.Id,
    ///                 Alias = "A",
    ///             },
    ///             new NewRelic.Inputs.AlertCompoundConditionComponentConditionArgs
    ///             {
    ///                 Id = highErrorRate.Id,
    ///                 Alias = "B",
    ///             },
    ///         },
    ///         FacetMatchingBehavior = "FACETS_IGNORED",
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Complex Condition with Three Components
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using NewRelic = Pulumi.NewRelic;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var highCpu = new NewRelic.NrqlAlertCondition("high_cpu", new()
    ///     {
    ///         PolicyId = example.Id,
    ///         Name = "High CPU",
    ///         Enabled = true,
    ///         Nrql = new NewRelic.Inputs.NrqlAlertConditionNrqlArgs
    ///         {
    ///             Query = "SELECT average(cpuPercent) FROM SystemSample WHERE hostname = 'myhost'",
    ///         },
    ///         Critical = new NewRelic.Inputs.NrqlAlertConditionCriticalArgs
    ///         {
    ///             Operator = "above",
    ///             Threshold = 80,
    ///             ThresholdDuration = 300,
    ///             ThresholdOccurrences = "all",
    ///         },
    ///         ViolationTimeLimitSeconds = 3600,
    ///     });
    /// 
    ///     var highMemory = new NewRelic.NrqlAlertCondition("high_memory", new()
    ///     {
    ///         PolicyId = example.Id,
    ///         Name = "High Memory",
    ///         Enabled = true,
    ///         Nrql = new NewRelic.Inputs.NrqlAlertConditionNrqlArgs
    ///         {
    ///             Query = "SELECT average(memoryUsedPercent) FROM SystemSample WHERE hostname = 'myhost'",
    ///         },
    ///         Critical = new NewRelic.Inputs.NrqlAlertConditionCriticalArgs
    ///         {
    ///             Operator = "above",
    ///             Threshold = 85,
    ///             ThresholdDuration = 300,
    ///             ThresholdOccurrences = "all",
    ///         },
    ///         ViolationTimeLimitSeconds = 3600,
    ///     });
    /// 
    ///     var diskFull = new NewRelic.NrqlAlertCondition("disk_full", new()
    ///     {
    ///         PolicyId = example.Id,
    ///         Name = "Disk Full",
    ///         Enabled = true,
    ///         Nrql = new NewRelic.Inputs.NrqlAlertConditionNrqlArgs
    ///         {
    ///             Query = "SELECT average(diskUsedPercent) FROM SystemSample WHERE hostname = 'myhost'",
    ///         },
    ///         Critical = new NewRelic.Inputs.NrqlAlertConditionCriticalArgs
    ///         {
    ///             Operator = "above",
    ///             Threshold = 90,
    ///             ThresholdDuration = 300,
    ///             ThresholdOccurrences = "all",
    ///         },
    ///         ViolationTimeLimitSeconds = 3600,
    ///     });
    /// 
    ///     var complex = new NewRelic.AlertCompoundCondition("complex", new()
    ///     {
    ///         PolicyId = example.Id,
    ///         Name = "Complex Infrastructure Alert",
    ///         Enabled = true,
    ///         TriggerExpression = "(A AND B) OR C",
    ///         ComponentConditions = new[]
    ///         {
    ///             new NewRelic.Inputs.AlertCompoundConditionComponentConditionArgs
    ///             {
    ///                 Id = highCpu.Id,
    ///                 Alias = "A",
    ///             },
    ///             new NewRelic.Inputs.AlertCompoundConditionComponentConditionArgs
    ///             {
    ///                 Id = highMemory.Id,
    ///                 Alias = "B",
    ///             },
    ///             new NewRelic.Inputs.AlertCompoundConditionComponentConditionArgs
    ///             {
    ///                 Id = diskFull.Id,
    ///                 Alias = "C",
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### With Facet Matching
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using NewRelic = Pulumi.NewRelic;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var highThroughputPerHost = new NewRelic.NrqlAlertCondition("high_throughput_per_host", new()
    ///     {
    ///         PolicyId = example.Id,
    ///         Name = "High Throughput Per Host",
    ///         Enabled = true,
    ///         Nrql = new NewRelic.Inputs.NrqlAlertConditionNrqlArgs
    ///         {
    ///             Query = "SELECT rate(count(*), 1 minute) FROM Transaction FACET host",
    ///         },
    ///         Critical = new NewRelic.Inputs.NrqlAlertConditionCriticalArgs
    ///         {
    ///             Operator = "above",
    ///             Threshold = 1000,
    ///             ThresholdDuration = 300,
    ///             ThresholdOccurrences = "all",
    ///         },
    ///         ViolationTimeLimitSeconds = 3600,
    ///     });
    /// 
    ///     var highErrorRatePerHost = new NewRelic.NrqlAlertCondition("high_error_rate_per_host", new()
    ///     {
    ///         PolicyId = example.Id,
    ///         Name = "High Error Rate Per Host",
    ///         Enabled = true,
    ///         Nrql = new NewRelic.Inputs.NrqlAlertConditionNrqlArgs
    ///         {
    ///             Query = "SELECT percentage(count(*), WHERE error IS true) FROM Transaction FACET host",
    ///         },
    ///         Critical = new NewRelic.Inputs.NrqlAlertConditionCriticalArgs
    ///         {
    ///             Operator = "above",
    ///             Threshold = 5,
    ///             ThresholdDuration = 300,
    ///             ThresholdOccurrences = "all",
    ///         },
    ///         ViolationTimeLimitSeconds = 3600,
    ///     });
    /// 
    ///     var withFacets = new NewRelic.AlertCompoundCondition("with_facets", new()
    ///     {
    ///         PolicyId = example.Id,
    ///         Name = "Host-Specific Alert",
    ///         Enabled = true,
    ///         TriggerExpression = "A AND B",
    ///         FacetMatchingBehavior = "FACETS_MATCH",
    ///         ComponentConditions = new[]
    ///         {
    ///             new NewRelic.Inputs.AlertCompoundConditionComponentConditionArgs
    ///             {
    ///                 Id = highThroughputPerHost.Id,
    ///                 Alias = "A",
    ///             },
    ///             new NewRelic.Inputs.AlertCompoundConditionComponentConditionArgs
    ///             {
    ///                 Id = highErrorRatePerHost.Id,
    ///                 Alias = "B",
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Additional Information
    /// 
    /// ### Understanding Trigger Expressions
    /// 
    /// Trigger expressions define the logical conditions under which your alert compound condition will activate. Valid operators are:
    /// 
    /// - **AND** - Both conditions must be true
    /// - **OR** - Either condition must be true
    /// - **NOT** - Negates a condition
    /// - **Parentheses** - Group conditions for complex logic
    /// 
    /// Examples:
    /// 
    /// - `"A AND B"` - Activate when both A and B are in violation
    /// - `"A OR B"` - Activate when either A or B is in violation
    /// - `"A AND NOT B"` - Activate when A is in violation but B is not
    /// - `"(A AND B) OR C"` - Activate when both A and B are in violation, OR when C is in violation
    /// - `"A AND (B OR C) AND NOT D"` - Activate when A is in violation AND either B or C is in violation AND D is not in violation
    /// 
    /// ### Facet Matching Behavior
    /// 
    /// When your component NRQL conditions use FACET clauses:
    /// 
    /// - **FACETS_IGNORED** (Default) - Facets are not taken into consideration when determining when the compound alert condition activates. If component conditions have violations (on any facet), the compound alert condition will activate based on the trigger expression.
    /// - **FACETS_MATCH** - The compound alert condition will activate only when shared facets have matching values. For example, if condition A fires for `host="server-1"` and condition B fires for `host="server-2"`, the compound alert condition will NOT activate because the facet values don't match.
    /// 
    /// ### Threshold Duration
    /// 
    /// The `ThresholdDuration` parameter controls how long the trigger expression must remain true before the compound alert condition will activate.
    /// 
    /// ## Import
    /// 
    /// Compound alert conditions can be imported using the condition ID, e.g.
    /// </summary>
    [NewRelicResourceType("newrelic:index/alertCompoundCondition:AlertCompoundCondition")]
    public partial class AlertCompoundCondition : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The New Relic account ID for managing your compound alert conditions. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
        /// </summary>
        [Output("accountId")]
        public Output<string> AccountId { get; private set; } = null!;

        /// <summary>
        /// The list of conditions to be combined. Each component condition must be enabled. Must include at least 2. See Component Conditions below for details.
        /// </summary>
        [Output("componentConditions")]
        public Output<ImmutableArray<Outputs.AlertCompoundConditionComponentCondition>> ComponentConditions { get; private set; } = null!;

        /// <summary>
        /// Whether or not the compound alert condition is enabled. Defaults to `True`.
        /// </summary>
        [Output("enabled")]
        public Output<bool> Enabled { get; private set; } = null!;

        /// <summary>
        /// How the compound condition will take into account the component conditions' facets during evaluation. Valid values are:
        /// - `FACETS_IGNORED` - (Default) Facets are not taken into consideration when determining when the compound alert condition activates
        /// - `FACETS_MATCH` - The compound alert condition will activate only when shared facets have matching values
        /// </summary>
        [Output("facetMatchingBehavior")]
        public Output<string> FacetMatchingBehavior { get; private set; } = null!;

        /// <summary>
        /// The title of the compound alert condition.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The ID of the policy where this alert compound condition should be used.
        /// </summary>
        [Output("policyId")]
        public Output<string> PolicyId { get; private set; } = null!;

        /// <summary>
        /// Runbook URL to display in notifications.
        /// </summary>
        [Output("runbookUrl")]
        public Output<string?> RunbookUrl { get; private set; } = null!;

        /// <summary>
        /// The duration, in seconds, that the trigger expression must be true before the compound alert condition will activate. Between 30-86400 seconds.
        /// </summary>
        [Output("thresholdDuration")]
        public Output<int> ThresholdDuration { get; private set; } = null!;

        /// <summary>
        /// Expression that defines how component condition evaluations are combined. Valid operators are 'AND', 'OR', 'NOT'. For more complex expressions, use parentheses. Use the aliases from `ComponentConditions` to build expressions like `"A AND B"`, `"A OR B"`, `"(A AND B) OR C"`, or `"A AND (B OR C) AND NOT (D AND E)"`.
        /// </summary>
        [Output("triggerExpression")]
        public Output<string> TriggerExpression { get; private set; } = null!;


        /// <summary>
        /// Create a AlertCompoundCondition resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public AlertCompoundCondition(string name, AlertCompoundConditionArgs args, CustomResourceOptions? options = null)
            : base("newrelic:index/alertCompoundCondition:AlertCompoundCondition", name, args ?? new AlertCompoundConditionArgs(), MakeResourceOptions(options, ""))
        {
        }

        private AlertCompoundCondition(string name, Input<string> id, AlertCompoundConditionState? state = null, CustomResourceOptions? options = null)
            : base("newrelic:index/alertCompoundCondition:AlertCompoundCondition", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing AlertCompoundCondition resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static AlertCompoundCondition Get(string name, Input<string> id, AlertCompoundConditionState? state = null, CustomResourceOptions? options = null)
        {
            return new AlertCompoundCondition(name, id, state, options);
        }
    }

    public sealed class AlertCompoundConditionArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The New Relic account ID for managing your compound alert conditions. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
        /// </summary>
        [Input("accountId")]
        public Input<string>? AccountId { get; set; }

        [Input("componentConditions", required: true)]
        private InputList<Inputs.AlertCompoundConditionComponentConditionArgs>? _componentConditions;

        /// <summary>
        /// The list of conditions to be combined. Each component condition must be enabled. Must include at least 2. See Component Conditions below for details.
        /// </summary>
        public InputList<Inputs.AlertCompoundConditionComponentConditionArgs> ComponentConditions
        {
            get => _componentConditions ?? (_componentConditions = new InputList<Inputs.AlertCompoundConditionComponentConditionArgs>());
            set => _componentConditions = value;
        }

        /// <summary>
        /// Whether or not the compound alert condition is enabled. Defaults to `True`.
        /// </summary>
        [Input("enabled", required: true)]
        public Input<bool> Enabled { get; set; } = null!;

        /// <summary>
        /// How the compound condition will take into account the component conditions' facets during evaluation. Valid values are:
        /// - `FACETS_IGNORED` - (Default) Facets are not taken into consideration when determining when the compound alert condition activates
        /// - `FACETS_MATCH` - The compound alert condition will activate only when shared facets have matching values
        /// </summary>
        [Input("facetMatchingBehavior")]
        public Input<string>? FacetMatchingBehavior { get; set; }

        /// <summary>
        /// The title of the compound alert condition.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The ID of the policy where this alert compound condition should be used.
        /// </summary>
        [Input("policyId", required: true)]
        public Input<string> PolicyId { get; set; } = null!;

        /// <summary>
        /// Runbook URL to display in notifications.
        /// </summary>
        [Input("runbookUrl")]
        public Input<string>? RunbookUrl { get; set; }

        /// <summary>
        /// The duration, in seconds, that the trigger expression must be true before the compound alert condition will activate. Between 30-86400 seconds.
        /// </summary>
        [Input("thresholdDuration")]
        public Input<int>? ThresholdDuration { get; set; }

        /// <summary>
        /// Expression that defines how component condition evaluations are combined. Valid operators are 'AND', 'OR', 'NOT'. For more complex expressions, use parentheses. Use the aliases from `ComponentConditions` to build expressions like `"A AND B"`, `"A OR B"`, `"(A AND B) OR C"`, or `"A AND (B OR C) AND NOT (D AND E)"`.
        /// </summary>
        [Input("triggerExpression", required: true)]
        public Input<string> TriggerExpression { get; set; } = null!;

        public AlertCompoundConditionArgs()
        {
        }
        public static new AlertCompoundConditionArgs Empty => new AlertCompoundConditionArgs();
    }

    public sealed class AlertCompoundConditionState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The New Relic account ID for managing your compound alert conditions. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
        /// </summary>
        [Input("accountId")]
        public Input<string>? AccountId { get; set; }

        [Input("componentConditions")]
        private InputList<Inputs.AlertCompoundConditionComponentConditionGetArgs>? _componentConditions;

        /// <summary>
        /// The list of conditions to be combined. Each component condition must be enabled. Must include at least 2. See Component Conditions below for details.
        /// </summary>
        public InputList<Inputs.AlertCompoundConditionComponentConditionGetArgs> ComponentConditions
        {
            get => _componentConditions ?? (_componentConditions = new InputList<Inputs.AlertCompoundConditionComponentConditionGetArgs>());
            set => _componentConditions = value;
        }

        /// <summary>
        /// Whether or not the compound alert condition is enabled. Defaults to `True`.
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// How the compound condition will take into account the component conditions' facets during evaluation. Valid values are:
        /// - `FACETS_IGNORED` - (Default) Facets are not taken into consideration when determining when the compound alert condition activates
        /// - `FACETS_MATCH` - The compound alert condition will activate only when shared facets have matching values
        /// </summary>
        [Input("facetMatchingBehavior")]
        public Input<string>? FacetMatchingBehavior { get; set; }

        /// <summary>
        /// The title of the compound alert condition.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The ID of the policy where this alert compound condition should be used.
        /// </summary>
        [Input("policyId")]
        public Input<string>? PolicyId { get; set; }

        /// <summary>
        /// Runbook URL to display in notifications.
        /// </summary>
        [Input("runbookUrl")]
        public Input<string>? RunbookUrl { get; set; }

        /// <summary>
        /// The duration, in seconds, that the trigger expression must be true before the compound alert condition will activate. Between 30-86400 seconds.
        /// </summary>
        [Input("thresholdDuration")]
        public Input<int>? ThresholdDuration { get; set; }

        /// <summary>
        /// Expression that defines how component condition evaluations are combined. Valid operators are 'AND', 'OR', 'NOT'. For more complex expressions, use parentheses. Use the aliases from `ComponentConditions` to build expressions like `"A AND B"`, `"A OR B"`, `"(A AND B) OR C"`, or `"A AND (B OR C) AND NOT (D AND E)"`.
        /// </summary>
        [Input("triggerExpression")]
        public Input<string>? TriggerExpression { get; set; }

        public AlertCompoundConditionState()
        {
        }
        public static new AlertCompoundConditionState Empty => new AlertCompoundConditionState();
    }
}
