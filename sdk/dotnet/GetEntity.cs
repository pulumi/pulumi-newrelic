// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.NewRelic
{
    public static class GetEntity
    {
        /// <summary>
        /// Use this data source to get information about a specific entity in New Relic One that already exists.
        /// 
        /// ### Example: Filter By Account ID
        /// 
        /// The default behaviour of this data source is to retrieve entities matching the specified parameters (such as `name`, `domain`, `type`) from NerdGraph with the credentials specified in the configuration of the provider (account ID and API Key), filter them by the account ID specified in the configuration of the provider, and return the first match. 
        /// 
        /// This would mean, if no entity with the specified search parameters is found associated with the account ID in the configuration of the provider, i.e. `NEW_RELIC_ACCOUNT_ID`, an error is thrown, stating that no matching entity has been found.
        /// 
        /// &lt;!--Start PulumiCodeChooser --&gt;
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// using NewRelic = Pulumi.NewRelic;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     // The entity returned by this configuration would have to 
        ///     // belong to the account_id specified in the provider 
        ///     // configuration, i.e. NEW_RELIC_ACCOUNT_ID.
        ///     var app = NewRelic.GetEntity.Invoke(new()
        ///     {
        ///         Name = "my-app",
        ///         Domain = "APM",
        ///         Type = "APPLICATION",
        ///     });
        /// 
        /// });
        /// ```
        /// &lt;!--End PulumiCodeChooser --&gt;
        /// However, in order to cater to scenarios in which it could be necessary to retrieve an entity belonging to a subaccount using the account ID and API Key of the parent account (for instance, when entities with identical names are present in both the parent account and subaccounts, since matching entities from subaccounts too are returned by NerdGraph), the `account_id` attribute of this data source may be availed. This ensures that the account ID in the configuration of the provider, used to filter entities returned by the API is now overridden by the `account_id` specified in the configuration; i.e., in the below example, the data source would now return an entity matching the specified `name`, belonging to the account with the ID `account_id`.
        /// &lt;!--Start PulumiCodeChooser --&gt;
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// using NewRelic = Pulumi.NewRelic;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     // The entity returned by this configuration, unlike in 
        ///     // the above example, would have to belong to the account_id 
        ///     // specified in the configuration below, i.e. 654321.
        ///     var app = NewRelic.GetEntity.Invoke(new()
        ///     {
        ///         Name = "my-app",
        ///         AccountId = 654321,
        ///         Domain = "APM",
        ///         Type = "APPLICATION",
        ///     });
        /// 
        /// });
        /// ```
        /// &lt;!--End PulumiCodeChooser --&gt;
        /// The following example explains a use case along the lines of the aforementioned; using the `account_id` argument in the data source to allow the filtering criteria to be the `account_id` specified (of the subaccount), and not the account ID in the provider configuration. 
        /// 
        /// In simpler terms, when entities are queried from the parent account, entities with matching names are returned from subaccounts too, hence, specifying the `account_id` of the subaccount in the configuration allows the entity returned to belong to the subaccount with `account_id`.
        /// ### Query for an OTEL entity
        /// 
        /// &lt;!--Start PulumiCodeChooser --&gt;
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// using NewRelic = Pulumi.NewRelic;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     var app = NewRelic.GetEntity.Invoke(new()
        ///     {
        ///         Name = "my-otel-app",
        ///         Domain = "EXT",
        ///         Type = "SERVICE",
        ///         Tags = new[]
        ///         {
        ///             new NewRelic.Inputs.GetEntityTagInputArgs
        ///             {
        ///                 Key = "accountID",
        ///                 Value = "12345",
        ///             },
        ///         },
        ///     });
        /// 
        /// });
        /// ```
        /// &lt;!--End PulumiCodeChooser --&gt;
        /// 
        /// ### Query for an entity by type (AWS Lambda entity in this example)
        /// 
        /// &lt;!--Start PulumiCodeChooser --&gt;
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// using NewRelic = Pulumi.NewRelic;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     var app = NewRelic.GetEntity.Invoke(new()
        ///     {
        ///         Name = "my_lambda_trace",
        ///         Type = "AWSLAMBDAFUNCTION",
        ///     });
        /// 
        /// });
        /// ```
        /// &lt;!--End PulumiCodeChooser --&gt;
        /// </summary>
        public static Task<GetEntityResult> InvokeAsync(GetEntityArgs args, InvokeOptions? options = null)
            => global::Pulumi.Deployment.Instance.InvokeAsync<GetEntityResult>("newrelic:index/getEntity:getEntity", args ?? new GetEntityArgs(), options.WithDefaults());

        /// <summary>
        /// Use this data source to get information about a specific entity in New Relic One that already exists.
        /// 
        /// ### Example: Filter By Account ID
        /// 
        /// The default behaviour of this data source is to retrieve entities matching the specified parameters (such as `name`, `domain`, `type`) from NerdGraph with the credentials specified in the configuration of the provider (account ID and API Key), filter them by the account ID specified in the configuration of the provider, and return the first match. 
        /// 
        /// This would mean, if no entity with the specified search parameters is found associated with the account ID in the configuration of the provider, i.e. `NEW_RELIC_ACCOUNT_ID`, an error is thrown, stating that no matching entity has been found.
        /// 
        /// &lt;!--Start PulumiCodeChooser --&gt;
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// using NewRelic = Pulumi.NewRelic;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     // The entity returned by this configuration would have to 
        ///     // belong to the account_id specified in the provider 
        ///     // configuration, i.e. NEW_RELIC_ACCOUNT_ID.
        ///     var app = NewRelic.GetEntity.Invoke(new()
        ///     {
        ///         Name = "my-app",
        ///         Domain = "APM",
        ///         Type = "APPLICATION",
        ///     });
        /// 
        /// });
        /// ```
        /// &lt;!--End PulumiCodeChooser --&gt;
        /// However, in order to cater to scenarios in which it could be necessary to retrieve an entity belonging to a subaccount using the account ID and API Key of the parent account (for instance, when entities with identical names are present in both the parent account and subaccounts, since matching entities from subaccounts too are returned by NerdGraph), the `account_id` attribute of this data source may be availed. This ensures that the account ID in the configuration of the provider, used to filter entities returned by the API is now overridden by the `account_id` specified in the configuration; i.e., in the below example, the data source would now return an entity matching the specified `name`, belonging to the account with the ID `account_id`.
        /// &lt;!--Start PulumiCodeChooser --&gt;
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// using NewRelic = Pulumi.NewRelic;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     // The entity returned by this configuration, unlike in 
        ///     // the above example, would have to belong to the account_id 
        ///     // specified in the configuration below, i.e. 654321.
        ///     var app = NewRelic.GetEntity.Invoke(new()
        ///     {
        ///         Name = "my-app",
        ///         AccountId = 654321,
        ///         Domain = "APM",
        ///         Type = "APPLICATION",
        ///     });
        /// 
        /// });
        /// ```
        /// &lt;!--End PulumiCodeChooser --&gt;
        /// The following example explains a use case along the lines of the aforementioned; using the `account_id` argument in the data source to allow the filtering criteria to be the `account_id` specified (of the subaccount), and not the account ID in the provider configuration. 
        /// 
        /// In simpler terms, when entities are queried from the parent account, entities with matching names are returned from subaccounts too, hence, specifying the `account_id` of the subaccount in the configuration allows the entity returned to belong to the subaccount with `account_id`.
        /// ### Query for an OTEL entity
        /// 
        /// &lt;!--Start PulumiCodeChooser --&gt;
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// using NewRelic = Pulumi.NewRelic;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     var app = NewRelic.GetEntity.Invoke(new()
        ///     {
        ///         Name = "my-otel-app",
        ///         Domain = "EXT",
        ///         Type = "SERVICE",
        ///         Tags = new[]
        ///         {
        ///             new NewRelic.Inputs.GetEntityTagInputArgs
        ///             {
        ///                 Key = "accountID",
        ///                 Value = "12345",
        ///             },
        ///         },
        ///     });
        /// 
        /// });
        /// ```
        /// &lt;!--End PulumiCodeChooser --&gt;
        /// 
        /// ### Query for an entity by type (AWS Lambda entity in this example)
        /// 
        /// &lt;!--Start PulumiCodeChooser --&gt;
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// using NewRelic = Pulumi.NewRelic;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     var app = NewRelic.GetEntity.Invoke(new()
        ///     {
        ///         Name = "my_lambda_trace",
        ///         Type = "AWSLAMBDAFUNCTION",
        ///     });
        /// 
        /// });
        /// ```
        /// &lt;!--End PulumiCodeChooser --&gt;
        /// </summary>
        public static Output<GetEntityResult> Invoke(GetEntityInvokeArgs args, InvokeOptions? options = null)
            => global::Pulumi.Deployment.Instance.Invoke<GetEntityResult>("newrelic:index/getEntity:getEntity", args ?? new GetEntityInvokeArgs(), options.WithDefaults());
    }


    public sealed class GetEntityArgs : global::Pulumi.InvokeArgs
    {
        /// <summary>
        /// The New Relic account ID the entity to be returned would be associated with, i.e. if specified, the data source would filter matching entities received by `account_id` and return the first match. If not, matching entities are filtered by the account ID specified in the configuration of the provider. See the **Example: Filter By Account ID** section above for more details.
        /// </summary>
        [Input("accountId")]
        public int? AccountId { get; set; }

        /// <summary>
        /// The entity's domain. Valid values are APM, BROWSER, INFRA, MOBILE, SYNTH, and EXT. If not specified, all domains are searched.
        /// </summary>
        [Input("domain")]
        public string? Domain { get; set; }

        /// <summary>
        /// Ignore case of the `name` when searching for the entity. Defaults to false.
        /// </summary>
        [Input("ignoreCase")]
        public bool? IgnoreCase { get; set; }

        /// <summary>
        /// A boolean argument that, when set to true, prevents an error from being thrown when the queried entity is not found. Instead, a warning is displayed. Defaults to `false`.
        /// 
        /// &gt; **WARNING:** Setting the `ignore_not_found` argument to `true` will display an 'entity not found' warning instead of throwing an error. This can lead to downstream errors if the values of attributes exported by this data source are used elsewhere, as all of these values would be null. Please use this argument at your own risk.
        /// </summary>
        [Input("ignoreNotFound")]
        public bool? IgnoreNotFound { get; set; }

        /// <summary>
        /// The name of the entity in New Relic One.  The first entity matching this name for the given search parameters will be returned.
        /// </summary>
        [Input("name", required: true)]
        public string Name { get; set; } = null!;

        [Input("tags")]
        private List<Inputs.GetEntityTagArgs>? _tags;

        /// <summary>
        /// A tag applied to the entity. See Nested tag blocks below for details.
        /// </summary>
        public List<Inputs.GetEntityTagArgs> Tags
        {
            get => _tags ?? (_tags = new List<Inputs.GetEntityTagArgs>());
            set => _tags = value;
        }

        /// <summary>
        /// The entity's type. Valid values are APPLICATION, DASHBOARD, HOST, MONITOR, WORKLOAD, AWSLAMBDAFUNCTION, SERVICE_LEVEL, and KEY_TRANSACTION. Note: Other entity types may also be queryable as the list of entity types may fluctuate over time.
        /// </summary>
        [Input("type")]
        public string? Type { get; set; }

        public GetEntityArgs()
        {
        }
        public static new GetEntityArgs Empty => new GetEntityArgs();
    }

    public sealed class GetEntityInvokeArgs : global::Pulumi.InvokeArgs
    {
        /// <summary>
        /// The New Relic account ID the entity to be returned would be associated with, i.e. if specified, the data source would filter matching entities received by `account_id` and return the first match. If not, matching entities are filtered by the account ID specified in the configuration of the provider. See the **Example: Filter By Account ID** section above for more details.
        /// </summary>
        [Input("accountId")]
        public Input<int>? AccountId { get; set; }

        /// <summary>
        /// The entity's domain. Valid values are APM, BROWSER, INFRA, MOBILE, SYNTH, and EXT. If not specified, all domains are searched.
        /// </summary>
        [Input("domain")]
        public Input<string>? Domain { get; set; }

        /// <summary>
        /// Ignore case of the `name` when searching for the entity. Defaults to false.
        /// </summary>
        [Input("ignoreCase")]
        public Input<bool>? IgnoreCase { get; set; }

        /// <summary>
        /// A boolean argument that, when set to true, prevents an error from being thrown when the queried entity is not found. Instead, a warning is displayed. Defaults to `false`.
        /// 
        /// &gt; **WARNING:** Setting the `ignore_not_found` argument to `true` will display an 'entity not found' warning instead of throwing an error. This can lead to downstream errors if the values of attributes exported by this data source are used elsewhere, as all of these values would be null. Please use this argument at your own risk.
        /// </summary>
        [Input("ignoreNotFound")]
        public Input<bool>? IgnoreNotFound { get; set; }

        /// <summary>
        /// The name of the entity in New Relic One.  The first entity matching this name for the given search parameters will be returned.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        [Input("tags")]
        private InputList<Inputs.GetEntityTagInputArgs>? _tags;

        /// <summary>
        /// A tag applied to the entity. See Nested tag blocks below for details.
        /// </summary>
        public InputList<Inputs.GetEntityTagInputArgs> Tags
        {
            get => _tags ?? (_tags = new InputList<Inputs.GetEntityTagInputArgs>());
            set => _tags = value;
        }

        /// <summary>
        /// The entity's type. Valid values are APPLICATION, DASHBOARD, HOST, MONITOR, WORKLOAD, AWSLAMBDAFUNCTION, SERVICE_LEVEL, and KEY_TRANSACTION. Note: Other entity types may also be queryable as the list of entity types may fluctuate over time.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

        public GetEntityInvokeArgs()
        {
        }
        public static new GetEntityInvokeArgs Empty => new GetEntityInvokeArgs();
    }


    [OutputType]
    public sealed class GetEntityResult
    {
        public readonly int AccountId;
        /// <summary>
        /// The domain-specific application ID of the entity. Only returned for APM and Browser applications.
        /// </summary>
        public readonly int ApplicationId;
        public readonly string Domain;
        /// <summary>
        /// The unique GUID of the entity.
        /// </summary>
        public readonly string Guid;
        /// <summary>
        /// The provider-assigned unique ID for this managed resource.
        /// </summary>
        public readonly string Id;
        public readonly bool? IgnoreCase;
        public readonly bool? IgnoreNotFound;
        public readonly string Name;
        /// <summary>
        /// The browser-specific ID of the backing APM entity. Only returned for Browser applications.
        /// </summary>
        public readonly int ServingApmApplicationId;
        public readonly ImmutableArray<Outputs.GetEntityTagResult> Tags;
        public readonly string Type;

        [OutputConstructor]
        private GetEntityResult(
            int accountId,

            int applicationId,

            string domain,

            string guid,

            string id,

            bool? ignoreCase,

            bool? ignoreNotFound,

            string name,

            int servingApmApplicationId,

            ImmutableArray<Outputs.GetEntityTagResult> tags,

            string type)
        {
            AccountId = accountId;
            ApplicationId = applicationId;
            Domain = domain;
            Guid = guid;
            Id = id;
            IgnoreCase = ignoreCase;
            IgnoreNotFound = ignoreNotFound;
            Name = name;
            ServingApmApplicationId = servingApmApplicationId;
            Tags = tags;
            Type = type;
        }
    }
}
