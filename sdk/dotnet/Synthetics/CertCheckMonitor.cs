// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.NewRelic.Synthetics
{
    /// <summary>
    /// Use this resource to create, update, and delete a Synthetics Certificate Check monitor in New Relic.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using NewRelic = Pulumi.NewRelic;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var foo = new NewRelic.Synthetics.CertCheckMonitor("foo", new()
    ///     {
    ///         Name = "Sample Cert Check Monitor",
    ///         Domain = "www.example.com",
    ///         LocationsPublics = new[]
    ///         {
    ///             "AP_SOUTH_1",
    ///         },
    ///         CertificateExpiration = 10,
    ///         Period = "EVERY_6_HOURS",
    ///         Status = "ENABLED",
    ///         RuntimeType = "NODE_API",
    ///         RuntimeTypeVersion = "16.10",
    ///         Tags = new[]
    ///         {
    ///             new NewRelic.Synthetics.Inputs.CertCheckMonitorTagArgs
    ///             {
    ///                 Key = "some_key",
    ///                 Values = new[]
    ///                 {
    ///                     "some_value",
    ///                 },
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// See additional examples.
    /// 
    /// ## Additional Examples
    /// 
    /// ### Create a monitor with a private location
    /// 
    /// The below example shows how you can define a private location and attach it to a monitor.
    /// 
    /// &gt; **NOTE:** It can take up to 10 minutes for a private location to become available.
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using NewRelic = Pulumi.NewRelic;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var foo = new NewRelic.Synthetics.PrivateLocation("foo", new()
    ///     {
    ///         Name = "Sample Private Location",
    ///         Description = "Sample Private Location Description",
    ///         VerifiedScriptExecution = false,
    ///     });
    /// 
    ///     var fooCertCheckMonitor = new NewRelic.Synthetics.CertCheckMonitor("foo", new()
    ///     {
    ///         Name = "Sample Cert Check Monitor",
    ///         Domain = "www.one.example.com",
    ///         LocationsPrivates = new[]
    ///         {
    ///             foo.Id,
    ///         },
    ///         CertificateExpiration = 10,
    ///         Period = "EVERY_6_HOURS",
    ///         Status = "ENABLED",
    ///         Tags = new[]
    ///         {
    ///             new NewRelic.Synthetics.Inputs.CertCheckMonitorTagArgs
    ///             {
    ///                 Key = "some_key",
    ///                 Values = new[]
    ///                 {
    ///                     "some_value",
    ///                 },
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// A cert check monitor can be imported using its GUID, using the following command.
    /// 
    /// bash
    /// 
    /// ```sh
    /// $ pulumi import newrelic:synthetics/certCheckMonitor:CertCheckMonitor monitor &lt;guid&gt;
    /// ```
    /// </summary>
    [NewRelicResourceType("newrelic:synthetics/certCheckMonitor:CertCheckMonitor")]
    public partial class CertCheckMonitor : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The account in which the Synthetics monitor will be created.
        /// </summary>
        [Output("accountId")]
        public Output<string> AccountId { get; private set; } = null!;

        /// <summary>
        /// The desired number of remaining days until the certificate expires to trigger a monitor failure.
        /// </summary>
        [Output("certificateExpiration")]
        public Output<int> CertificateExpiration { get; private set; } = null!;

        /// <summary>
        /// The domain of the host that will have its certificate checked.
        /// </summary>
        [Output("domain")]
        public Output<string> Domain { get; private set; } = null!;

        /// <summary>
        /// The location the monitor will run from. Accepts a list of private location GUIDs. At least one of either `locations_public` or `locations_private` is required.
        /// </summary>
        [Output("locationsPrivates")]
        public Output<ImmutableArray<string>> LocationsPrivates { get; private set; } = null!;

        /// <summary>
        /// The location the monitor will run from. Valid public locations are https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/synthetic-public-minion-ips/. You don't need the `AWS_` prefix as the provider uses NerdGraph. At least one of either `locations_public` or `location_private` is required.
        /// </summary>
        [Output("locationsPublics")]
        public Output<ImmutableArray<string>> LocationsPublics { get; private set; } = null!;

        /// <summary>
        /// The name for the monitor.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The interval at which this monitor should run. Valid values are EVERY_MINUTE, EVERY_5_MINUTES, EVERY_10_MINUTES, EVERY_15_MINUTES, EVERY_30_MINUTES, EVERY_HOUR, EVERY_6_HOURS, EVERY_12_HOURS, or EVERY_DAY.
        /// </summary>
        [Output("period")]
        public Output<string> Period { get; private set; } = null!;

        /// <summary>
        /// The interval in minutes at which Synthetic monitor should run.
        /// </summary>
        [Output("periodInMinutes")]
        public Output<int> PeriodInMinutes { get; private set; } = null!;

        /// <summary>
        /// The runtime that the monitor will use to run jobs.
        /// </summary>
        [Output("runtimeType")]
        public Output<string?> RuntimeType { get; private set; } = null!;

        /// <summary>
        /// The specific version of the runtime type selected.
        /// 
        /// &gt; **NOTE:** Currently, the values of `runtime_type` and `runtime_type_version` supported by this resource are `NODE_API` and `16.10` respectively. In order to run the monitor in the new runtime, both `runtime_type` and `runtime_type_version` need to be specified; however, specifying neither of these attributes would set this monitor to use the legacy runtime. It may also be noted that the runtime opted for would only be effective with private locations. For public locations, all traffic has been shifted to the new runtime, irrespective of the selection made.
        /// </summary>
        [Output("runtimeTypeVersion")]
        public Output<string?> RuntimeTypeVersion { get; private set; } = null!;

        /// <summary>
        /// The monitor status (ENABLED or DISABLED).
        /// </summary>
        [Output("status")]
        public Output<string> Status { get; private set; } = null!;

        /// <summary>
        /// The tags that will be associated with the monitor. See Nested tag blocks below for details
        /// </summary>
        [Output("tags")]
        public Output<ImmutableArray<Outputs.CertCheckMonitorTag>> Tags { get; private set; } = null!;


        /// <summary>
        /// Create a CertCheckMonitor resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public CertCheckMonitor(string name, CertCheckMonitorArgs args, CustomResourceOptions? options = null)
            : base("newrelic:synthetics/certCheckMonitor:CertCheckMonitor", name, args ?? new CertCheckMonitorArgs(), MakeResourceOptions(options, ""))
        {
        }

        private CertCheckMonitor(string name, Input<string> id, CertCheckMonitorState? state = null, CustomResourceOptions? options = null)
            : base("newrelic:synthetics/certCheckMonitor:CertCheckMonitor", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing CertCheckMonitor resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static CertCheckMonitor Get(string name, Input<string> id, CertCheckMonitorState? state = null, CustomResourceOptions? options = null)
        {
            return new CertCheckMonitor(name, id, state, options);
        }
    }

    public sealed class CertCheckMonitorArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The account in which the Synthetics monitor will be created.
        /// </summary>
        [Input("accountId")]
        public Input<string>? AccountId { get; set; }

        /// <summary>
        /// The desired number of remaining days until the certificate expires to trigger a monitor failure.
        /// </summary>
        [Input("certificateExpiration", required: true)]
        public Input<int> CertificateExpiration { get; set; } = null!;

        /// <summary>
        /// The domain of the host that will have its certificate checked.
        /// </summary>
        [Input("domain", required: true)]
        public Input<string> Domain { get; set; } = null!;

        [Input("locationsPrivates")]
        private InputList<string>? _locationsPrivates;

        /// <summary>
        /// The location the monitor will run from. Accepts a list of private location GUIDs. At least one of either `locations_public` or `locations_private` is required.
        /// </summary>
        public InputList<string> LocationsPrivates
        {
            get => _locationsPrivates ?? (_locationsPrivates = new InputList<string>());
            set => _locationsPrivates = value;
        }

        [Input("locationsPublics")]
        private InputList<string>? _locationsPublics;

        /// <summary>
        /// The location the monitor will run from. Valid public locations are https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/synthetic-public-minion-ips/. You don't need the `AWS_` prefix as the provider uses NerdGraph. At least one of either `locations_public` or `location_private` is required.
        /// </summary>
        public InputList<string> LocationsPublics
        {
            get => _locationsPublics ?? (_locationsPublics = new InputList<string>());
            set => _locationsPublics = value;
        }

        /// <summary>
        /// The name for the monitor.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The interval at which this monitor should run. Valid values are EVERY_MINUTE, EVERY_5_MINUTES, EVERY_10_MINUTES, EVERY_15_MINUTES, EVERY_30_MINUTES, EVERY_HOUR, EVERY_6_HOURS, EVERY_12_HOURS, or EVERY_DAY.
        /// </summary>
        [Input("period", required: true)]
        public Input<string> Period { get; set; } = null!;

        /// <summary>
        /// The runtime that the monitor will use to run jobs.
        /// </summary>
        [Input("runtimeType")]
        public Input<string>? RuntimeType { get; set; }

        /// <summary>
        /// The specific version of the runtime type selected.
        /// 
        /// &gt; **NOTE:** Currently, the values of `runtime_type` and `runtime_type_version` supported by this resource are `NODE_API` and `16.10` respectively. In order to run the monitor in the new runtime, both `runtime_type` and `runtime_type_version` need to be specified; however, specifying neither of these attributes would set this monitor to use the legacy runtime. It may also be noted that the runtime opted for would only be effective with private locations. For public locations, all traffic has been shifted to the new runtime, irrespective of the selection made.
        /// </summary>
        [Input("runtimeTypeVersion")]
        public Input<string>? RuntimeTypeVersion { get; set; }

        /// <summary>
        /// The monitor status (ENABLED or DISABLED).
        /// </summary>
        [Input("status", required: true)]
        public Input<string> Status { get; set; } = null!;

        [Input("tags")]
        private InputList<Inputs.CertCheckMonitorTagArgs>? _tags;

        /// <summary>
        /// The tags that will be associated with the monitor. See Nested tag blocks below for details
        /// </summary>
        public InputList<Inputs.CertCheckMonitorTagArgs> Tags
        {
            get => _tags ?? (_tags = new InputList<Inputs.CertCheckMonitorTagArgs>());
            set => _tags = value;
        }

        public CertCheckMonitorArgs()
        {
        }
        public static new CertCheckMonitorArgs Empty => new CertCheckMonitorArgs();
    }

    public sealed class CertCheckMonitorState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The account in which the Synthetics monitor will be created.
        /// </summary>
        [Input("accountId")]
        public Input<string>? AccountId { get; set; }

        /// <summary>
        /// The desired number of remaining days until the certificate expires to trigger a monitor failure.
        /// </summary>
        [Input("certificateExpiration")]
        public Input<int>? CertificateExpiration { get; set; }

        /// <summary>
        /// The domain of the host that will have its certificate checked.
        /// </summary>
        [Input("domain")]
        public Input<string>? Domain { get; set; }

        [Input("locationsPrivates")]
        private InputList<string>? _locationsPrivates;

        /// <summary>
        /// The location the monitor will run from. Accepts a list of private location GUIDs. At least one of either `locations_public` or `locations_private` is required.
        /// </summary>
        public InputList<string> LocationsPrivates
        {
            get => _locationsPrivates ?? (_locationsPrivates = new InputList<string>());
            set => _locationsPrivates = value;
        }

        [Input("locationsPublics")]
        private InputList<string>? _locationsPublics;

        /// <summary>
        /// The location the monitor will run from. Valid public locations are https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/synthetic-public-minion-ips/. You don't need the `AWS_` prefix as the provider uses NerdGraph. At least one of either `locations_public` or `location_private` is required.
        /// </summary>
        public InputList<string> LocationsPublics
        {
            get => _locationsPublics ?? (_locationsPublics = new InputList<string>());
            set => _locationsPublics = value;
        }

        /// <summary>
        /// The name for the monitor.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The interval at which this monitor should run. Valid values are EVERY_MINUTE, EVERY_5_MINUTES, EVERY_10_MINUTES, EVERY_15_MINUTES, EVERY_30_MINUTES, EVERY_HOUR, EVERY_6_HOURS, EVERY_12_HOURS, or EVERY_DAY.
        /// </summary>
        [Input("period")]
        public Input<string>? Period { get; set; }

        /// <summary>
        /// The interval in minutes at which Synthetic monitor should run.
        /// </summary>
        [Input("periodInMinutes")]
        public Input<int>? PeriodInMinutes { get; set; }

        /// <summary>
        /// The runtime that the monitor will use to run jobs.
        /// </summary>
        [Input("runtimeType")]
        public Input<string>? RuntimeType { get; set; }

        /// <summary>
        /// The specific version of the runtime type selected.
        /// 
        /// &gt; **NOTE:** Currently, the values of `runtime_type` and `runtime_type_version` supported by this resource are `NODE_API` and `16.10` respectively. In order to run the monitor in the new runtime, both `runtime_type` and `runtime_type_version` need to be specified; however, specifying neither of these attributes would set this monitor to use the legacy runtime. It may also be noted that the runtime opted for would only be effective with private locations. For public locations, all traffic has been shifted to the new runtime, irrespective of the selection made.
        /// </summary>
        [Input("runtimeTypeVersion")]
        public Input<string>? RuntimeTypeVersion { get; set; }

        /// <summary>
        /// The monitor status (ENABLED or DISABLED).
        /// </summary>
        [Input("status")]
        public Input<string>? Status { get; set; }

        [Input("tags")]
        private InputList<Inputs.CertCheckMonitorTagGetArgs>? _tags;

        /// <summary>
        /// The tags that will be associated with the monitor. See Nested tag blocks below for details
        /// </summary>
        public InputList<Inputs.CertCheckMonitorTagGetArgs> Tags
        {
            get => _tags ?? (_tags = new InputList<Inputs.CertCheckMonitorTagGetArgs>());
            set => _tags = value;
        }

        public CertCheckMonitorState()
        {
        }
        public static new CertCheckMonitorState Empty => new CertCheckMonitorState();
    }
}
