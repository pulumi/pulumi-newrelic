// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.newrelic.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.newrelic.inputs.NrqlAlertConditionCriticalArgs;
import com.pulumi.newrelic.inputs.NrqlAlertConditionNrqlArgs;
import com.pulumi.newrelic.inputs.NrqlAlertConditionTermArgs;
import com.pulumi.newrelic.inputs.NrqlAlertConditionWarningArgs;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class NrqlAlertConditionState extends com.pulumi.resources.ResourceArgs {

    public static final NrqlAlertConditionState Empty = new NrqlAlertConditionState();

    /**
     * The New Relic account ID of the account you wish to create the condition. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
     * 
     */
    @Import(name="accountId")
    private @Nullable Output<String> accountId;

    /**
     * @return The New Relic account ID of the account you wish to create the condition. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
     * 
     */
    public Optional<Output<String>> accountId() {
        return Optional.ofNullable(this.accountId);
    }

    /**
     * How long we wait for data that belongs in each aggregation window. Depending on your data, a longer delay may increase accuracy but delay notifications. Use `aggregation_delay` with the `event_flow` and `cadence` methods. The maximum delay is 1200 seconds (20 minutes) when using `event_flow` and 3600 seconds (60 minutes) when using `cadence`. In both cases, the minimum delay is 0 seconds and the default is 120 seconds. `aggregation_delay` cannot be set with `nrql.evaluation_offset`.
     * 
     */
    @Import(name="aggregationDelay")
    private @Nullable Output<String> aggregationDelay;

    /**
     * @return How long we wait for data that belongs in each aggregation window. Depending on your data, a longer delay may increase accuracy but delay notifications. Use `aggregation_delay` with the `event_flow` and `cadence` methods. The maximum delay is 1200 seconds (20 minutes) when using `event_flow` and 3600 seconds (60 minutes) when using `cadence`. In both cases, the minimum delay is 0 seconds and the default is 120 seconds. `aggregation_delay` cannot be set with `nrql.evaluation_offset`.
     * 
     */
    public Optional<Output<String>> aggregationDelay() {
        return Optional.ofNullable(this.aggregationDelay);
    }

    /**
     * Determines when we consider an aggregation window to be complete so that we can evaluate the signal for incidents. Possible values are `cadence`, `event_flow` or `event_timer`. Default is `event_flow`. `aggregation_method` cannot be set with `nrql.evaluation_offset`.
     * 
     */
    @Import(name="aggregationMethod")
    private @Nullable Output<String> aggregationMethod;

    /**
     * @return Determines when we consider an aggregation window to be complete so that we can evaluate the signal for incidents. Possible values are `cadence`, `event_flow` or `event_timer`. Default is `event_flow`. `aggregation_method` cannot be set with `nrql.evaluation_offset`.
     * 
     */
    public Optional<Output<String>> aggregationMethod() {
        return Optional.ofNullable(this.aggregationMethod);
    }

    /**
     * How long we wait after each data point arrives to make sure we&#39;ve processed the whole batch. Use `aggregation_timer` with the `event_timer` method. The timer value can range from 0 seconds to 1200 seconds (20 minutes); the default is 60 seconds. `aggregation_timer` cannot be set with `nrql.evaluation_offset`.
     * 
     */
    @Import(name="aggregationTimer")
    private @Nullable Output<String> aggregationTimer;

    /**
     * @return How long we wait after each data point arrives to make sure we&#39;ve processed the whole batch. Use `aggregation_timer` with the `event_timer` method. The timer value can range from 0 seconds to 1200 seconds (20 minutes); the default is 60 seconds. `aggregation_timer` cannot be set with `nrql.evaluation_offset`.
     * 
     */
    public Optional<Output<String>> aggregationTimer() {
        return Optional.ofNullable(this.aggregationTimer);
    }

    /**
     * The duration of the time window used to evaluate the NRQL query, in seconds. The value must be at least 30 seconds, and no more than 21600 seconds (6 hours). Default is 60 seconds.
     * 
     */
    @Import(name="aggregationWindow")
    private @Nullable Output<Integer> aggregationWindow;

    /**
     * @return The duration of the time window used to evaluate the NRQL query, in seconds. The value must be at least 30 seconds, and no more than 21600 seconds (6 hours). Default is 60 seconds.
     * 
     */
    public Optional<Output<Integer>> aggregationWindow() {
        return Optional.ofNullable(this.aggregationWindow);
    }

    /**
     * The baseline direction of a _baseline_ NRQL alert condition. Valid values are: `lower_only`, `upper_and_lower`, `upper_only` (case insensitive).
     * 
     */
    @Import(name="baselineDirection")
    private @Nullable Output<String> baselineDirection;

    /**
     * @return The baseline direction of a _baseline_ NRQL alert condition. Valid values are: `lower_only`, `upper_and_lower`, `upper_only` (case insensitive).
     * 
     */
    public Optional<Output<String>> baselineDirection() {
        return Optional.ofNullable(this.baselineDirection);
    }

    /**
     * Whether to close all open incidents when the signal expires.
     * 
     */
    @Import(name="closeViolationsOnExpiration")
    private @Nullable Output<Boolean> closeViolationsOnExpiration;

    /**
     * @return Whether to close all open incidents when the signal expires.
     * 
     */
    public Optional<Output<Boolean>> closeViolationsOnExpiration() {
        return Optional.ofNullable(this.closeViolationsOnExpiration);
    }

    /**
     * A list containing the `critical` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
     * 
     */
    @Import(name="critical")
    private @Nullable Output<NrqlAlertConditionCriticalArgs> critical;

    /**
     * @return A list containing the `critical` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
     * 
     */
    public Optional<Output<NrqlAlertConditionCriticalArgs>> critical() {
        return Optional.ofNullable(this.critical);
    }

    /**
     * The description of the NRQL alert condition.
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return The description of the NRQL alert condition.
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * Whether to enable the alert condition. Valid values are `true` and `false`. Defaults to `true`.
     * 
     */
    @Import(name="enabled")
    private @Nullable Output<Boolean> enabled;

    /**
     * @return Whether to enable the alert condition. Valid values are `true` and `false`. Defaults to `true`.
     * 
     */
    public Optional<Output<Boolean>> enabled() {
        return Optional.ofNullable(this.enabled);
    }

    /**
     * The unique entity identifier of the NRQL Condition in New Relic.
     * 
     */
    @Import(name="entityGuid")
    private @Nullable Output<String> entityGuid;

    /**
     * @return The unique entity identifier of the NRQL Condition in New Relic.
     * 
     */
    public Optional<Output<String>> entityGuid() {
        return Optional.ofNullable(this.entityGuid);
    }

    /**
     * How long we wait until the signal starts evaluating. The maximum delay is 7200 seconds (120 minutes).
     * 
     */
    @Import(name="evaluationDelay")
    private @Nullable Output<Integer> evaluationDelay;

    /**
     * @return How long we wait until the signal starts evaluating. The maximum delay is 7200 seconds (120 minutes).
     * 
     */
    public Optional<Output<Integer>> evaluationDelay() {
        return Optional.ofNullable(this.evaluationDelay);
    }

    /**
     * The amount of time (in seconds) to wait before considering the signal expired. The value must be at least 30 seconds, and no more than 172800 seconds (48 hours).
     * 
     */
    @Import(name="expirationDuration")
    private @Nullable Output<Integer> expirationDuration;

    /**
     * @return The amount of time (in seconds) to wait before considering the signal expired. The value must be at least 30 seconds, and no more than 172800 seconds (48 hours).
     * 
     */
    public Optional<Output<Integer>> expirationDuration() {
        return Optional.ofNullable(this.expirationDuration);
    }

    /**
     * Which strategy to use when filling gaps in the signal. Possible values are `none`, `last_value` or `static`. If `static`, the `fill_value` field will be used for filling gaps in the signal.
     * 
     */
    @Import(name="fillOption")
    private @Nullable Output<String> fillOption;

    /**
     * @return Which strategy to use when filling gaps in the signal. Possible values are `none`, `last_value` or `static`. If `static`, the `fill_value` field will be used for filling gaps in the signal.
     * 
     */
    public Optional<Output<String>> fillOption() {
        return Optional.ofNullable(this.fillOption);
    }

    /**
     * This value will be used for filling gaps in the signal.
     * 
     */
    @Import(name="fillValue")
    private @Nullable Output<Double> fillValue;

    /**
     * @return This value will be used for filling gaps in the signal.
     * 
     */
    public Optional<Output<Double>> fillValue() {
        return Optional.ofNullable(this.fillValue);
    }

    /**
     * Whether an alert condition should ignore expected termination of a signal when considering whether to create a loss of signal incident. Defaults to false.
     * 
     */
    @Import(name="ignoreOnExpectedTermination")
    private @Nullable Output<Boolean> ignoreOnExpectedTermination;

    /**
     * @return Whether an alert condition should ignore expected termination of a signal when considering whether to create a loss of signal incident. Defaults to false.
     * 
     */
    public Optional<Output<Boolean>> ignoreOnExpectedTermination() {
        return Optional.ofNullable(this.ignoreOnExpectedTermination);
    }

    /**
     * The title of the condition.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The title of the condition.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * A NRQL query. See NRQL below for details.
     * 
     */
    @Import(name="nrql")
    private @Nullable Output<NrqlAlertConditionNrqlArgs> nrql;

    /**
     * @return A NRQL query. See NRQL below for details.
     * 
     */
    public Optional<Output<NrqlAlertConditionNrqlArgs>> nrql() {
        return Optional.ofNullable(this.nrql);
    }

    /**
     * Whether to create a new incident to capture that the signal expired.
     * 
     */
    @Import(name="openViolationOnExpiration")
    private @Nullable Output<Boolean> openViolationOnExpiration;

    /**
     * @return Whether to create a new incident to capture that the signal expired.
     * 
     */
    public Optional<Output<Boolean>> openViolationOnExpiration() {
        return Optional.ofNullable(this.openViolationOnExpiration);
    }

    /**
     * The ID of the policy where this condition should be used.
     * 
     */
    @Import(name="policyId")
    private @Nullable Output<String> policyId;

    /**
     * @return The ID of the policy where this condition should be used.
     * 
     */
    public Optional<Output<String>> policyId() {
        return Optional.ofNullable(this.policyId);
    }

    /**
     * Runbook URL to display in notifications.
     * 
     */
    @Import(name="runbookUrl")
    private @Nullable Output<String> runbookUrl;

    /**
     * @return Runbook URL to display in notifications.
     * 
     */
    public Optional<Output<String>> runbookUrl() {
        return Optional.ofNullable(this.runbookUrl);
    }

    /**
     * Seasonality under which a condition&#39;s signal(s) are evaluated. Only available for baseline conditions. Valid values are: `NEW_RELIC_CALCULATION`, `HOURLY`, `DAILY`, `WEEKLY`, or `NONE`. To have New Relic calculate seasonality automatically, set to `NEW_RELIC_CALCULATION`. To turn off seasonality completely, set to `NONE`.
     * 
     */
    @Import(name="signalSeasonality")
    private @Nullable Output<String> signalSeasonality;

    /**
     * @return Seasonality under which a condition&#39;s signal(s) are evaluated. Only available for baseline conditions. Valid values are: `NEW_RELIC_CALCULATION`, `HOURLY`, `DAILY`, `WEEKLY`, or `NONE`. To have New Relic calculate seasonality automatically, set to `NEW_RELIC_CALCULATION`. To turn off seasonality completely, set to `NONE`.
     * 
     */
    public Optional<Output<String>> signalSeasonality() {
        return Optional.ofNullable(this.signalSeasonality);
    }

    /**
     * Gathers data in overlapping time windows to smooth the chart line, making it easier to spot trends. The `slide_by` value is specified in seconds and must be smaller than and a factor of the `aggregation_window`.
     * 
     */
    @Import(name="slideBy")
    private @Nullable Output<Integer> slideBy;

    /**
     * @return Gathers data in overlapping time windows to smooth the chart line, making it easier to spot trends. The `slide_by` value is specified in seconds and must be smaller than and a factor of the `aggregation_window`.
     * 
     */
    public Optional<Output<Integer>> slideBy() {
        return Optional.ofNullable(this.slideBy);
    }

    /**
     * **DEPRECATED** Use `critical`, and `warning` instead. A list of terms for this condition. See Terms below for details.
     * 
     * @deprecated
     * use `critical` and `warning` attributes instead
     * 
     */
    @Deprecated /* use `critical` and `warning` attributes instead */
    @Import(name="terms")
    private @Nullable Output<List<NrqlAlertConditionTermArgs>> terms;

    /**
     * @return **DEPRECATED** Use `critical`, and `warning` instead. A list of terms for this condition. See Terms below for details.
     * 
     * @deprecated
     * use `critical` and `warning` attributes instead
     * 
     */
    @Deprecated /* use `critical` and `warning` attributes instead */
    public Optional<Output<List<NrqlAlertConditionTermArgs>>> terms() {
        return Optional.ofNullable(this.terms);
    }

    /**
     * The custom title to be used when incidents are opened by the condition. Setting this field will override the default title. Must be [Handlebars](https://handlebarsjs.com/) format.
     * 
     */
    @Import(name="titleTemplate")
    private @Nullable Output<String> titleTemplate;

    /**
     * @return The custom title to be used when incidents are opened by the condition. Setting this field will override the default title. Must be [Handlebars](https://handlebarsjs.com/) format.
     * 
     */
    public Optional<Output<String>> titleTemplate() {
        return Optional.ofNullable(this.titleTemplate);
    }

    /**
     * The type of the condition. Valid values are `static` or `baseline`. Defaults to `static`.
     * 
     */
    @Import(name="type")
    private @Nullable Output<String> type;

    /**
     * @return The type of the condition. Valid values are `static` or `baseline`. Defaults to `static`.
     * 
     */
    public Optional<Output<String>> type() {
        return Optional.ofNullable(this.type);
    }

    /**
     * **DEPRECATED:** Use `violation_time_limit_seconds` instead. Sets a time limit, in hours, that will automatically force-close a long-lasting incident after the time limit you select. Possible values are `ONE_HOUR`, `TWO_HOURS`, `FOUR_HOURS`, `EIGHT_HOURS`, `TWELVE_HOURS`, `TWENTY_FOUR_HOURS`, `THIRTY_DAYS` (case insensitive).&lt;br&gt;
     * &lt;small&gt;\***Note**: One of `violation_time_limit` _or_ `violation_time_limit_seconds` must be set, but not both.&lt;/small&gt;
     * 
     * @deprecated
     * use `violation_time_limit_seconds` attribute instead
     * 
     */
    @Deprecated /* use `violation_time_limit_seconds` attribute instead */
    @Import(name="violationTimeLimit")
    private @Nullable Output<String> violationTimeLimit;

    /**
     * @return **DEPRECATED:** Use `violation_time_limit_seconds` instead. Sets a time limit, in hours, that will automatically force-close a long-lasting incident after the time limit you select. Possible values are `ONE_HOUR`, `TWO_HOURS`, `FOUR_HOURS`, `EIGHT_HOURS`, `TWELVE_HOURS`, `TWENTY_FOUR_HOURS`, `THIRTY_DAYS` (case insensitive).&lt;br&gt;
     * &lt;small&gt;\***Note**: One of `violation_time_limit` _or_ `violation_time_limit_seconds` must be set, but not both.&lt;/small&gt;
     * 
     * @deprecated
     * use `violation_time_limit_seconds` attribute instead
     * 
     */
    @Deprecated /* use `violation_time_limit_seconds` attribute instead */
    public Optional<Output<String>> violationTimeLimit() {
        return Optional.ofNullable(this.violationTimeLimit);
    }

    /**
     * Sets a time limit, in seconds, that will automatically force-close a long-lasting incident after the time limit you select. The value must be between 300 seconds (5 minutes) to 2592000 seconds (30 days) (inclusive). &lt;br&gt;
     * &lt;small&gt;\***Note**: One of `violation_time_limit` _or_ `violation_time_limit_seconds` must be set, but not both.&lt;/small&gt;
     * 
     */
    @Import(name="violationTimeLimitSeconds")
    private @Nullable Output<Integer> violationTimeLimitSeconds;

    /**
     * @return Sets a time limit, in seconds, that will automatically force-close a long-lasting incident after the time limit you select. The value must be between 300 seconds (5 minutes) to 2592000 seconds (30 days) (inclusive). &lt;br&gt;
     * &lt;small&gt;\***Note**: One of `violation_time_limit` _or_ `violation_time_limit_seconds` must be set, but not both.&lt;/small&gt;
     * 
     */
    public Optional<Output<Integer>> violationTimeLimitSeconds() {
        return Optional.ofNullable(this.violationTimeLimitSeconds);
    }

    /**
     * A list containing the `warning` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
     * 
     */
    @Import(name="warning")
    private @Nullable Output<NrqlAlertConditionWarningArgs> warning;

    /**
     * @return A list containing the `warning` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
     * 
     */
    public Optional<Output<NrqlAlertConditionWarningArgs>> warning() {
        return Optional.ofNullable(this.warning);
    }

    private NrqlAlertConditionState() {}

    private NrqlAlertConditionState(NrqlAlertConditionState $) {
        this.accountId = $.accountId;
        this.aggregationDelay = $.aggregationDelay;
        this.aggregationMethod = $.aggregationMethod;
        this.aggregationTimer = $.aggregationTimer;
        this.aggregationWindow = $.aggregationWindow;
        this.baselineDirection = $.baselineDirection;
        this.closeViolationsOnExpiration = $.closeViolationsOnExpiration;
        this.critical = $.critical;
        this.description = $.description;
        this.enabled = $.enabled;
        this.entityGuid = $.entityGuid;
        this.evaluationDelay = $.evaluationDelay;
        this.expirationDuration = $.expirationDuration;
        this.fillOption = $.fillOption;
        this.fillValue = $.fillValue;
        this.ignoreOnExpectedTermination = $.ignoreOnExpectedTermination;
        this.name = $.name;
        this.nrql = $.nrql;
        this.openViolationOnExpiration = $.openViolationOnExpiration;
        this.policyId = $.policyId;
        this.runbookUrl = $.runbookUrl;
        this.signalSeasonality = $.signalSeasonality;
        this.slideBy = $.slideBy;
        this.terms = $.terms;
        this.titleTemplate = $.titleTemplate;
        this.type = $.type;
        this.violationTimeLimit = $.violationTimeLimit;
        this.violationTimeLimitSeconds = $.violationTimeLimitSeconds;
        this.warning = $.warning;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(NrqlAlertConditionState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private NrqlAlertConditionState $;

        public Builder() {
            $ = new NrqlAlertConditionState();
        }

        public Builder(NrqlAlertConditionState defaults) {
            $ = new NrqlAlertConditionState(Objects.requireNonNull(defaults));
        }

        /**
         * @param accountId The New Relic account ID of the account you wish to create the condition. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
         * 
         * @return builder
         * 
         */
        public Builder accountId(@Nullable Output<String> accountId) {
            $.accountId = accountId;
            return this;
        }

        /**
         * @param accountId The New Relic account ID of the account you wish to create the condition. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
         * 
         * @return builder
         * 
         */
        public Builder accountId(String accountId) {
            return accountId(Output.of(accountId));
        }

        /**
         * @param aggregationDelay How long we wait for data that belongs in each aggregation window. Depending on your data, a longer delay may increase accuracy but delay notifications. Use `aggregation_delay` with the `event_flow` and `cadence` methods. The maximum delay is 1200 seconds (20 minutes) when using `event_flow` and 3600 seconds (60 minutes) when using `cadence`. In both cases, the minimum delay is 0 seconds and the default is 120 seconds. `aggregation_delay` cannot be set with `nrql.evaluation_offset`.
         * 
         * @return builder
         * 
         */
        public Builder aggregationDelay(@Nullable Output<String> aggregationDelay) {
            $.aggregationDelay = aggregationDelay;
            return this;
        }

        /**
         * @param aggregationDelay How long we wait for data that belongs in each aggregation window. Depending on your data, a longer delay may increase accuracy but delay notifications. Use `aggregation_delay` with the `event_flow` and `cadence` methods. The maximum delay is 1200 seconds (20 minutes) when using `event_flow` and 3600 seconds (60 minutes) when using `cadence`. In both cases, the minimum delay is 0 seconds and the default is 120 seconds. `aggregation_delay` cannot be set with `nrql.evaluation_offset`.
         * 
         * @return builder
         * 
         */
        public Builder aggregationDelay(String aggregationDelay) {
            return aggregationDelay(Output.of(aggregationDelay));
        }

        /**
         * @param aggregationMethod Determines when we consider an aggregation window to be complete so that we can evaluate the signal for incidents. Possible values are `cadence`, `event_flow` or `event_timer`. Default is `event_flow`. `aggregation_method` cannot be set with `nrql.evaluation_offset`.
         * 
         * @return builder
         * 
         */
        public Builder aggregationMethod(@Nullable Output<String> aggregationMethod) {
            $.aggregationMethod = aggregationMethod;
            return this;
        }

        /**
         * @param aggregationMethod Determines when we consider an aggregation window to be complete so that we can evaluate the signal for incidents. Possible values are `cadence`, `event_flow` or `event_timer`. Default is `event_flow`. `aggregation_method` cannot be set with `nrql.evaluation_offset`.
         * 
         * @return builder
         * 
         */
        public Builder aggregationMethod(String aggregationMethod) {
            return aggregationMethod(Output.of(aggregationMethod));
        }

        /**
         * @param aggregationTimer How long we wait after each data point arrives to make sure we&#39;ve processed the whole batch. Use `aggregation_timer` with the `event_timer` method. The timer value can range from 0 seconds to 1200 seconds (20 minutes); the default is 60 seconds. `aggregation_timer` cannot be set with `nrql.evaluation_offset`.
         * 
         * @return builder
         * 
         */
        public Builder aggregationTimer(@Nullable Output<String> aggregationTimer) {
            $.aggregationTimer = aggregationTimer;
            return this;
        }

        /**
         * @param aggregationTimer How long we wait after each data point arrives to make sure we&#39;ve processed the whole batch. Use `aggregation_timer` with the `event_timer` method. The timer value can range from 0 seconds to 1200 seconds (20 minutes); the default is 60 seconds. `aggregation_timer` cannot be set with `nrql.evaluation_offset`.
         * 
         * @return builder
         * 
         */
        public Builder aggregationTimer(String aggregationTimer) {
            return aggregationTimer(Output.of(aggregationTimer));
        }

        /**
         * @param aggregationWindow The duration of the time window used to evaluate the NRQL query, in seconds. The value must be at least 30 seconds, and no more than 21600 seconds (6 hours). Default is 60 seconds.
         * 
         * @return builder
         * 
         */
        public Builder aggregationWindow(@Nullable Output<Integer> aggregationWindow) {
            $.aggregationWindow = aggregationWindow;
            return this;
        }

        /**
         * @param aggregationWindow The duration of the time window used to evaluate the NRQL query, in seconds. The value must be at least 30 seconds, and no more than 21600 seconds (6 hours). Default is 60 seconds.
         * 
         * @return builder
         * 
         */
        public Builder aggregationWindow(Integer aggregationWindow) {
            return aggregationWindow(Output.of(aggregationWindow));
        }

        /**
         * @param baselineDirection The baseline direction of a _baseline_ NRQL alert condition. Valid values are: `lower_only`, `upper_and_lower`, `upper_only` (case insensitive).
         * 
         * @return builder
         * 
         */
        public Builder baselineDirection(@Nullable Output<String> baselineDirection) {
            $.baselineDirection = baselineDirection;
            return this;
        }

        /**
         * @param baselineDirection The baseline direction of a _baseline_ NRQL alert condition. Valid values are: `lower_only`, `upper_and_lower`, `upper_only` (case insensitive).
         * 
         * @return builder
         * 
         */
        public Builder baselineDirection(String baselineDirection) {
            return baselineDirection(Output.of(baselineDirection));
        }

        /**
         * @param closeViolationsOnExpiration Whether to close all open incidents when the signal expires.
         * 
         * @return builder
         * 
         */
        public Builder closeViolationsOnExpiration(@Nullable Output<Boolean> closeViolationsOnExpiration) {
            $.closeViolationsOnExpiration = closeViolationsOnExpiration;
            return this;
        }

        /**
         * @param closeViolationsOnExpiration Whether to close all open incidents when the signal expires.
         * 
         * @return builder
         * 
         */
        public Builder closeViolationsOnExpiration(Boolean closeViolationsOnExpiration) {
            return closeViolationsOnExpiration(Output.of(closeViolationsOnExpiration));
        }

        /**
         * @param critical A list containing the `critical` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
         * 
         * @return builder
         * 
         */
        public Builder critical(@Nullable Output<NrqlAlertConditionCriticalArgs> critical) {
            $.critical = critical;
            return this;
        }

        /**
         * @param critical A list containing the `critical` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
         * 
         * @return builder
         * 
         */
        public Builder critical(NrqlAlertConditionCriticalArgs critical) {
            return critical(Output.of(critical));
        }

        /**
         * @param description The description of the NRQL alert condition.
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description The description of the NRQL alert condition.
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param enabled Whether to enable the alert condition. Valid values are `true` and `false`. Defaults to `true`.
         * 
         * @return builder
         * 
         */
        public Builder enabled(@Nullable Output<Boolean> enabled) {
            $.enabled = enabled;
            return this;
        }

        /**
         * @param enabled Whether to enable the alert condition. Valid values are `true` and `false`. Defaults to `true`.
         * 
         * @return builder
         * 
         */
        public Builder enabled(Boolean enabled) {
            return enabled(Output.of(enabled));
        }

        /**
         * @param entityGuid The unique entity identifier of the NRQL Condition in New Relic.
         * 
         * @return builder
         * 
         */
        public Builder entityGuid(@Nullable Output<String> entityGuid) {
            $.entityGuid = entityGuid;
            return this;
        }

        /**
         * @param entityGuid The unique entity identifier of the NRQL Condition in New Relic.
         * 
         * @return builder
         * 
         */
        public Builder entityGuid(String entityGuid) {
            return entityGuid(Output.of(entityGuid));
        }

        /**
         * @param evaluationDelay How long we wait until the signal starts evaluating. The maximum delay is 7200 seconds (120 minutes).
         * 
         * @return builder
         * 
         */
        public Builder evaluationDelay(@Nullable Output<Integer> evaluationDelay) {
            $.evaluationDelay = evaluationDelay;
            return this;
        }

        /**
         * @param evaluationDelay How long we wait until the signal starts evaluating. The maximum delay is 7200 seconds (120 minutes).
         * 
         * @return builder
         * 
         */
        public Builder evaluationDelay(Integer evaluationDelay) {
            return evaluationDelay(Output.of(evaluationDelay));
        }

        /**
         * @param expirationDuration The amount of time (in seconds) to wait before considering the signal expired. The value must be at least 30 seconds, and no more than 172800 seconds (48 hours).
         * 
         * @return builder
         * 
         */
        public Builder expirationDuration(@Nullable Output<Integer> expirationDuration) {
            $.expirationDuration = expirationDuration;
            return this;
        }

        /**
         * @param expirationDuration The amount of time (in seconds) to wait before considering the signal expired. The value must be at least 30 seconds, and no more than 172800 seconds (48 hours).
         * 
         * @return builder
         * 
         */
        public Builder expirationDuration(Integer expirationDuration) {
            return expirationDuration(Output.of(expirationDuration));
        }

        /**
         * @param fillOption Which strategy to use when filling gaps in the signal. Possible values are `none`, `last_value` or `static`. If `static`, the `fill_value` field will be used for filling gaps in the signal.
         * 
         * @return builder
         * 
         */
        public Builder fillOption(@Nullable Output<String> fillOption) {
            $.fillOption = fillOption;
            return this;
        }

        /**
         * @param fillOption Which strategy to use when filling gaps in the signal. Possible values are `none`, `last_value` or `static`. If `static`, the `fill_value` field will be used for filling gaps in the signal.
         * 
         * @return builder
         * 
         */
        public Builder fillOption(String fillOption) {
            return fillOption(Output.of(fillOption));
        }

        /**
         * @param fillValue This value will be used for filling gaps in the signal.
         * 
         * @return builder
         * 
         */
        public Builder fillValue(@Nullable Output<Double> fillValue) {
            $.fillValue = fillValue;
            return this;
        }

        /**
         * @param fillValue This value will be used for filling gaps in the signal.
         * 
         * @return builder
         * 
         */
        public Builder fillValue(Double fillValue) {
            return fillValue(Output.of(fillValue));
        }

        /**
         * @param ignoreOnExpectedTermination Whether an alert condition should ignore expected termination of a signal when considering whether to create a loss of signal incident. Defaults to false.
         * 
         * @return builder
         * 
         */
        public Builder ignoreOnExpectedTermination(@Nullable Output<Boolean> ignoreOnExpectedTermination) {
            $.ignoreOnExpectedTermination = ignoreOnExpectedTermination;
            return this;
        }

        /**
         * @param ignoreOnExpectedTermination Whether an alert condition should ignore expected termination of a signal when considering whether to create a loss of signal incident. Defaults to false.
         * 
         * @return builder
         * 
         */
        public Builder ignoreOnExpectedTermination(Boolean ignoreOnExpectedTermination) {
            return ignoreOnExpectedTermination(Output.of(ignoreOnExpectedTermination));
        }

        /**
         * @param name The title of the condition.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The title of the condition.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param nrql A NRQL query. See NRQL below for details.
         * 
         * @return builder
         * 
         */
        public Builder nrql(@Nullable Output<NrqlAlertConditionNrqlArgs> nrql) {
            $.nrql = nrql;
            return this;
        }

        /**
         * @param nrql A NRQL query. See NRQL below for details.
         * 
         * @return builder
         * 
         */
        public Builder nrql(NrqlAlertConditionNrqlArgs nrql) {
            return nrql(Output.of(nrql));
        }

        /**
         * @param openViolationOnExpiration Whether to create a new incident to capture that the signal expired.
         * 
         * @return builder
         * 
         */
        public Builder openViolationOnExpiration(@Nullable Output<Boolean> openViolationOnExpiration) {
            $.openViolationOnExpiration = openViolationOnExpiration;
            return this;
        }

        /**
         * @param openViolationOnExpiration Whether to create a new incident to capture that the signal expired.
         * 
         * @return builder
         * 
         */
        public Builder openViolationOnExpiration(Boolean openViolationOnExpiration) {
            return openViolationOnExpiration(Output.of(openViolationOnExpiration));
        }

        /**
         * @param policyId The ID of the policy where this condition should be used.
         * 
         * @return builder
         * 
         */
        public Builder policyId(@Nullable Output<String> policyId) {
            $.policyId = policyId;
            return this;
        }

        /**
         * @param policyId The ID of the policy where this condition should be used.
         * 
         * @return builder
         * 
         */
        public Builder policyId(String policyId) {
            return policyId(Output.of(policyId));
        }

        /**
         * @param runbookUrl Runbook URL to display in notifications.
         * 
         * @return builder
         * 
         */
        public Builder runbookUrl(@Nullable Output<String> runbookUrl) {
            $.runbookUrl = runbookUrl;
            return this;
        }

        /**
         * @param runbookUrl Runbook URL to display in notifications.
         * 
         * @return builder
         * 
         */
        public Builder runbookUrl(String runbookUrl) {
            return runbookUrl(Output.of(runbookUrl));
        }

        /**
         * @param signalSeasonality Seasonality under which a condition&#39;s signal(s) are evaluated. Only available for baseline conditions. Valid values are: `NEW_RELIC_CALCULATION`, `HOURLY`, `DAILY`, `WEEKLY`, or `NONE`. To have New Relic calculate seasonality automatically, set to `NEW_RELIC_CALCULATION`. To turn off seasonality completely, set to `NONE`.
         * 
         * @return builder
         * 
         */
        public Builder signalSeasonality(@Nullable Output<String> signalSeasonality) {
            $.signalSeasonality = signalSeasonality;
            return this;
        }

        /**
         * @param signalSeasonality Seasonality under which a condition&#39;s signal(s) are evaluated. Only available for baseline conditions. Valid values are: `NEW_RELIC_CALCULATION`, `HOURLY`, `DAILY`, `WEEKLY`, or `NONE`. To have New Relic calculate seasonality automatically, set to `NEW_RELIC_CALCULATION`. To turn off seasonality completely, set to `NONE`.
         * 
         * @return builder
         * 
         */
        public Builder signalSeasonality(String signalSeasonality) {
            return signalSeasonality(Output.of(signalSeasonality));
        }

        /**
         * @param slideBy Gathers data in overlapping time windows to smooth the chart line, making it easier to spot trends. The `slide_by` value is specified in seconds and must be smaller than and a factor of the `aggregation_window`.
         * 
         * @return builder
         * 
         */
        public Builder slideBy(@Nullable Output<Integer> slideBy) {
            $.slideBy = slideBy;
            return this;
        }

        /**
         * @param slideBy Gathers data in overlapping time windows to smooth the chart line, making it easier to spot trends. The `slide_by` value is specified in seconds and must be smaller than and a factor of the `aggregation_window`.
         * 
         * @return builder
         * 
         */
        public Builder slideBy(Integer slideBy) {
            return slideBy(Output.of(slideBy));
        }

        /**
         * @param terms **DEPRECATED** Use `critical`, and `warning` instead. A list of terms for this condition. See Terms below for details.
         * 
         * @return builder
         * 
         * @deprecated
         * use `critical` and `warning` attributes instead
         * 
         */
        @Deprecated /* use `critical` and `warning` attributes instead */
        public Builder terms(@Nullable Output<List<NrqlAlertConditionTermArgs>> terms) {
            $.terms = terms;
            return this;
        }

        /**
         * @param terms **DEPRECATED** Use `critical`, and `warning` instead. A list of terms for this condition. See Terms below for details.
         * 
         * @return builder
         * 
         * @deprecated
         * use `critical` and `warning` attributes instead
         * 
         */
        @Deprecated /* use `critical` and `warning` attributes instead */
        public Builder terms(List<NrqlAlertConditionTermArgs> terms) {
            return terms(Output.of(terms));
        }

        /**
         * @param terms **DEPRECATED** Use `critical`, and `warning` instead. A list of terms for this condition. See Terms below for details.
         * 
         * @return builder
         * 
         * @deprecated
         * use `critical` and `warning` attributes instead
         * 
         */
        @Deprecated /* use `critical` and `warning` attributes instead */
        public Builder terms(NrqlAlertConditionTermArgs... terms) {
            return terms(List.of(terms));
        }

        /**
         * @param titleTemplate The custom title to be used when incidents are opened by the condition. Setting this field will override the default title. Must be [Handlebars](https://handlebarsjs.com/) format.
         * 
         * @return builder
         * 
         */
        public Builder titleTemplate(@Nullable Output<String> titleTemplate) {
            $.titleTemplate = titleTemplate;
            return this;
        }

        /**
         * @param titleTemplate The custom title to be used when incidents are opened by the condition. Setting this field will override the default title. Must be [Handlebars](https://handlebarsjs.com/) format.
         * 
         * @return builder
         * 
         */
        public Builder titleTemplate(String titleTemplate) {
            return titleTemplate(Output.of(titleTemplate));
        }

        /**
         * @param type The type of the condition. Valid values are `static` or `baseline`. Defaults to `static`.
         * 
         * @return builder
         * 
         */
        public Builder type(@Nullable Output<String> type) {
            $.type = type;
            return this;
        }

        /**
         * @param type The type of the condition. Valid values are `static` or `baseline`. Defaults to `static`.
         * 
         * @return builder
         * 
         */
        public Builder type(String type) {
            return type(Output.of(type));
        }

        /**
         * @param violationTimeLimit **DEPRECATED:** Use `violation_time_limit_seconds` instead. Sets a time limit, in hours, that will automatically force-close a long-lasting incident after the time limit you select. Possible values are `ONE_HOUR`, `TWO_HOURS`, `FOUR_HOURS`, `EIGHT_HOURS`, `TWELVE_HOURS`, `TWENTY_FOUR_HOURS`, `THIRTY_DAYS` (case insensitive).&lt;br&gt;
         * &lt;small&gt;\***Note**: One of `violation_time_limit` _or_ `violation_time_limit_seconds` must be set, but not both.&lt;/small&gt;
         * 
         * @return builder
         * 
         * @deprecated
         * use `violation_time_limit_seconds` attribute instead
         * 
         */
        @Deprecated /* use `violation_time_limit_seconds` attribute instead */
        public Builder violationTimeLimit(@Nullable Output<String> violationTimeLimit) {
            $.violationTimeLimit = violationTimeLimit;
            return this;
        }

        /**
         * @param violationTimeLimit **DEPRECATED:** Use `violation_time_limit_seconds` instead. Sets a time limit, in hours, that will automatically force-close a long-lasting incident after the time limit you select. Possible values are `ONE_HOUR`, `TWO_HOURS`, `FOUR_HOURS`, `EIGHT_HOURS`, `TWELVE_HOURS`, `TWENTY_FOUR_HOURS`, `THIRTY_DAYS` (case insensitive).&lt;br&gt;
         * &lt;small&gt;\***Note**: One of `violation_time_limit` _or_ `violation_time_limit_seconds` must be set, but not both.&lt;/small&gt;
         * 
         * @return builder
         * 
         * @deprecated
         * use `violation_time_limit_seconds` attribute instead
         * 
         */
        @Deprecated /* use `violation_time_limit_seconds` attribute instead */
        public Builder violationTimeLimit(String violationTimeLimit) {
            return violationTimeLimit(Output.of(violationTimeLimit));
        }

        /**
         * @param violationTimeLimitSeconds Sets a time limit, in seconds, that will automatically force-close a long-lasting incident after the time limit you select. The value must be between 300 seconds (5 minutes) to 2592000 seconds (30 days) (inclusive). &lt;br&gt;
         * &lt;small&gt;\***Note**: One of `violation_time_limit` _or_ `violation_time_limit_seconds` must be set, but not both.&lt;/small&gt;
         * 
         * @return builder
         * 
         */
        public Builder violationTimeLimitSeconds(@Nullable Output<Integer> violationTimeLimitSeconds) {
            $.violationTimeLimitSeconds = violationTimeLimitSeconds;
            return this;
        }

        /**
         * @param violationTimeLimitSeconds Sets a time limit, in seconds, that will automatically force-close a long-lasting incident after the time limit you select. The value must be between 300 seconds (5 minutes) to 2592000 seconds (30 days) (inclusive). &lt;br&gt;
         * &lt;small&gt;\***Note**: One of `violation_time_limit` _or_ `violation_time_limit_seconds` must be set, but not both.&lt;/small&gt;
         * 
         * @return builder
         * 
         */
        public Builder violationTimeLimitSeconds(Integer violationTimeLimitSeconds) {
            return violationTimeLimitSeconds(Output.of(violationTimeLimitSeconds));
        }

        /**
         * @param warning A list containing the `warning` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
         * 
         * @return builder
         * 
         */
        public Builder warning(@Nullable Output<NrqlAlertConditionWarningArgs> warning) {
            $.warning = warning;
            return this;
        }

        /**
         * @param warning A list containing the `warning` threshold values. At least one `critical` or `warning` threshold must be defined. See Terms below for details.
         * 
         * @return builder
         * 
         */
        public Builder warning(NrqlAlertConditionWarningArgs warning) {
            return warning(Output.of(warning));
        }

        public NrqlAlertConditionState build() {
            return $;
        }
    }

}
