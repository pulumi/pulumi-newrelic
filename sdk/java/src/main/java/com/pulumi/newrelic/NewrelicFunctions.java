// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.newrelic;

import com.pulumi.core.Output;
import com.pulumi.core.TypeShape;
import com.pulumi.deployment.Deployment;
import com.pulumi.deployment.InvokeOptions;
import com.pulumi.deployment.InvokeOutputOptions;
import com.pulumi.newrelic.Utilities;
import com.pulumi.newrelic.inputs.GetAccountArgs;
import com.pulumi.newrelic.inputs.GetAccountPlainArgs;
import com.pulumi.newrelic.inputs.GetAlertChannelArgs;
import com.pulumi.newrelic.inputs.GetAlertChannelPlainArgs;
import com.pulumi.newrelic.inputs.GetAlertPolicyArgs;
import com.pulumi.newrelic.inputs.GetAlertPolicyPlainArgs;
import com.pulumi.newrelic.inputs.GetApplicationArgs;
import com.pulumi.newrelic.inputs.GetApplicationPlainArgs;
import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
import com.pulumi.newrelic.inputs.GetAuthenticationDomainPlainArgs;
import com.pulumi.newrelic.inputs.GetCloudAccountArgs;
import com.pulumi.newrelic.inputs.GetCloudAccountPlainArgs;
import com.pulumi.newrelic.inputs.GetEntityArgs;
import com.pulumi.newrelic.inputs.GetEntityPlainArgs;
import com.pulumi.newrelic.inputs.GetGroupArgs;
import com.pulumi.newrelic.inputs.GetGroupPlainArgs;
import com.pulumi.newrelic.inputs.GetKeyTransactionArgs;
import com.pulumi.newrelic.inputs.GetKeyTransactionPlainArgs;
import com.pulumi.newrelic.inputs.GetNotificationDestinationArgs;
import com.pulumi.newrelic.inputs.GetNotificationDestinationPlainArgs;
import com.pulumi.newrelic.inputs.GetObfuscationExpressionArgs;
import com.pulumi.newrelic.inputs.GetObfuscationExpressionPlainArgs;
import com.pulumi.newrelic.inputs.GetServiceLevelAlertHelperArgs;
import com.pulumi.newrelic.inputs.GetServiceLevelAlertHelperPlainArgs;
import com.pulumi.newrelic.inputs.GetTestGrokPatternArgs;
import com.pulumi.newrelic.inputs.GetTestGrokPatternPlainArgs;
import com.pulumi.newrelic.inputs.GetUserArgs;
import com.pulumi.newrelic.inputs.GetUserPlainArgs;
import com.pulumi.newrelic.outputs.GetAccountResult;
import com.pulumi.newrelic.outputs.GetAlertChannelResult;
import com.pulumi.newrelic.outputs.GetAlertPolicyResult;
import com.pulumi.newrelic.outputs.GetApplicationResult;
import com.pulumi.newrelic.outputs.GetAuthenticationDomainResult;
import com.pulumi.newrelic.outputs.GetCloudAccountResult;
import com.pulumi.newrelic.outputs.GetEntityResult;
import com.pulumi.newrelic.outputs.GetGroupResult;
import com.pulumi.newrelic.outputs.GetKeyTransactionResult;
import com.pulumi.newrelic.outputs.GetNotificationDestinationResult;
import com.pulumi.newrelic.outputs.GetObfuscationExpressionResult;
import com.pulumi.newrelic.outputs.GetServiceLevelAlertHelperResult;
import com.pulumi.newrelic.outputs.GetTestGrokPatternResult;
import com.pulumi.newrelic.outputs.GetUserResult;
import java.util.concurrent.CompletableFuture;

public final class NewrelicFunctions {
    /**
     * This data source allows you to retrieve information about a specific account in New Relic.
     * 
     * ## Overview
     * 
     * You can locate accounts using either their `accountId` or `name`. However, only one of these attributes can be specified at a time. If neither attribute is provided, the provider&#39;s default `accountId` will be used.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = NewrelicFunctions.getAccount(GetAccountArgs.builder()
     *             .name("Test Account")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetAccountResult> getAccount() {
        return getAccount(GetAccountArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * This data source allows you to retrieve information about a specific account in New Relic.
     * 
     * ## Overview
     * 
     * You can locate accounts using either their `accountId` or `name`. However, only one of these attributes can be specified at a time. If neither attribute is provided, the provider&#39;s default `accountId` will be used.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = NewrelicFunctions.getAccount(GetAccountArgs.builder()
     *             .name("Test Account")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetAccountResult> getAccountPlain() {
        return getAccountPlain(GetAccountPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * This data source allows you to retrieve information about a specific account in New Relic.
     * 
     * ## Overview
     * 
     * You can locate accounts using either their `accountId` or `name`. However, only one of these attributes can be specified at a time. If neither attribute is provided, the provider&#39;s default `accountId` will be used.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = NewrelicFunctions.getAccount(GetAccountArgs.builder()
     *             .name("Test Account")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetAccountResult> getAccount(GetAccountArgs args) {
        return getAccount(args, InvokeOptions.Empty);
    }
    /**
     * This data source allows you to retrieve information about a specific account in New Relic.
     * 
     * ## Overview
     * 
     * You can locate accounts using either their `accountId` or `name`. However, only one of these attributes can be specified at a time. If neither attribute is provided, the provider&#39;s default `accountId` will be used.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = NewrelicFunctions.getAccount(GetAccountArgs.builder()
     *             .name("Test Account")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetAccountResult> getAccountPlain(GetAccountPlainArgs args) {
        return getAccountPlain(args, InvokeOptions.Empty);
    }
    /**
     * This data source allows you to retrieve information about a specific account in New Relic.
     * 
     * ## Overview
     * 
     * You can locate accounts using either their `accountId` or `name`. However, only one of these attributes can be specified at a time. If neither attribute is provided, the provider&#39;s default `accountId` will be used.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = NewrelicFunctions.getAccount(GetAccountArgs.builder()
     *             .name("Test Account")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetAccountResult> getAccount(GetAccountArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getAccount:getAccount", TypeShape.of(GetAccountResult.class), args, Utilities.withVersion(options));
    }
    /**
     * This data source allows you to retrieve information about a specific account in New Relic.
     * 
     * ## Overview
     * 
     * You can locate accounts using either their `accountId` or `name`. However, only one of these attributes can be specified at a time. If neither attribute is provided, the provider&#39;s default `accountId` will be used.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = NewrelicFunctions.getAccount(GetAccountArgs.builder()
     *             .name("Test Account")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetAccountResult> getAccount(GetAccountArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getAccount:getAccount", TypeShape.of(GetAccountResult.class), args, Utilities.withVersion(options));
    }
    /**
     * This data source allows you to retrieve information about a specific account in New Relic.
     * 
     * ## Overview
     * 
     * You can locate accounts using either their `accountId` or `name`. However, only one of these attributes can be specified at a time. If neither attribute is provided, the provider&#39;s default `accountId` will be used.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = NewrelicFunctions.getAccount(GetAccountArgs.builder()
     *             .name("Test Account")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetAccountResult> getAccountPlain(GetAccountPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getAccount:getAccount", TypeShape.of(GetAccountResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific alert channel in New Relic that already exists. More information on Terraform&#39;s data sources can be found here.
     * 
     * &gt; **WARNING:** The `newrelic.AlertChannel` data source is deprecated and will be removed in the next major release.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAlertChannelArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertPolicyChannel;
     * import com.pulumi.newrelic.AlertPolicyChannelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App }{{@code
     *     public static void main(String[] args) }{{@code
     *         Pulumi.run(App::stack);
     *     }}{@code
     * 
     *     public static void stack(Context ctx) }{{@code
     *         // Data source
     *         final var foo = NewrelicFunctions.getAlertChannel(GetAlertChannelArgs.builder()
     *             .name("foo}{@literal @}{@code example.com")
     *             .build());
     * 
     *         // Resource
     *         var fooAlertPolicy = new AlertPolicy("fooAlertPolicy", AlertPolicyArgs.builder()
     *             .name("foo")
     *             .build());
     * 
     *         // Using the data source and resource together
     *         var fooAlertPolicyChannel = new AlertPolicyChannel("fooAlertPolicyChannel", AlertPolicyChannelArgs.builder()
     *             .policyId(fooAlertPolicy.id())
     *             .channelId(foo.id())
     *             .build());
     * 
     *     }}{@code
     * }}{@code
     * }
     * </pre>
     * 
     */
    public static Output<GetAlertChannelResult> getAlertChannel(GetAlertChannelArgs args) {
        return getAlertChannel(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific alert channel in New Relic that already exists. More information on Terraform&#39;s data sources can be found here.
     * 
     * &gt; **WARNING:** The `newrelic.AlertChannel` data source is deprecated and will be removed in the next major release.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAlertChannelArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertPolicyChannel;
     * import com.pulumi.newrelic.AlertPolicyChannelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App }{{@code
     *     public static void main(String[] args) }{{@code
     *         Pulumi.run(App::stack);
     *     }}{@code
     * 
     *     public static void stack(Context ctx) }{{@code
     *         // Data source
     *         final var foo = NewrelicFunctions.getAlertChannel(GetAlertChannelArgs.builder()
     *             .name("foo}{@literal @}{@code example.com")
     *             .build());
     * 
     *         // Resource
     *         var fooAlertPolicy = new AlertPolicy("fooAlertPolicy", AlertPolicyArgs.builder()
     *             .name("foo")
     *             .build());
     * 
     *         // Using the data source and resource together
     *         var fooAlertPolicyChannel = new AlertPolicyChannel("fooAlertPolicyChannel", AlertPolicyChannelArgs.builder()
     *             .policyId(fooAlertPolicy.id())
     *             .channelId(foo.id())
     *             .build());
     * 
     *     }}{@code
     * }}{@code
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetAlertChannelResult> getAlertChannelPlain(GetAlertChannelPlainArgs args) {
        return getAlertChannelPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific alert channel in New Relic that already exists. More information on Terraform&#39;s data sources can be found here.
     * 
     * &gt; **WARNING:** The `newrelic.AlertChannel` data source is deprecated and will be removed in the next major release.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAlertChannelArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertPolicyChannel;
     * import com.pulumi.newrelic.AlertPolicyChannelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App }{{@code
     *     public static void main(String[] args) }{{@code
     *         Pulumi.run(App::stack);
     *     }}{@code
     * 
     *     public static void stack(Context ctx) }{{@code
     *         // Data source
     *         final var foo = NewrelicFunctions.getAlertChannel(GetAlertChannelArgs.builder()
     *             .name("foo}{@literal @}{@code example.com")
     *             .build());
     * 
     *         // Resource
     *         var fooAlertPolicy = new AlertPolicy("fooAlertPolicy", AlertPolicyArgs.builder()
     *             .name("foo")
     *             .build());
     * 
     *         // Using the data source and resource together
     *         var fooAlertPolicyChannel = new AlertPolicyChannel("fooAlertPolicyChannel", AlertPolicyChannelArgs.builder()
     *             .policyId(fooAlertPolicy.id())
     *             .channelId(foo.id())
     *             .build());
     * 
     *     }}{@code
     * }}{@code
     * }
     * </pre>
     * 
     */
    public static Output<GetAlertChannelResult> getAlertChannel(GetAlertChannelArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getAlertChannel:getAlertChannel", TypeShape.of(GetAlertChannelResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific alert channel in New Relic that already exists. More information on Terraform&#39;s data sources can be found here.
     * 
     * &gt; **WARNING:** The `newrelic.AlertChannel` data source is deprecated and will be removed in the next major release.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAlertChannelArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertPolicyChannel;
     * import com.pulumi.newrelic.AlertPolicyChannelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App }{{@code
     *     public static void main(String[] args) }{{@code
     *         Pulumi.run(App::stack);
     *     }}{@code
     * 
     *     public static void stack(Context ctx) }{{@code
     *         // Data source
     *         final var foo = NewrelicFunctions.getAlertChannel(GetAlertChannelArgs.builder()
     *             .name("foo}{@literal @}{@code example.com")
     *             .build());
     * 
     *         // Resource
     *         var fooAlertPolicy = new AlertPolicy("fooAlertPolicy", AlertPolicyArgs.builder()
     *             .name("foo")
     *             .build());
     * 
     *         // Using the data source and resource together
     *         var fooAlertPolicyChannel = new AlertPolicyChannel("fooAlertPolicyChannel", AlertPolicyChannelArgs.builder()
     *             .policyId(fooAlertPolicy.id())
     *             .channelId(foo.id())
     *             .build());
     * 
     *     }}{@code
     * }}{@code
     * }
     * </pre>
     * 
     */
    public static Output<GetAlertChannelResult> getAlertChannel(GetAlertChannelArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getAlertChannel:getAlertChannel", TypeShape.of(GetAlertChannelResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific alert channel in New Relic that already exists. More information on Terraform&#39;s data sources can be found here.
     * 
     * &gt; **WARNING:** The `newrelic.AlertChannel` data source is deprecated and will be removed in the next major release.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAlertChannelArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertPolicyChannel;
     * import com.pulumi.newrelic.AlertPolicyChannelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App }{{@code
     *     public static void main(String[] args) }{{@code
     *         Pulumi.run(App::stack);
     *     }}{@code
     * 
     *     public static void stack(Context ctx) }{{@code
     *         // Data source
     *         final var foo = NewrelicFunctions.getAlertChannel(GetAlertChannelArgs.builder()
     *             .name("foo}{@literal @}{@code example.com")
     *             .build());
     * 
     *         // Resource
     *         var fooAlertPolicy = new AlertPolicy("fooAlertPolicy", AlertPolicyArgs.builder()
     *             .name("foo")
     *             .build());
     * 
     *         // Using the data source and resource together
     *         var fooAlertPolicyChannel = new AlertPolicyChannel("fooAlertPolicyChannel", AlertPolicyChannelArgs.builder()
     *             .policyId(fooAlertPolicy.id())
     *             .channelId(foo.id())
     *             .build());
     * 
     *     }}{@code
     * }}{@code
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetAlertChannelResult> getAlertChannelPlain(GetAlertChannelPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getAlertChannel:getAlertChannel", TypeShape.of(GetAlertChannelResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific alert policy in New Relic that already exists.
     * More information on Terraform&#39;s data sources can be found here.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAlertChannelArgs;
     * import com.pulumi.newrelic.inputs.GetAlertPolicyArgs;
     * import com.pulumi.newrelic.AlertPolicyChannel;
     * import com.pulumi.newrelic.AlertPolicyChannelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App }{{@code
     *     public static void main(String[] args) }{{@code
     *         Pulumi.run(App::stack);
     *     }}{@code
     * 
     *     public static void stack(Context ctx) }{{@code
     *         final var foo = NewrelicFunctions.getAlertChannel(GetAlertChannelArgs.builder()
     *             .name("foo}{@literal @}{@code example.com")
     *             .build());
     * 
     *         final var fooGetAlertPolicy = NewrelicFunctions.getAlertPolicy(GetAlertPolicyArgs.builder()
     *             .name("foo policy")
     *             .build());
     * 
     *         var fooAlertPolicyChannel = new AlertPolicyChannel("fooAlertPolicyChannel", AlertPolicyChannelArgs.builder()
     *             .policyId(fooGetAlertPolicy.id())
     *             .channelId(foo.id())
     *             .build());
     * 
     *     }}{@code
     * }}{@code
     * }
     * </pre>
     * 
     */
    public static Output<GetAlertPolicyResult> getAlertPolicy(GetAlertPolicyArgs args) {
        return getAlertPolicy(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific alert policy in New Relic that already exists.
     * More information on Terraform&#39;s data sources can be found here.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAlertChannelArgs;
     * import com.pulumi.newrelic.inputs.GetAlertPolicyArgs;
     * import com.pulumi.newrelic.AlertPolicyChannel;
     * import com.pulumi.newrelic.AlertPolicyChannelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App }{{@code
     *     public static void main(String[] args) }{{@code
     *         Pulumi.run(App::stack);
     *     }}{@code
     * 
     *     public static void stack(Context ctx) }{{@code
     *         final var foo = NewrelicFunctions.getAlertChannel(GetAlertChannelArgs.builder()
     *             .name("foo}{@literal @}{@code example.com")
     *             .build());
     * 
     *         final var fooGetAlertPolicy = NewrelicFunctions.getAlertPolicy(GetAlertPolicyArgs.builder()
     *             .name("foo policy")
     *             .build());
     * 
     *         var fooAlertPolicyChannel = new AlertPolicyChannel("fooAlertPolicyChannel", AlertPolicyChannelArgs.builder()
     *             .policyId(fooGetAlertPolicy.id())
     *             .channelId(foo.id())
     *             .build());
     * 
     *     }}{@code
     * }}{@code
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetAlertPolicyResult> getAlertPolicyPlain(GetAlertPolicyPlainArgs args) {
        return getAlertPolicyPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific alert policy in New Relic that already exists.
     * More information on Terraform&#39;s data sources can be found here.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAlertChannelArgs;
     * import com.pulumi.newrelic.inputs.GetAlertPolicyArgs;
     * import com.pulumi.newrelic.AlertPolicyChannel;
     * import com.pulumi.newrelic.AlertPolicyChannelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App }{{@code
     *     public static void main(String[] args) }{{@code
     *         Pulumi.run(App::stack);
     *     }}{@code
     * 
     *     public static void stack(Context ctx) }{{@code
     *         final var foo = NewrelicFunctions.getAlertChannel(GetAlertChannelArgs.builder()
     *             .name("foo}{@literal @}{@code example.com")
     *             .build());
     * 
     *         final var fooGetAlertPolicy = NewrelicFunctions.getAlertPolicy(GetAlertPolicyArgs.builder()
     *             .name("foo policy")
     *             .build());
     * 
     *         var fooAlertPolicyChannel = new AlertPolicyChannel("fooAlertPolicyChannel", AlertPolicyChannelArgs.builder()
     *             .policyId(fooGetAlertPolicy.id())
     *             .channelId(foo.id())
     *             .build());
     * 
     *     }}{@code
     * }}{@code
     * }
     * </pre>
     * 
     */
    public static Output<GetAlertPolicyResult> getAlertPolicy(GetAlertPolicyArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getAlertPolicy:getAlertPolicy", TypeShape.of(GetAlertPolicyResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific alert policy in New Relic that already exists.
     * More information on Terraform&#39;s data sources can be found here.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAlertChannelArgs;
     * import com.pulumi.newrelic.inputs.GetAlertPolicyArgs;
     * import com.pulumi.newrelic.AlertPolicyChannel;
     * import com.pulumi.newrelic.AlertPolicyChannelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App }{{@code
     *     public static void main(String[] args) }{{@code
     *         Pulumi.run(App::stack);
     *     }}{@code
     * 
     *     public static void stack(Context ctx) }{{@code
     *         final var foo = NewrelicFunctions.getAlertChannel(GetAlertChannelArgs.builder()
     *             .name("foo}{@literal @}{@code example.com")
     *             .build());
     * 
     *         final var fooGetAlertPolicy = NewrelicFunctions.getAlertPolicy(GetAlertPolicyArgs.builder()
     *             .name("foo policy")
     *             .build());
     * 
     *         var fooAlertPolicyChannel = new AlertPolicyChannel("fooAlertPolicyChannel", AlertPolicyChannelArgs.builder()
     *             .policyId(fooGetAlertPolicy.id())
     *             .channelId(foo.id())
     *             .build());
     * 
     *     }}{@code
     * }}{@code
     * }
     * </pre>
     * 
     */
    public static Output<GetAlertPolicyResult> getAlertPolicy(GetAlertPolicyArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getAlertPolicy:getAlertPolicy", TypeShape.of(GetAlertPolicyResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific alert policy in New Relic that already exists.
     * More information on Terraform&#39;s data sources can be found here.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAlertChannelArgs;
     * import com.pulumi.newrelic.inputs.GetAlertPolicyArgs;
     * import com.pulumi.newrelic.AlertPolicyChannel;
     * import com.pulumi.newrelic.AlertPolicyChannelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App }{{@code
     *     public static void main(String[] args) }{{@code
     *         Pulumi.run(App::stack);
     *     }}{@code
     * 
     *     public static void stack(Context ctx) }{{@code
     *         final var foo = NewrelicFunctions.getAlertChannel(GetAlertChannelArgs.builder()
     *             .name("foo}{@literal @}{@code example.com")
     *             .build());
     * 
     *         final var fooGetAlertPolicy = NewrelicFunctions.getAlertPolicy(GetAlertPolicyArgs.builder()
     *             .name("foo policy")
     *             .build());
     * 
     *         var fooAlertPolicyChannel = new AlertPolicyChannel("fooAlertPolicyChannel", AlertPolicyChannelArgs.builder()
     *             .policyId(fooGetAlertPolicy.id())
     *             .channelId(foo.id())
     *             .build());
     * 
     *     }}{@code
     * }}{@code
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetAlertPolicyResult> getAlertPolicyPlain(GetAlertPolicyPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getAlertPolicy:getAlertPolicy", TypeShape.of(GetAlertPolicyResult.class), args, Utilities.withVersion(options));
    }
    /**
     * &gt; **DEPRECATED** Use at your own risk. Use the [`newrelic.getEntity`](https://www.terraform.io/docs/providers/newrelic/d/entity.html) data source instead. This feature may be removed in the next major release.
     * 
     * Use this data source to get information about a specific application in New Relic that already exists. More information on Terraform&#39;s data sources can be found here.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetApplicationArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertCondition;
     * import com.pulumi.newrelic.AlertConditionArgs;
     * import com.pulumi.newrelic.inputs.AlertConditionTermArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getApplication(GetApplicationArgs.builder()
     *             .name("my-app")
     *             .build());
     * 
     *         var foo = new AlertPolicy("foo", AlertPolicyArgs.builder()
     *             .name("foo")
     *             .build());
     * 
     *         var fooAlertCondition = new AlertCondition("fooAlertCondition", AlertConditionArgs.builder()
     *             .policyId(foo.id())
     *             .name("foo")
     *             .type("apm_app_metric")
     *             .entities(app.id())
     *             .metric("apdex")
     *             .runbookUrl("https://www.example.com")
     *             .terms(AlertConditionTermArgs.builder()
     *                 .duration(5)
     *                 .operator("below")
     *                 .priority("critical")
     *                 .threshold(0.75)
     *                 .timeFunction("all")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetApplicationResult> getApplication(GetApplicationArgs args) {
        return getApplication(args, InvokeOptions.Empty);
    }
    /**
     * &gt; **DEPRECATED** Use at your own risk. Use the [`newrelic.getEntity`](https://www.terraform.io/docs/providers/newrelic/d/entity.html) data source instead. This feature may be removed in the next major release.
     * 
     * Use this data source to get information about a specific application in New Relic that already exists. More information on Terraform&#39;s data sources can be found here.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetApplicationArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertCondition;
     * import com.pulumi.newrelic.AlertConditionArgs;
     * import com.pulumi.newrelic.inputs.AlertConditionTermArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getApplication(GetApplicationArgs.builder()
     *             .name("my-app")
     *             .build());
     * 
     *         var foo = new AlertPolicy("foo", AlertPolicyArgs.builder()
     *             .name("foo")
     *             .build());
     * 
     *         var fooAlertCondition = new AlertCondition("fooAlertCondition", AlertConditionArgs.builder()
     *             .policyId(foo.id())
     *             .name("foo")
     *             .type("apm_app_metric")
     *             .entities(app.id())
     *             .metric("apdex")
     *             .runbookUrl("https://www.example.com")
     *             .terms(AlertConditionTermArgs.builder()
     *                 .duration(5)
     *                 .operator("below")
     *                 .priority("critical")
     *                 .threshold(0.75)
     *                 .timeFunction("all")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetApplicationResult> getApplicationPlain(GetApplicationPlainArgs args) {
        return getApplicationPlain(args, InvokeOptions.Empty);
    }
    /**
     * &gt; **DEPRECATED** Use at your own risk. Use the [`newrelic.getEntity`](https://www.terraform.io/docs/providers/newrelic/d/entity.html) data source instead. This feature may be removed in the next major release.
     * 
     * Use this data source to get information about a specific application in New Relic that already exists. More information on Terraform&#39;s data sources can be found here.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetApplicationArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertCondition;
     * import com.pulumi.newrelic.AlertConditionArgs;
     * import com.pulumi.newrelic.inputs.AlertConditionTermArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getApplication(GetApplicationArgs.builder()
     *             .name("my-app")
     *             .build());
     * 
     *         var foo = new AlertPolicy("foo", AlertPolicyArgs.builder()
     *             .name("foo")
     *             .build());
     * 
     *         var fooAlertCondition = new AlertCondition("fooAlertCondition", AlertConditionArgs.builder()
     *             .policyId(foo.id())
     *             .name("foo")
     *             .type("apm_app_metric")
     *             .entities(app.id())
     *             .metric("apdex")
     *             .runbookUrl("https://www.example.com")
     *             .terms(AlertConditionTermArgs.builder()
     *                 .duration(5)
     *                 .operator("below")
     *                 .priority("critical")
     *                 .threshold(0.75)
     *                 .timeFunction("all")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetApplicationResult> getApplication(GetApplicationArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getApplication:getApplication", TypeShape.of(GetApplicationResult.class), args, Utilities.withVersion(options));
    }
    /**
     * &gt; **DEPRECATED** Use at your own risk. Use the [`newrelic.getEntity`](https://www.terraform.io/docs/providers/newrelic/d/entity.html) data source instead. This feature may be removed in the next major release.
     * 
     * Use this data source to get information about a specific application in New Relic that already exists. More information on Terraform&#39;s data sources can be found here.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetApplicationArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertCondition;
     * import com.pulumi.newrelic.AlertConditionArgs;
     * import com.pulumi.newrelic.inputs.AlertConditionTermArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getApplication(GetApplicationArgs.builder()
     *             .name("my-app")
     *             .build());
     * 
     *         var foo = new AlertPolicy("foo", AlertPolicyArgs.builder()
     *             .name("foo")
     *             .build());
     * 
     *         var fooAlertCondition = new AlertCondition("fooAlertCondition", AlertConditionArgs.builder()
     *             .policyId(foo.id())
     *             .name("foo")
     *             .type("apm_app_metric")
     *             .entities(app.id())
     *             .metric("apdex")
     *             .runbookUrl("https://www.example.com")
     *             .terms(AlertConditionTermArgs.builder()
     *                 .duration(5)
     *                 .operator("below")
     *                 .priority("critical")
     *                 .threshold(0.75)
     *                 .timeFunction("all")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetApplicationResult> getApplication(GetApplicationArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getApplication:getApplication", TypeShape.of(GetApplicationResult.class), args, Utilities.withVersion(options));
    }
    /**
     * &gt; **DEPRECATED** Use at your own risk. Use the [`newrelic.getEntity`](https://www.terraform.io/docs/providers/newrelic/d/entity.html) data source instead. This feature may be removed in the next major release.
     * 
     * Use this data source to get information about a specific application in New Relic that already exists. More information on Terraform&#39;s data sources can be found here.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetApplicationArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertCondition;
     * import com.pulumi.newrelic.AlertConditionArgs;
     * import com.pulumi.newrelic.inputs.AlertConditionTermArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getApplication(GetApplicationArgs.builder()
     *             .name("my-app")
     *             .build());
     * 
     *         var foo = new AlertPolicy("foo", AlertPolicyArgs.builder()
     *             .name("foo")
     *             .build());
     * 
     *         var fooAlertCondition = new AlertCondition("fooAlertCondition", AlertConditionArgs.builder()
     *             .policyId(foo.id())
     *             .name("foo")
     *             .type("apm_app_metric")
     *             .entities(app.id())
     *             .metric("apdex")
     *             .runbookUrl("https://www.example.com")
     *             .terms(AlertConditionTermArgs.builder()
     *                 .duration(5)
     *                 .operator("below")
     *                 .priority("critical")
     *                 .threshold(0.75)
     *                 .timeFunction("all")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetApplicationResult> getApplicationPlain(GetApplicationPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getApplication:getApplication", TypeShape.of(GetApplicationResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to fetch the ID of an authentication domain belonging to your account, matching the specified name.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name("Test Authentication Domain")
     *             .build());
     * 
     *         ctx.export("foo", foo.id());
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetAuthenticationDomainResult> getAuthenticationDomain(GetAuthenticationDomainArgs args) {
        return getAuthenticationDomain(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to fetch the ID of an authentication domain belonging to your account, matching the specified name.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name("Test Authentication Domain")
     *             .build());
     * 
     *         ctx.export("foo", foo.id());
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetAuthenticationDomainResult> getAuthenticationDomainPlain(GetAuthenticationDomainPlainArgs args) {
        return getAuthenticationDomainPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to fetch the ID of an authentication domain belonging to your account, matching the specified name.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name("Test Authentication Domain")
     *             .build());
     * 
     *         ctx.export("foo", foo.id());
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetAuthenticationDomainResult> getAuthenticationDomain(GetAuthenticationDomainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getAuthenticationDomain:getAuthenticationDomain", TypeShape.of(GetAuthenticationDomainResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to fetch the ID of an authentication domain belonging to your account, matching the specified name.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name("Test Authentication Domain")
     *             .build());
     * 
     *         ctx.export("foo", foo.id());
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetAuthenticationDomainResult> getAuthenticationDomain(GetAuthenticationDomainArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getAuthenticationDomain:getAuthenticationDomain", TypeShape.of(GetAuthenticationDomainResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to fetch the ID of an authentication domain belonging to your account, matching the specified name.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name("Test Authentication Domain")
     *             .build());
     * 
     *         ctx.export("foo", foo.id());
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetAuthenticationDomainResult> getAuthenticationDomainPlain(GetAuthenticationDomainPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getAuthenticationDomain:getAuthenticationDomain", TypeShape.of(GetAuthenticationDomainResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific cloud account linked to New Relic.
     * Accounts can be located by a combination of New Relic Account ID, name and cloud provider (aws, gcp, azure, etc). Name and cloud provider are required attributes. If no accountId is specified on the resource the provider level accountId will be used.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetCloudAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var account = NewrelicFunctions.getCloudAccount(GetCloudAccountArgs.builder()
     *             .accountId("12345")
     *             .cloudProvider("aws")
     *             .name("my aws account")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetCloudAccountResult> getCloudAccount(GetCloudAccountArgs args) {
        return getCloudAccount(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific cloud account linked to New Relic.
     * Accounts can be located by a combination of New Relic Account ID, name and cloud provider (aws, gcp, azure, etc). Name and cloud provider are required attributes. If no accountId is specified on the resource the provider level accountId will be used.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetCloudAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var account = NewrelicFunctions.getCloudAccount(GetCloudAccountArgs.builder()
     *             .accountId("12345")
     *             .cloudProvider("aws")
     *             .name("my aws account")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetCloudAccountResult> getCloudAccountPlain(GetCloudAccountPlainArgs args) {
        return getCloudAccountPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific cloud account linked to New Relic.
     * Accounts can be located by a combination of New Relic Account ID, name and cloud provider (aws, gcp, azure, etc). Name and cloud provider are required attributes. If no accountId is specified on the resource the provider level accountId will be used.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetCloudAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var account = NewrelicFunctions.getCloudAccount(GetCloudAccountArgs.builder()
     *             .accountId("12345")
     *             .cloudProvider("aws")
     *             .name("my aws account")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetCloudAccountResult> getCloudAccount(GetCloudAccountArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getCloudAccount:getCloudAccount", TypeShape.of(GetCloudAccountResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific cloud account linked to New Relic.
     * Accounts can be located by a combination of New Relic Account ID, name and cloud provider (aws, gcp, azure, etc). Name and cloud provider are required attributes. If no accountId is specified on the resource the provider level accountId will be used.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetCloudAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var account = NewrelicFunctions.getCloudAccount(GetCloudAccountArgs.builder()
     *             .accountId("12345")
     *             .cloudProvider("aws")
     *             .name("my aws account")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetCloudAccountResult> getCloudAccount(GetCloudAccountArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getCloudAccount:getCloudAccount", TypeShape.of(GetCloudAccountResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific cloud account linked to New Relic.
     * Accounts can be located by a combination of New Relic Account ID, name and cloud provider (aws, gcp, azure, etc). Name and cloud provider are required attributes. If no accountId is specified on the resource the provider level accountId will be used.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetCloudAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var account = NewrelicFunctions.getCloudAccount(GetCloudAccountArgs.builder()
     *             .accountId("12345")
     *             .cloudProvider("aws")
     *             .name("my aws account")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetCloudAccountResult> getCloudAccountPlain(GetCloudAccountPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getCloudAccount:getCloudAccount", TypeShape.of(GetCloudAccountResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific entity in New Relic One that already exists. More information on Terraform&#39;s data sources can be found here.
     * 
     * &gt; **IMPORTANT!** Version 2.0.0 of the New Relic Terraform Provider introduces some [additional requirements](https://www.terraform.io/providers/newrelic/newrelic/latest/docs/guides/migration_guide_v2) for configuring the provider.
     * &lt;br&gt;&lt;br&gt;
     * Before upgrading to version 2.0.0 or later, it is recommended to upgrade to the most recent 1.x version of the provider and ensure that your environment successfully runs `pulumi preview` without unexpected changes.
     * 
     * ### Example: Filter By Account ID
     * 
     * The default behaviour of this data source is to retrieve entities matching the specified parameters (such as `name`, `domain`, `type`) from NerdGraph with the credentials specified in the configuration of the provider (account ID and API Key), filter them by the account ID specified in the configuration of the provider, and return the first match.
     * 
     * This would mean, if no entity with the specified search parameters is found associated with the account ID in the configuration of the provider, i.e. `NEW_RELIC_ACCOUNT_ID`, an error is thrown, stating that no matching entity has been found.
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // The entity returned by this configuration would have to 
     *         // belong to the account_id specified in the provider 
     *         // configuration, i.e. NEW_RELIC_ACCOUNT_ID.
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name("my-app")
     *             .domain("APM")
     *             .type("APPLICATION")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * However, in order to cater to scenarios in which it could be necessary to retrieve an entity belonging to a subaccount using the account ID and API Key of the parent account (for instance, when entities with identical names are present in both the parent account and subaccounts, since matching entities from subaccounts too are returned by NerdGraph), the `accountId` attribute of this data source may be availed. This ensures that the account ID in the configuration of the provider, used to filter entities returned by the API is now overridden by the `accountId` specified in the configuration; i.e., in the below example, the data source would now return an entity matching the specified `name`, belonging to the account with the ID `accountId`.
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // The entity returned by this configuration, unlike in 
     *         // the above example, would have to belong to the account_id 
     *         // specified in the configuration below, i.e. 654321.
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name("my-app")
     *             .accountId("654321")
     *             .domain("APM")
     *             .type("APPLICATION")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * The following example explains a use case along the lines of the aforementioned; using the `accountId` argument in the data source to allow the filtering criteria to be the `accountId` specified (of the subaccount), and not the account ID in the provider configuration.
     * 
     * In simpler terms, when entities are queried from the parent account, entities with matching names are returned from subaccounts too, hence, specifying the `accountId` of the subaccount in the configuration allows the entity returned to belong to the subaccount with `accountId`.
     * ### Query for an OTEL entity
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name("my-otel-app")
     *             .domain("EXT")
     *             .type("SERVICE")
     *             .tags(GetEntityTagArgs.builder()
     *                 .key("accountID")
     *                 .value("12345")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * ### Query for an entity by type (AWS Lambda entity in this example)
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name("my_lambda_trace")
     *             .type("AWSLAMBDAFUNCTION")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * ### Using the `entityTags` Attribute to Fetch Tags Associated with the Entity
     * 
     * As stated above in the **Attributes Reference** section, while the attribute `entityTags` helps retrieve tags associated with the entity fetched by the data source, the tags are returned as a JSON-encoded string and not a conventional list or a map, owing to a couple of design considerations; which is why one would need to use the Terraform function `jsondecode()`, along with the attribute `entityTags` in order to convert the JSON-encoded string into a map with key-value pairs.
     * 
     * The following is an illustration of the aforementioned scenario. It may be observed that a key-value pair version of the JSON-encoded string exported by `entityTags` is written to the variable `keyValueMaps` , using the `jsondecode()` function.
     * 
     * The value of `local.key_value_map`  would look like the following.
     * 
     */
    public static Output<GetEntityResult> getEntity(GetEntityArgs args) {
        return getEntity(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific entity in New Relic One that already exists. More information on Terraform&#39;s data sources can be found here.
     * 
     * &gt; **IMPORTANT!** Version 2.0.0 of the New Relic Terraform Provider introduces some [additional requirements](https://www.terraform.io/providers/newrelic/newrelic/latest/docs/guides/migration_guide_v2) for configuring the provider.
     * &lt;br&gt;&lt;br&gt;
     * Before upgrading to version 2.0.0 or later, it is recommended to upgrade to the most recent 1.x version of the provider and ensure that your environment successfully runs `pulumi preview` without unexpected changes.
     * 
     * ### Example: Filter By Account ID
     * 
     * The default behaviour of this data source is to retrieve entities matching the specified parameters (such as `name`, `domain`, `type`) from NerdGraph with the credentials specified in the configuration of the provider (account ID and API Key), filter them by the account ID specified in the configuration of the provider, and return the first match.
     * 
     * This would mean, if no entity with the specified search parameters is found associated with the account ID in the configuration of the provider, i.e. `NEW_RELIC_ACCOUNT_ID`, an error is thrown, stating that no matching entity has been found.
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // The entity returned by this configuration would have to 
     *         // belong to the account_id specified in the provider 
     *         // configuration, i.e. NEW_RELIC_ACCOUNT_ID.
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name("my-app")
     *             .domain("APM")
     *             .type("APPLICATION")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * However, in order to cater to scenarios in which it could be necessary to retrieve an entity belonging to a subaccount using the account ID and API Key of the parent account (for instance, when entities with identical names are present in both the parent account and subaccounts, since matching entities from subaccounts too are returned by NerdGraph), the `accountId` attribute of this data source may be availed. This ensures that the account ID in the configuration of the provider, used to filter entities returned by the API is now overridden by the `accountId` specified in the configuration; i.e., in the below example, the data source would now return an entity matching the specified `name`, belonging to the account with the ID `accountId`.
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // The entity returned by this configuration, unlike in 
     *         // the above example, would have to belong to the account_id 
     *         // specified in the configuration below, i.e. 654321.
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name("my-app")
     *             .accountId("654321")
     *             .domain("APM")
     *             .type("APPLICATION")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * The following example explains a use case along the lines of the aforementioned; using the `accountId` argument in the data source to allow the filtering criteria to be the `accountId` specified (of the subaccount), and not the account ID in the provider configuration.
     * 
     * In simpler terms, when entities are queried from the parent account, entities with matching names are returned from subaccounts too, hence, specifying the `accountId` of the subaccount in the configuration allows the entity returned to belong to the subaccount with `accountId`.
     * ### Query for an OTEL entity
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name("my-otel-app")
     *             .domain("EXT")
     *             .type("SERVICE")
     *             .tags(GetEntityTagArgs.builder()
     *                 .key("accountID")
     *                 .value("12345")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * ### Query for an entity by type (AWS Lambda entity in this example)
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name("my_lambda_trace")
     *             .type("AWSLAMBDAFUNCTION")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * ### Using the `entityTags` Attribute to Fetch Tags Associated with the Entity
     * 
     * As stated above in the **Attributes Reference** section, while the attribute `entityTags` helps retrieve tags associated with the entity fetched by the data source, the tags are returned as a JSON-encoded string and not a conventional list or a map, owing to a couple of design considerations; which is why one would need to use the Terraform function `jsondecode()`, along with the attribute `entityTags` in order to convert the JSON-encoded string into a map with key-value pairs.
     * 
     * The following is an illustration of the aforementioned scenario. It may be observed that a key-value pair version of the JSON-encoded string exported by `entityTags` is written to the variable `keyValueMaps` , using the `jsondecode()` function.
     * 
     * The value of `local.key_value_map`  would look like the following.
     * 
     */
    public static CompletableFuture<GetEntityResult> getEntityPlain(GetEntityPlainArgs args) {
        return getEntityPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific entity in New Relic One that already exists. More information on Terraform&#39;s data sources can be found here.
     * 
     * &gt; **IMPORTANT!** Version 2.0.0 of the New Relic Terraform Provider introduces some [additional requirements](https://www.terraform.io/providers/newrelic/newrelic/latest/docs/guides/migration_guide_v2) for configuring the provider.
     * &lt;br&gt;&lt;br&gt;
     * Before upgrading to version 2.0.0 or later, it is recommended to upgrade to the most recent 1.x version of the provider and ensure that your environment successfully runs `pulumi preview` without unexpected changes.
     * 
     * ### Example: Filter By Account ID
     * 
     * The default behaviour of this data source is to retrieve entities matching the specified parameters (such as `name`, `domain`, `type`) from NerdGraph with the credentials specified in the configuration of the provider (account ID and API Key), filter them by the account ID specified in the configuration of the provider, and return the first match.
     * 
     * This would mean, if no entity with the specified search parameters is found associated with the account ID in the configuration of the provider, i.e. `NEW_RELIC_ACCOUNT_ID`, an error is thrown, stating that no matching entity has been found.
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // The entity returned by this configuration would have to 
     *         // belong to the account_id specified in the provider 
     *         // configuration, i.e. NEW_RELIC_ACCOUNT_ID.
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name("my-app")
     *             .domain("APM")
     *             .type("APPLICATION")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * However, in order to cater to scenarios in which it could be necessary to retrieve an entity belonging to a subaccount using the account ID and API Key of the parent account (for instance, when entities with identical names are present in both the parent account and subaccounts, since matching entities from subaccounts too are returned by NerdGraph), the `accountId` attribute of this data source may be availed. This ensures that the account ID in the configuration of the provider, used to filter entities returned by the API is now overridden by the `accountId` specified in the configuration; i.e., in the below example, the data source would now return an entity matching the specified `name`, belonging to the account with the ID `accountId`.
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // The entity returned by this configuration, unlike in 
     *         // the above example, would have to belong to the account_id 
     *         // specified in the configuration below, i.e. 654321.
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name("my-app")
     *             .accountId("654321")
     *             .domain("APM")
     *             .type("APPLICATION")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * The following example explains a use case along the lines of the aforementioned; using the `accountId` argument in the data source to allow the filtering criteria to be the `accountId` specified (of the subaccount), and not the account ID in the provider configuration.
     * 
     * In simpler terms, when entities are queried from the parent account, entities with matching names are returned from subaccounts too, hence, specifying the `accountId` of the subaccount in the configuration allows the entity returned to belong to the subaccount with `accountId`.
     * ### Query for an OTEL entity
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name("my-otel-app")
     *             .domain("EXT")
     *             .type("SERVICE")
     *             .tags(GetEntityTagArgs.builder()
     *                 .key("accountID")
     *                 .value("12345")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * ### Query for an entity by type (AWS Lambda entity in this example)
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name("my_lambda_trace")
     *             .type("AWSLAMBDAFUNCTION")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * ### Using the `entityTags` Attribute to Fetch Tags Associated with the Entity
     * 
     * As stated above in the **Attributes Reference** section, while the attribute `entityTags` helps retrieve tags associated with the entity fetched by the data source, the tags are returned as a JSON-encoded string and not a conventional list or a map, owing to a couple of design considerations; which is why one would need to use the Terraform function `jsondecode()`, along with the attribute `entityTags` in order to convert the JSON-encoded string into a map with key-value pairs.
     * 
     * The following is an illustration of the aforementioned scenario. It may be observed that a key-value pair version of the JSON-encoded string exported by `entityTags` is written to the variable `keyValueMaps` , using the `jsondecode()` function.
     * 
     * The value of `local.key_value_map`  would look like the following.
     * 
     */
    public static Output<GetEntityResult> getEntity(GetEntityArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getEntity:getEntity", TypeShape.of(GetEntityResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific entity in New Relic One that already exists. More information on Terraform&#39;s data sources can be found here.
     * 
     * &gt; **IMPORTANT!** Version 2.0.0 of the New Relic Terraform Provider introduces some [additional requirements](https://www.terraform.io/providers/newrelic/newrelic/latest/docs/guides/migration_guide_v2) for configuring the provider.
     * &lt;br&gt;&lt;br&gt;
     * Before upgrading to version 2.0.0 or later, it is recommended to upgrade to the most recent 1.x version of the provider and ensure that your environment successfully runs `pulumi preview` without unexpected changes.
     * 
     * ### Example: Filter By Account ID
     * 
     * The default behaviour of this data source is to retrieve entities matching the specified parameters (such as `name`, `domain`, `type`) from NerdGraph with the credentials specified in the configuration of the provider (account ID and API Key), filter them by the account ID specified in the configuration of the provider, and return the first match.
     * 
     * This would mean, if no entity with the specified search parameters is found associated with the account ID in the configuration of the provider, i.e. `NEW_RELIC_ACCOUNT_ID`, an error is thrown, stating that no matching entity has been found.
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // The entity returned by this configuration would have to 
     *         // belong to the account_id specified in the provider 
     *         // configuration, i.e. NEW_RELIC_ACCOUNT_ID.
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name("my-app")
     *             .domain("APM")
     *             .type("APPLICATION")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * However, in order to cater to scenarios in which it could be necessary to retrieve an entity belonging to a subaccount using the account ID and API Key of the parent account (for instance, when entities with identical names are present in both the parent account and subaccounts, since matching entities from subaccounts too are returned by NerdGraph), the `accountId` attribute of this data source may be availed. This ensures that the account ID in the configuration of the provider, used to filter entities returned by the API is now overridden by the `accountId` specified in the configuration; i.e., in the below example, the data source would now return an entity matching the specified `name`, belonging to the account with the ID `accountId`.
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // The entity returned by this configuration, unlike in 
     *         // the above example, would have to belong to the account_id 
     *         // specified in the configuration below, i.e. 654321.
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name("my-app")
     *             .accountId("654321")
     *             .domain("APM")
     *             .type("APPLICATION")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * The following example explains a use case along the lines of the aforementioned; using the `accountId` argument in the data source to allow the filtering criteria to be the `accountId` specified (of the subaccount), and not the account ID in the provider configuration.
     * 
     * In simpler terms, when entities are queried from the parent account, entities with matching names are returned from subaccounts too, hence, specifying the `accountId` of the subaccount in the configuration allows the entity returned to belong to the subaccount with `accountId`.
     * ### Query for an OTEL entity
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name("my-otel-app")
     *             .domain("EXT")
     *             .type("SERVICE")
     *             .tags(GetEntityTagArgs.builder()
     *                 .key("accountID")
     *                 .value("12345")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * ### Query for an entity by type (AWS Lambda entity in this example)
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name("my_lambda_trace")
     *             .type("AWSLAMBDAFUNCTION")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * ### Using the `entityTags` Attribute to Fetch Tags Associated with the Entity
     * 
     * As stated above in the **Attributes Reference** section, while the attribute `entityTags` helps retrieve tags associated with the entity fetched by the data source, the tags are returned as a JSON-encoded string and not a conventional list or a map, owing to a couple of design considerations; which is why one would need to use the Terraform function `jsondecode()`, along with the attribute `entityTags` in order to convert the JSON-encoded string into a map with key-value pairs.
     * 
     * The following is an illustration of the aforementioned scenario. It may be observed that a key-value pair version of the JSON-encoded string exported by `entityTags` is written to the variable `keyValueMaps` , using the `jsondecode()` function.
     * 
     * The value of `local.key_value_map`  would look like the following.
     * 
     */
    public static Output<GetEntityResult> getEntity(GetEntityArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getEntity:getEntity", TypeShape.of(GetEntityResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific entity in New Relic One that already exists. More information on Terraform&#39;s data sources can be found here.
     * 
     * &gt; **IMPORTANT!** Version 2.0.0 of the New Relic Terraform Provider introduces some [additional requirements](https://www.terraform.io/providers/newrelic/newrelic/latest/docs/guides/migration_guide_v2) for configuring the provider.
     * &lt;br&gt;&lt;br&gt;
     * Before upgrading to version 2.0.0 or later, it is recommended to upgrade to the most recent 1.x version of the provider and ensure that your environment successfully runs `pulumi preview` without unexpected changes.
     * 
     * ### Example: Filter By Account ID
     * 
     * The default behaviour of this data source is to retrieve entities matching the specified parameters (such as `name`, `domain`, `type`) from NerdGraph with the credentials specified in the configuration of the provider (account ID and API Key), filter them by the account ID specified in the configuration of the provider, and return the first match.
     * 
     * This would mean, if no entity with the specified search parameters is found associated with the account ID in the configuration of the provider, i.e. `NEW_RELIC_ACCOUNT_ID`, an error is thrown, stating that no matching entity has been found.
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // The entity returned by this configuration would have to 
     *         // belong to the account_id specified in the provider 
     *         // configuration, i.e. NEW_RELIC_ACCOUNT_ID.
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name("my-app")
     *             .domain("APM")
     *             .type("APPLICATION")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * However, in order to cater to scenarios in which it could be necessary to retrieve an entity belonging to a subaccount using the account ID and API Key of the parent account (for instance, when entities with identical names are present in both the parent account and subaccounts, since matching entities from subaccounts too are returned by NerdGraph), the `accountId` attribute of this data source may be availed. This ensures that the account ID in the configuration of the provider, used to filter entities returned by the API is now overridden by the `accountId` specified in the configuration; i.e., in the below example, the data source would now return an entity matching the specified `name`, belonging to the account with the ID `accountId`.
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // The entity returned by this configuration, unlike in 
     *         // the above example, would have to belong to the account_id 
     *         // specified in the configuration below, i.e. 654321.
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name("my-app")
     *             .accountId("654321")
     *             .domain("APM")
     *             .type("APPLICATION")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * The following example explains a use case along the lines of the aforementioned; using the `accountId` argument in the data source to allow the filtering criteria to be the `accountId` specified (of the subaccount), and not the account ID in the provider configuration.
     * 
     * In simpler terms, when entities are queried from the parent account, entities with matching names are returned from subaccounts too, hence, specifying the `accountId` of the subaccount in the configuration allows the entity returned to belong to the subaccount with `accountId`.
     * ### Query for an OTEL entity
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name("my-otel-app")
     *             .domain("EXT")
     *             .type("SERVICE")
     *             .tags(GetEntityTagArgs.builder()
     *                 .key("accountID")
     *                 .value("12345")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * ### Query for an entity by type (AWS Lambda entity in this example)
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name("my_lambda_trace")
     *             .type("AWSLAMBDAFUNCTION")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * ### Using the `entityTags` Attribute to Fetch Tags Associated with the Entity
     * 
     * As stated above in the **Attributes Reference** section, while the attribute `entityTags` helps retrieve tags associated with the entity fetched by the data source, the tags are returned as a JSON-encoded string and not a conventional list or a map, owing to a couple of design considerations; which is why one would need to use the Terraform function `jsondecode()`, along with the attribute `entityTags` in order to convert the JSON-encoded string into a map with key-value pairs.
     * 
     * The following is an illustration of the aforementioned scenario. It may be observed that a key-value pair version of the JSON-encoded string exported by `entityTags` is written to the variable `keyValueMaps` , using the `jsondecode()` function.
     * 
     * The value of `local.key_value_map`  would look like the following.
     * 
     */
    public static CompletableFuture<GetEntityResult> getEntityPlain(GetEntityPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getEntity:getEntity", TypeShape.of(GetEntityResult.class), args, Utilities.withVersion(options));
    }
    /**
     * The `newrelic.Group` data source helps search for a group by its name and retrieve the ID of the matching group and other associated attributes.
     * 
     * ## Example Usage
     * 
     * The below example illustrates fetching the ID of a group (and IDs of users who belong to the group, if any) using the required arguments.
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import com.pulumi.newrelic.inputs.GetGroupArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name("Test Authentication Domain")
     *             .build());
     * 
     *         final var fooGetGroup = NewrelicFunctions.getGroup(GetGroupArgs.builder()
     *             .authenticationDomainId(foo.id())
     *             .name("Test Group")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * ## Additional Examples
     * 
     * The following example demonstrates utilizing attributes exported by this data source.
     * 
     * In order to directly reference the attributes `id` and `userIds` from this data source, you can use the syntax `data.newrelic_group.foo.id` and `data.newrelic_group.foo.user_ids`, respectively. However, if you need to assign these values to local variables and perform further processing (such as conditionally formatting the `userIds` attribute as shown in the example below), consider using the provided configuration. These variables can then be accessed elsewhere using the syntax `local.id` and `local.user_id`, respectively.
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import com.pulumi.newrelic.inputs.GetGroupArgs;
     * import com.pulumi.std.StdFunctions;
     * import com.pulumi.std.inputs.JoinArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name("Test Authentication Domain")
     *             .build());
     * 
     *         final var fooGetGroup = NewrelicFunctions.getGroup(GetGroupArgs.builder()
     *             .authenticationDomainId(foo.id())
     *             .name("Test Group")
     *             .build());
     * 
     *         final var id = fooGetGroup.id();
     * 
     *         final var userIds = fooGetGroup.userIds().length().applyValue(_length -> _length > 0 ? StdFunctions.join(JoinArgs.builder()
     *             .separator(", ")
     *             .input(fooGetGroup.userIds())
     *             .build()).result() : "");
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetGroupResult> getGroup(GetGroupArgs args) {
        return getGroup(args, InvokeOptions.Empty);
    }
    /**
     * The `newrelic.Group` data source helps search for a group by its name and retrieve the ID of the matching group and other associated attributes.
     * 
     * ## Example Usage
     * 
     * The below example illustrates fetching the ID of a group (and IDs of users who belong to the group, if any) using the required arguments.
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import com.pulumi.newrelic.inputs.GetGroupArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name("Test Authentication Domain")
     *             .build());
     * 
     *         final var fooGetGroup = NewrelicFunctions.getGroup(GetGroupArgs.builder()
     *             .authenticationDomainId(foo.id())
     *             .name("Test Group")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * ## Additional Examples
     * 
     * The following example demonstrates utilizing attributes exported by this data source.
     * 
     * In order to directly reference the attributes `id` and `userIds` from this data source, you can use the syntax `data.newrelic_group.foo.id` and `data.newrelic_group.foo.user_ids`, respectively. However, if you need to assign these values to local variables and perform further processing (such as conditionally formatting the `userIds` attribute as shown in the example below), consider using the provided configuration. These variables can then be accessed elsewhere using the syntax `local.id` and `local.user_id`, respectively.
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import com.pulumi.newrelic.inputs.GetGroupArgs;
     * import com.pulumi.std.StdFunctions;
     * import com.pulumi.std.inputs.JoinArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name("Test Authentication Domain")
     *             .build());
     * 
     *         final var fooGetGroup = NewrelicFunctions.getGroup(GetGroupArgs.builder()
     *             .authenticationDomainId(foo.id())
     *             .name("Test Group")
     *             .build());
     * 
     *         final var id = fooGetGroup.id();
     * 
     *         final var userIds = fooGetGroup.userIds().length().applyValue(_length -> _length > 0 ? StdFunctions.join(JoinArgs.builder()
     *             .separator(", ")
     *             .input(fooGetGroup.userIds())
     *             .build()).result() : "");
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetGroupResult> getGroupPlain(GetGroupPlainArgs args) {
        return getGroupPlain(args, InvokeOptions.Empty);
    }
    /**
     * The `newrelic.Group` data source helps search for a group by its name and retrieve the ID of the matching group and other associated attributes.
     * 
     * ## Example Usage
     * 
     * The below example illustrates fetching the ID of a group (and IDs of users who belong to the group, if any) using the required arguments.
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import com.pulumi.newrelic.inputs.GetGroupArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name("Test Authentication Domain")
     *             .build());
     * 
     *         final var fooGetGroup = NewrelicFunctions.getGroup(GetGroupArgs.builder()
     *             .authenticationDomainId(foo.id())
     *             .name("Test Group")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * ## Additional Examples
     * 
     * The following example demonstrates utilizing attributes exported by this data source.
     * 
     * In order to directly reference the attributes `id` and `userIds` from this data source, you can use the syntax `data.newrelic_group.foo.id` and `data.newrelic_group.foo.user_ids`, respectively. However, if you need to assign these values to local variables and perform further processing (such as conditionally formatting the `userIds` attribute as shown in the example below), consider using the provided configuration. These variables can then be accessed elsewhere using the syntax `local.id` and `local.user_id`, respectively.
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import com.pulumi.newrelic.inputs.GetGroupArgs;
     * import com.pulumi.std.StdFunctions;
     * import com.pulumi.std.inputs.JoinArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name("Test Authentication Domain")
     *             .build());
     * 
     *         final var fooGetGroup = NewrelicFunctions.getGroup(GetGroupArgs.builder()
     *             .authenticationDomainId(foo.id())
     *             .name("Test Group")
     *             .build());
     * 
     *         final var id = fooGetGroup.id();
     * 
     *         final var userIds = fooGetGroup.userIds().length().applyValue(_length -> _length > 0 ? StdFunctions.join(JoinArgs.builder()
     *             .separator(", ")
     *             .input(fooGetGroup.userIds())
     *             .build()).result() : "");
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetGroupResult> getGroup(GetGroupArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getGroup:getGroup", TypeShape.of(GetGroupResult.class), args, Utilities.withVersion(options));
    }
    /**
     * The `newrelic.Group` data source helps search for a group by its name and retrieve the ID of the matching group and other associated attributes.
     * 
     * ## Example Usage
     * 
     * The below example illustrates fetching the ID of a group (and IDs of users who belong to the group, if any) using the required arguments.
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import com.pulumi.newrelic.inputs.GetGroupArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name("Test Authentication Domain")
     *             .build());
     * 
     *         final var fooGetGroup = NewrelicFunctions.getGroup(GetGroupArgs.builder()
     *             .authenticationDomainId(foo.id())
     *             .name("Test Group")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * ## Additional Examples
     * 
     * The following example demonstrates utilizing attributes exported by this data source.
     * 
     * In order to directly reference the attributes `id` and `userIds` from this data source, you can use the syntax `data.newrelic_group.foo.id` and `data.newrelic_group.foo.user_ids`, respectively. However, if you need to assign these values to local variables and perform further processing (such as conditionally formatting the `userIds` attribute as shown in the example below), consider using the provided configuration. These variables can then be accessed elsewhere using the syntax `local.id` and `local.user_id`, respectively.
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import com.pulumi.newrelic.inputs.GetGroupArgs;
     * import com.pulumi.std.StdFunctions;
     * import com.pulumi.std.inputs.JoinArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name("Test Authentication Domain")
     *             .build());
     * 
     *         final var fooGetGroup = NewrelicFunctions.getGroup(GetGroupArgs.builder()
     *             .authenticationDomainId(foo.id())
     *             .name("Test Group")
     *             .build());
     * 
     *         final var id = fooGetGroup.id();
     * 
     *         final var userIds = fooGetGroup.userIds().length().applyValue(_length -> _length > 0 ? StdFunctions.join(JoinArgs.builder()
     *             .separator(", ")
     *             .input(fooGetGroup.userIds())
     *             .build()).result() : "");
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetGroupResult> getGroup(GetGroupArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getGroup:getGroup", TypeShape.of(GetGroupResult.class), args, Utilities.withVersion(options));
    }
    /**
     * The `newrelic.Group` data source helps search for a group by its name and retrieve the ID of the matching group and other associated attributes.
     * 
     * ## Example Usage
     * 
     * The below example illustrates fetching the ID of a group (and IDs of users who belong to the group, if any) using the required arguments.
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import com.pulumi.newrelic.inputs.GetGroupArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name("Test Authentication Domain")
     *             .build());
     * 
     *         final var fooGetGroup = NewrelicFunctions.getGroup(GetGroupArgs.builder()
     *             .authenticationDomainId(foo.id())
     *             .name("Test Group")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * ## Additional Examples
     * 
     * The following example demonstrates utilizing attributes exported by this data source.
     * 
     * In order to directly reference the attributes `id` and `userIds` from this data source, you can use the syntax `data.newrelic_group.foo.id` and `data.newrelic_group.foo.user_ids`, respectively. However, if you need to assign these values to local variables and perform further processing (such as conditionally formatting the `userIds` attribute as shown in the example below), consider using the provided configuration. These variables can then be accessed elsewhere using the syntax `local.id` and `local.user_id`, respectively.
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import com.pulumi.newrelic.inputs.GetGroupArgs;
     * import com.pulumi.std.StdFunctions;
     * import com.pulumi.std.inputs.JoinArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name("Test Authentication Domain")
     *             .build());
     * 
     *         final var fooGetGroup = NewrelicFunctions.getGroup(GetGroupArgs.builder()
     *             .authenticationDomainId(foo.id())
     *             .name("Test Group")
     *             .build());
     * 
     *         final var id = fooGetGroup.id();
     * 
     *         final var userIds = fooGetGroup.userIds().length().applyValue(_length -> _length > 0 ? StdFunctions.join(JoinArgs.builder()
     *             .separator(", ")
     *             .input(fooGetGroup.userIds())
     *             .build()).result() : "");
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetGroupResult> getGroupPlain(GetGroupPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getGroup:getGroup", TypeShape.of(GetGroupResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific key transaction in New Relic that already exists.  More information on Terraform&#39;s data sources can be found here.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetKeyTransactionArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertCondition;
     * import com.pulumi.newrelic.AlertConditionArgs;
     * import com.pulumi.newrelic.inputs.AlertConditionTermArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var txn = NewrelicFunctions.getKeyTransaction(GetKeyTransactionArgs.builder()
     *             .name("txn")
     *             .build());
     * 
     *         var foo = new AlertPolicy("foo", AlertPolicyArgs.builder()
     *             .name("foo")
     *             .build());
     * 
     *         var fooAlertCondition = new AlertCondition("fooAlertCondition", AlertConditionArgs.builder()
     *             .policyId(foo.id())
     *             .name("foo")
     *             .type("apm_kt_metric")
     *             .entities(txn.id())
     *             .metric("error_percentage")
     *             .runbookUrl("https://www.example.com")
     *             .terms(AlertConditionTermArgs.builder()
     *                 .duration(5)
     *                 .operator("below")
     *                 .priority("critical")
     *                 .threshold(0.75)
     *                 .timeFunction("all")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetKeyTransactionResult> getKeyTransaction(GetKeyTransactionArgs args) {
        return getKeyTransaction(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific key transaction in New Relic that already exists.  More information on Terraform&#39;s data sources can be found here.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetKeyTransactionArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertCondition;
     * import com.pulumi.newrelic.AlertConditionArgs;
     * import com.pulumi.newrelic.inputs.AlertConditionTermArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var txn = NewrelicFunctions.getKeyTransaction(GetKeyTransactionArgs.builder()
     *             .name("txn")
     *             .build());
     * 
     *         var foo = new AlertPolicy("foo", AlertPolicyArgs.builder()
     *             .name("foo")
     *             .build());
     * 
     *         var fooAlertCondition = new AlertCondition("fooAlertCondition", AlertConditionArgs.builder()
     *             .policyId(foo.id())
     *             .name("foo")
     *             .type("apm_kt_metric")
     *             .entities(txn.id())
     *             .metric("error_percentage")
     *             .runbookUrl("https://www.example.com")
     *             .terms(AlertConditionTermArgs.builder()
     *                 .duration(5)
     *                 .operator("below")
     *                 .priority("critical")
     *                 .threshold(0.75)
     *                 .timeFunction("all")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetKeyTransactionResult> getKeyTransactionPlain(GetKeyTransactionPlainArgs args) {
        return getKeyTransactionPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific key transaction in New Relic that already exists.  More information on Terraform&#39;s data sources can be found here.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetKeyTransactionArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertCondition;
     * import com.pulumi.newrelic.AlertConditionArgs;
     * import com.pulumi.newrelic.inputs.AlertConditionTermArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var txn = NewrelicFunctions.getKeyTransaction(GetKeyTransactionArgs.builder()
     *             .name("txn")
     *             .build());
     * 
     *         var foo = new AlertPolicy("foo", AlertPolicyArgs.builder()
     *             .name("foo")
     *             .build());
     * 
     *         var fooAlertCondition = new AlertCondition("fooAlertCondition", AlertConditionArgs.builder()
     *             .policyId(foo.id())
     *             .name("foo")
     *             .type("apm_kt_metric")
     *             .entities(txn.id())
     *             .metric("error_percentage")
     *             .runbookUrl("https://www.example.com")
     *             .terms(AlertConditionTermArgs.builder()
     *                 .duration(5)
     *                 .operator("below")
     *                 .priority("critical")
     *                 .threshold(0.75)
     *                 .timeFunction("all")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetKeyTransactionResult> getKeyTransaction(GetKeyTransactionArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getKeyTransaction:getKeyTransaction", TypeShape.of(GetKeyTransactionResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific key transaction in New Relic that already exists.  More information on Terraform&#39;s data sources can be found here.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetKeyTransactionArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertCondition;
     * import com.pulumi.newrelic.AlertConditionArgs;
     * import com.pulumi.newrelic.inputs.AlertConditionTermArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var txn = NewrelicFunctions.getKeyTransaction(GetKeyTransactionArgs.builder()
     *             .name("txn")
     *             .build());
     * 
     *         var foo = new AlertPolicy("foo", AlertPolicyArgs.builder()
     *             .name("foo")
     *             .build());
     * 
     *         var fooAlertCondition = new AlertCondition("fooAlertCondition", AlertConditionArgs.builder()
     *             .policyId(foo.id())
     *             .name("foo")
     *             .type("apm_kt_metric")
     *             .entities(txn.id())
     *             .metric("error_percentage")
     *             .runbookUrl("https://www.example.com")
     *             .terms(AlertConditionTermArgs.builder()
     *                 .duration(5)
     *                 .operator("below")
     *                 .priority("critical")
     *                 .threshold(0.75)
     *                 .timeFunction("all")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetKeyTransactionResult> getKeyTransaction(GetKeyTransactionArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getKeyTransaction:getKeyTransaction", TypeShape.of(GetKeyTransactionResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific key transaction in New Relic that already exists.  More information on Terraform&#39;s data sources can be found here.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetKeyTransactionArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertCondition;
     * import com.pulumi.newrelic.AlertConditionArgs;
     * import com.pulumi.newrelic.inputs.AlertConditionTermArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var txn = NewrelicFunctions.getKeyTransaction(GetKeyTransactionArgs.builder()
     *             .name("txn")
     *             .build());
     * 
     *         var foo = new AlertPolicy("foo", AlertPolicyArgs.builder()
     *             .name("foo")
     *             .build());
     * 
     *         var fooAlertCondition = new AlertCondition("fooAlertCondition", AlertConditionArgs.builder()
     *             .policyId(foo.id())
     *             .name("foo")
     *             .type("apm_kt_metric")
     *             .entities(txn.id())
     *             .metric("error_percentage")
     *             .runbookUrl("https://www.example.com")
     *             .terms(AlertConditionTermArgs.builder()
     *                 .duration(5)
     *                 .operator("below")
     *                 .priority("critical")
     *                 .threshold(0.75)
     *                 .timeFunction("all")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetKeyTransactionResult> getKeyTransactionPlain(GetKeyTransactionPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getKeyTransaction:getKeyTransaction", TypeShape.of(GetKeyTransactionResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific notification destination in New Relic that already exists. More information on Terraform&#39;s data sources can be found here.
     * 
     * ## ID Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetNotificationDestinationArgs;
     * import com.pulumi.newrelic.NotificationChannel;
     * import com.pulumi.newrelic.NotificationChannelArgs;
     * import com.pulumi.newrelic.inputs.NotificationChannelPropertyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getNotificationDestination(GetNotificationDestinationArgs.builder()
     *             .id("1e543419-0c25-456a-9057-fb0eb310e60b")
     *             .build());
     * 
     *         // Resource
     *         var foo_channel = new NotificationChannel("foo-channel", NotificationChannelArgs.builder()
     *             .name("webhook-example")
     *             .type("WEBHOOK")
     *             .destinationId(foo.id())
     *             .product("IINT")
     *             .properties(NotificationChannelPropertyArgs.builder()
     *                 .key("payload")
     *                 .value("""
     * {
     * 	"name": "foo"
     * }                """)
     *                 .label("Payload Template")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * ## Name Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetNotificationDestinationArgs;
     * import com.pulumi.newrelic.NotificationChannel;
     * import com.pulumi.newrelic.NotificationChannelArgs;
     * import com.pulumi.newrelic.inputs.NotificationChannelPropertyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getNotificationDestination(GetNotificationDestinationArgs.builder()
     *             .name("webhook-destination")
     *             .build());
     * 
     *         // Resource
     *         var foo_channel = new NotificationChannel("foo-channel", NotificationChannelArgs.builder()
     *             .name("webhook-example")
     *             .type("WEBHOOK")
     *             .destinationId(foo.id())
     *             .product("IINT")
     *             .properties(NotificationChannelPropertyArgs.builder()
     *                 .key("payload")
     *                 .value("""
     * {
     * 	"name": "foo"
     * }                """)
     *                 .label("Payload Template")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetNotificationDestinationResult> getNotificationDestination() {
        return getNotificationDestination(GetNotificationDestinationArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific notification destination in New Relic that already exists. More information on Terraform&#39;s data sources can be found here.
     * 
     * ## ID Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetNotificationDestinationArgs;
     * import com.pulumi.newrelic.NotificationChannel;
     * import com.pulumi.newrelic.NotificationChannelArgs;
     * import com.pulumi.newrelic.inputs.NotificationChannelPropertyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getNotificationDestination(GetNotificationDestinationArgs.builder()
     *             .id("1e543419-0c25-456a-9057-fb0eb310e60b")
     *             .build());
     * 
     *         // Resource
     *         var foo_channel = new NotificationChannel("foo-channel", NotificationChannelArgs.builder()
     *             .name("webhook-example")
     *             .type("WEBHOOK")
     *             .destinationId(foo.id())
     *             .product("IINT")
     *             .properties(NotificationChannelPropertyArgs.builder()
     *                 .key("payload")
     *                 .value("""
     * {
     * 	"name": "foo"
     * }                """)
     *                 .label("Payload Template")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * ## Name Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetNotificationDestinationArgs;
     * import com.pulumi.newrelic.NotificationChannel;
     * import com.pulumi.newrelic.NotificationChannelArgs;
     * import com.pulumi.newrelic.inputs.NotificationChannelPropertyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getNotificationDestination(GetNotificationDestinationArgs.builder()
     *             .name("webhook-destination")
     *             .build());
     * 
     *         // Resource
     *         var foo_channel = new NotificationChannel("foo-channel", NotificationChannelArgs.builder()
     *             .name("webhook-example")
     *             .type("WEBHOOK")
     *             .destinationId(foo.id())
     *             .product("IINT")
     *             .properties(NotificationChannelPropertyArgs.builder()
     *                 .key("payload")
     *                 .value("""
     * {
     * 	"name": "foo"
     * }                """)
     *                 .label("Payload Template")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetNotificationDestinationResult> getNotificationDestinationPlain() {
        return getNotificationDestinationPlain(GetNotificationDestinationPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific notification destination in New Relic that already exists. More information on Terraform&#39;s data sources can be found here.
     * 
     * ## ID Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetNotificationDestinationArgs;
     * import com.pulumi.newrelic.NotificationChannel;
     * import com.pulumi.newrelic.NotificationChannelArgs;
     * import com.pulumi.newrelic.inputs.NotificationChannelPropertyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getNotificationDestination(GetNotificationDestinationArgs.builder()
     *             .id("1e543419-0c25-456a-9057-fb0eb310e60b")
     *             .build());
     * 
     *         // Resource
     *         var foo_channel = new NotificationChannel("foo-channel", NotificationChannelArgs.builder()
     *             .name("webhook-example")
     *             .type("WEBHOOK")
     *             .destinationId(foo.id())
     *             .product("IINT")
     *             .properties(NotificationChannelPropertyArgs.builder()
     *                 .key("payload")
     *                 .value("""
     * {
     * 	"name": "foo"
     * }                """)
     *                 .label("Payload Template")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * ## Name Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetNotificationDestinationArgs;
     * import com.pulumi.newrelic.NotificationChannel;
     * import com.pulumi.newrelic.NotificationChannelArgs;
     * import com.pulumi.newrelic.inputs.NotificationChannelPropertyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getNotificationDestination(GetNotificationDestinationArgs.builder()
     *             .name("webhook-destination")
     *             .build());
     * 
     *         // Resource
     *         var foo_channel = new NotificationChannel("foo-channel", NotificationChannelArgs.builder()
     *             .name("webhook-example")
     *             .type("WEBHOOK")
     *             .destinationId(foo.id())
     *             .product("IINT")
     *             .properties(NotificationChannelPropertyArgs.builder()
     *                 .key("payload")
     *                 .value("""
     * {
     * 	"name": "foo"
     * }                """)
     *                 .label("Payload Template")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetNotificationDestinationResult> getNotificationDestination(GetNotificationDestinationArgs args) {
        return getNotificationDestination(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific notification destination in New Relic that already exists. More information on Terraform&#39;s data sources can be found here.
     * 
     * ## ID Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetNotificationDestinationArgs;
     * import com.pulumi.newrelic.NotificationChannel;
     * import com.pulumi.newrelic.NotificationChannelArgs;
     * import com.pulumi.newrelic.inputs.NotificationChannelPropertyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getNotificationDestination(GetNotificationDestinationArgs.builder()
     *             .id("1e543419-0c25-456a-9057-fb0eb310e60b")
     *             .build());
     * 
     *         // Resource
     *         var foo_channel = new NotificationChannel("foo-channel", NotificationChannelArgs.builder()
     *             .name("webhook-example")
     *             .type("WEBHOOK")
     *             .destinationId(foo.id())
     *             .product("IINT")
     *             .properties(NotificationChannelPropertyArgs.builder()
     *                 .key("payload")
     *                 .value("""
     * {
     * 	"name": "foo"
     * }                """)
     *                 .label("Payload Template")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * ## Name Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetNotificationDestinationArgs;
     * import com.pulumi.newrelic.NotificationChannel;
     * import com.pulumi.newrelic.NotificationChannelArgs;
     * import com.pulumi.newrelic.inputs.NotificationChannelPropertyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getNotificationDestination(GetNotificationDestinationArgs.builder()
     *             .name("webhook-destination")
     *             .build());
     * 
     *         // Resource
     *         var foo_channel = new NotificationChannel("foo-channel", NotificationChannelArgs.builder()
     *             .name("webhook-example")
     *             .type("WEBHOOK")
     *             .destinationId(foo.id())
     *             .product("IINT")
     *             .properties(NotificationChannelPropertyArgs.builder()
     *                 .key("payload")
     *                 .value("""
     * {
     * 	"name": "foo"
     * }                """)
     *                 .label("Payload Template")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetNotificationDestinationResult> getNotificationDestinationPlain(GetNotificationDestinationPlainArgs args) {
        return getNotificationDestinationPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific notification destination in New Relic that already exists. More information on Terraform&#39;s data sources can be found here.
     * 
     * ## ID Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetNotificationDestinationArgs;
     * import com.pulumi.newrelic.NotificationChannel;
     * import com.pulumi.newrelic.NotificationChannelArgs;
     * import com.pulumi.newrelic.inputs.NotificationChannelPropertyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getNotificationDestination(GetNotificationDestinationArgs.builder()
     *             .id("1e543419-0c25-456a-9057-fb0eb310e60b")
     *             .build());
     * 
     *         // Resource
     *         var foo_channel = new NotificationChannel("foo-channel", NotificationChannelArgs.builder()
     *             .name("webhook-example")
     *             .type("WEBHOOK")
     *             .destinationId(foo.id())
     *             .product("IINT")
     *             .properties(NotificationChannelPropertyArgs.builder()
     *                 .key("payload")
     *                 .value("""
     * {
     * 	"name": "foo"
     * }                """)
     *                 .label("Payload Template")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * ## Name Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetNotificationDestinationArgs;
     * import com.pulumi.newrelic.NotificationChannel;
     * import com.pulumi.newrelic.NotificationChannelArgs;
     * import com.pulumi.newrelic.inputs.NotificationChannelPropertyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getNotificationDestination(GetNotificationDestinationArgs.builder()
     *             .name("webhook-destination")
     *             .build());
     * 
     *         // Resource
     *         var foo_channel = new NotificationChannel("foo-channel", NotificationChannelArgs.builder()
     *             .name("webhook-example")
     *             .type("WEBHOOK")
     *             .destinationId(foo.id())
     *             .product("IINT")
     *             .properties(NotificationChannelPropertyArgs.builder()
     *                 .key("payload")
     *                 .value("""
     * {
     * 	"name": "foo"
     * }                """)
     *                 .label("Payload Template")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetNotificationDestinationResult> getNotificationDestination(GetNotificationDestinationArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getNotificationDestination:getNotificationDestination", TypeShape.of(GetNotificationDestinationResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific notification destination in New Relic that already exists. More information on Terraform&#39;s data sources can be found here.
     * 
     * ## ID Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetNotificationDestinationArgs;
     * import com.pulumi.newrelic.NotificationChannel;
     * import com.pulumi.newrelic.NotificationChannelArgs;
     * import com.pulumi.newrelic.inputs.NotificationChannelPropertyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getNotificationDestination(GetNotificationDestinationArgs.builder()
     *             .id("1e543419-0c25-456a-9057-fb0eb310e60b")
     *             .build());
     * 
     *         // Resource
     *         var foo_channel = new NotificationChannel("foo-channel", NotificationChannelArgs.builder()
     *             .name("webhook-example")
     *             .type("WEBHOOK")
     *             .destinationId(foo.id())
     *             .product("IINT")
     *             .properties(NotificationChannelPropertyArgs.builder()
     *                 .key("payload")
     *                 .value("""
     * {
     * 	"name": "foo"
     * }                """)
     *                 .label("Payload Template")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * ## Name Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetNotificationDestinationArgs;
     * import com.pulumi.newrelic.NotificationChannel;
     * import com.pulumi.newrelic.NotificationChannelArgs;
     * import com.pulumi.newrelic.inputs.NotificationChannelPropertyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getNotificationDestination(GetNotificationDestinationArgs.builder()
     *             .name("webhook-destination")
     *             .build());
     * 
     *         // Resource
     *         var foo_channel = new NotificationChannel("foo-channel", NotificationChannelArgs.builder()
     *             .name("webhook-example")
     *             .type("WEBHOOK")
     *             .destinationId(foo.id())
     *             .product("IINT")
     *             .properties(NotificationChannelPropertyArgs.builder()
     *                 .key("payload")
     *                 .value("""
     * {
     * 	"name": "foo"
     * }                """)
     *                 .label("Payload Template")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetNotificationDestinationResult> getNotificationDestination(GetNotificationDestinationArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getNotificationDestination:getNotificationDestination", TypeShape.of(GetNotificationDestinationResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific notification destination in New Relic that already exists. More information on Terraform&#39;s data sources can be found here.
     * 
     * ## ID Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetNotificationDestinationArgs;
     * import com.pulumi.newrelic.NotificationChannel;
     * import com.pulumi.newrelic.NotificationChannelArgs;
     * import com.pulumi.newrelic.inputs.NotificationChannelPropertyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getNotificationDestination(GetNotificationDestinationArgs.builder()
     *             .id("1e543419-0c25-456a-9057-fb0eb310e60b")
     *             .build());
     * 
     *         // Resource
     *         var foo_channel = new NotificationChannel("foo-channel", NotificationChannelArgs.builder()
     *             .name("webhook-example")
     *             .type("WEBHOOK")
     *             .destinationId(foo.id())
     *             .product("IINT")
     *             .properties(NotificationChannelPropertyArgs.builder()
     *                 .key("payload")
     *                 .value("""
     * {
     * 	"name": "foo"
     * }                """)
     *                 .label("Payload Template")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * ## Name Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetNotificationDestinationArgs;
     * import com.pulumi.newrelic.NotificationChannel;
     * import com.pulumi.newrelic.NotificationChannelArgs;
     * import com.pulumi.newrelic.inputs.NotificationChannelPropertyArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getNotificationDestination(GetNotificationDestinationArgs.builder()
     *             .name("webhook-destination")
     *             .build());
     * 
     *         // Resource
     *         var foo_channel = new NotificationChannel("foo-channel", NotificationChannelArgs.builder()
     *             .name("webhook-example")
     *             .type("WEBHOOK")
     *             .destinationId(foo.id())
     *             .product("IINT")
     *             .properties(NotificationChannelPropertyArgs.builder()
     *                 .key("payload")
     *                 .value("""
     * {
     * 	"name": "foo"
     * }                """)
     *                 .label("Payload Template")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetNotificationDestinationResult> getNotificationDestinationPlain(GetNotificationDestinationPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getNotificationDestination:getNotificationDestination", TypeShape.of(GetNotificationDestinationResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific Obfuscation Expression in New Relic that already exists.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetObfuscationExpressionArgs;
     * import com.pulumi.newrelic.ObfuscationRule;
     * import com.pulumi.newrelic.ObfuscationRuleArgs;
     * import com.pulumi.newrelic.inputs.ObfuscationRuleActionArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var expression = NewrelicFunctions.getObfuscationExpression(GetObfuscationExpressionArgs.builder()
     *             .accountId("123456")
     *             .name("The expression")
     *             .build());
     * 
     *         var rule = new ObfuscationRule("rule", ObfuscationRuleArgs.builder()
     *             .name("ruleName")
     *             .description("description of the rule")
     *             .filter("hostStatus=running")
     *             .enabled(true)
     *             .actions(ObfuscationRuleActionArgs.builder()
     *                 .attributes("message")
     *                 .expressionId(expression.id())
     *                 .method("MASK")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetObfuscationExpressionResult> getObfuscationExpression(GetObfuscationExpressionArgs args) {
        return getObfuscationExpression(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific Obfuscation Expression in New Relic that already exists.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetObfuscationExpressionArgs;
     * import com.pulumi.newrelic.ObfuscationRule;
     * import com.pulumi.newrelic.ObfuscationRuleArgs;
     * import com.pulumi.newrelic.inputs.ObfuscationRuleActionArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var expression = NewrelicFunctions.getObfuscationExpression(GetObfuscationExpressionArgs.builder()
     *             .accountId("123456")
     *             .name("The expression")
     *             .build());
     * 
     *         var rule = new ObfuscationRule("rule", ObfuscationRuleArgs.builder()
     *             .name("ruleName")
     *             .description("description of the rule")
     *             .filter("hostStatus=running")
     *             .enabled(true)
     *             .actions(ObfuscationRuleActionArgs.builder()
     *                 .attributes("message")
     *                 .expressionId(expression.id())
     *                 .method("MASK")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetObfuscationExpressionResult> getObfuscationExpressionPlain(GetObfuscationExpressionPlainArgs args) {
        return getObfuscationExpressionPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific Obfuscation Expression in New Relic that already exists.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetObfuscationExpressionArgs;
     * import com.pulumi.newrelic.ObfuscationRule;
     * import com.pulumi.newrelic.ObfuscationRuleArgs;
     * import com.pulumi.newrelic.inputs.ObfuscationRuleActionArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var expression = NewrelicFunctions.getObfuscationExpression(GetObfuscationExpressionArgs.builder()
     *             .accountId("123456")
     *             .name("The expression")
     *             .build());
     * 
     *         var rule = new ObfuscationRule("rule", ObfuscationRuleArgs.builder()
     *             .name("ruleName")
     *             .description("description of the rule")
     *             .filter("hostStatus=running")
     *             .enabled(true)
     *             .actions(ObfuscationRuleActionArgs.builder()
     *                 .attributes("message")
     *                 .expressionId(expression.id())
     *                 .method("MASK")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetObfuscationExpressionResult> getObfuscationExpression(GetObfuscationExpressionArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getObfuscationExpression:getObfuscationExpression", TypeShape.of(GetObfuscationExpressionResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific Obfuscation Expression in New Relic that already exists.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetObfuscationExpressionArgs;
     * import com.pulumi.newrelic.ObfuscationRule;
     * import com.pulumi.newrelic.ObfuscationRuleArgs;
     * import com.pulumi.newrelic.inputs.ObfuscationRuleActionArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var expression = NewrelicFunctions.getObfuscationExpression(GetObfuscationExpressionArgs.builder()
     *             .accountId("123456")
     *             .name("The expression")
     *             .build());
     * 
     *         var rule = new ObfuscationRule("rule", ObfuscationRuleArgs.builder()
     *             .name("ruleName")
     *             .description("description of the rule")
     *             .filter("hostStatus=running")
     *             .enabled(true)
     *             .actions(ObfuscationRuleActionArgs.builder()
     *                 .attributes("message")
     *                 .expressionId(expression.id())
     *                 .method("MASK")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetObfuscationExpressionResult> getObfuscationExpression(GetObfuscationExpressionArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getObfuscationExpression:getObfuscationExpression", TypeShape.of(GetObfuscationExpressionResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific Obfuscation Expression in New Relic that already exists.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetObfuscationExpressionArgs;
     * import com.pulumi.newrelic.ObfuscationRule;
     * import com.pulumi.newrelic.ObfuscationRuleArgs;
     * import com.pulumi.newrelic.inputs.ObfuscationRuleActionArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var expression = NewrelicFunctions.getObfuscationExpression(GetObfuscationExpressionArgs.builder()
     *             .accountId("123456")
     *             .name("The expression")
     *             .build());
     * 
     *         var rule = new ObfuscationRule("rule", ObfuscationRuleArgs.builder()
     *             .name("ruleName")
     *             .description("description of the rule")
     *             .filter("hostStatus=running")
     *             .enabled(true)
     *             .actions(ObfuscationRuleActionArgs.builder()
     *                 .attributes("message")
     *                 .expressionId(expression.id())
     *                 .method("MASK")
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetObfuscationExpressionResult> getObfuscationExpressionPlain(GetObfuscationExpressionPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getObfuscationExpression:getObfuscationExpression", TypeShape.of(GetObfuscationExpressionResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to obtain the necessary fields to set up alerts on your service levels. It can be used for a `custom` alertType in order to set up an alert with custom tolerated budget consumption and custom evaluation period or for recommended ones like `fastBurn` or `slowBurn`. For more information check [the documentation](https://docs.newrelic.com/docs/service-level-management/alerts-slm/).
     * 
     * ## Example Usage
     * 
     * Firstly set up your service level objective, we recommend using local variables for the `target` and `time_window.rolling.count`, as they are also necessary for the helper.
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.ServiceLevel;
     * import com.pulumi.newrelic.ServiceLevelArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsValidEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsBadEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveTimeWindowArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveTimeWindowRollingArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooTarget = 99.9;
     * 
     *         final var fooPeriod = 28;
     * 
     *         var foo = new ServiceLevel("foo", ServiceLevelArgs.builder()
     *             .guid("MXxBUE18QVBQTElDQVRJT058MQ")
     *             .name("Latency")
     *             .description("Proportion of requests that are served faster than a threshold.")
     *             .events(ServiceLevelEventsArgs.builder()
     *                 .accountId("12345678")
     *                 .validEvents(ServiceLevelEventsValidEventsArgs.builder()
     *                     .from("Transaction")
     *                     .where("appName = 'Example application' AND (transactionType='Web')")
     *                     .build())
     *                 .badEvents(ServiceLevelEventsBadEventsArgs.builder()
     *                     .from("Transaction")
     *                     .where("appName = 'Example application' AND (transactionType= 'Web') AND duration > 0.1")
     *                     .build())
     *                 .build())
     *             .objective(ServiceLevelObjectiveArgs.builder()
     *                 .target(fooTarget)
     *                 .timeWindow(ServiceLevelObjectiveTimeWindowArgs.builder()
     *                     .rolling(ServiceLevelObjectiveTimeWindowRollingArgs.builder()
     *                         .count(fooPeriod)
     *                         .unit("DAY")
     *                         .build())
     *                     .build())
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * Then use the helper to obtain the necessary fields to set up an alert on that Service Level.
     * Note that the Service Level was set up using bad events, that&#39;s why `isBadEvents` is set to `true`.
     * If the Service Level was configured with good events that would be unnecessary as the field defaults to `false`.
     * 
     * Here is an example of a `slowBurn` alert.
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetServiceLevelAlertHelperArgs;
     * import com.pulumi.newrelic.NrqlAlertCondition;
     * import com.pulumi.newrelic.NrqlAlertConditionArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionNrqlArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionCriticalArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooSlowBurn = NewrelicFunctions.getServiceLevelAlertHelper(GetServiceLevelAlertHelperArgs.builder()
     *             .alertType("slow_burn")
     *             .sliGuid(foo.sliGuid())
     *             .sloTarget(fooTarget)
     *             .sloPeriod(fooPeriod)
     *             .isBadEvents(true)
     *             .build());
     * 
     *         var yourCondition = new NrqlAlertCondition("yourCondition", NrqlAlertConditionArgs.builder()
     *             .accountId("12345678")
     *             .policyId("67890")
     *             .type("static")
     *             .name("Slow burn alert")
     *             .enabled(true)
     *             .violationTimeLimitSeconds(259200)
     *             .nrql(NrqlAlertConditionNrqlArgs.builder()
     *                 .query(fooSlowBurn.nrql())
     *                 .build())
     *             .critical(NrqlAlertConditionCriticalArgs.builder()
     *                 .operator("above_or_equals")
     *                 .threshold(fooSlowBurn.threshold())
     *                 .thresholdDuration(900)
     *                 .thresholdOccurrences("at_least_once")
     *                 .build())
     *             .fillOption("none")
     *             .aggregationWindow(fooSlowBurn.evaluationPeriod())
     *             .aggregationMethod("event_flow")
     *             .aggregationDelay("120")
     *             .slideBy(900)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * Here is an example of a custom alert:
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetServiceLevelAlertHelperArgs;
     * import com.pulumi.newrelic.NrqlAlertCondition;
     * import com.pulumi.newrelic.NrqlAlertConditionArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionNrqlArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionCriticalArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooCustom = NewrelicFunctions.getServiceLevelAlertHelper(GetServiceLevelAlertHelperArgs.builder()
     *             .alertType("custom")
     *             .sliGuid(foo.sliGuid())
     *             .sloTarget(fooTarget)
     *             .sloPeriod(fooPeriod)
     *             .customToleratedBudgetConsumption(4)
     *             .customEvaluationPeriod(5400)
     *             .isBadEvents(true)
     *             .build());
     * 
     *         var yourCondition = new NrqlAlertCondition("yourCondition", NrqlAlertConditionArgs.builder()
     *             .accountId("12345678")
     *             .policyId("67890")
     *             .type("static")
     *             .name("Custom burn alert")
     *             .enabled(true)
     *             .violationTimeLimitSeconds(259200)
     *             .nrql(NrqlAlertConditionNrqlArgs.builder()
     *                 .query(fooCustom.nrql())
     *                 .build())
     *             .critical(NrqlAlertConditionCriticalArgs.builder()
     *                 .operator("above_or_equals")
     *                 .threshold(fooCustom.threshold())
     *                 .thresholdDuration(900)
     *                 .thresholdOccurrences("at_least_once")
     *                 .build())
     *             .fillOption("none")
     *             .aggregationWindow(fooCustom.evaluationPeriod())
     *             .aggregationMethod("event_flow")
     *             .aggregationDelay("120")
     *             .slideBy(60)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetServiceLevelAlertHelperResult> getServiceLevelAlertHelper(GetServiceLevelAlertHelperArgs args) {
        return getServiceLevelAlertHelper(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to obtain the necessary fields to set up alerts on your service levels. It can be used for a `custom` alertType in order to set up an alert with custom tolerated budget consumption and custom evaluation period or for recommended ones like `fastBurn` or `slowBurn`. For more information check [the documentation](https://docs.newrelic.com/docs/service-level-management/alerts-slm/).
     * 
     * ## Example Usage
     * 
     * Firstly set up your service level objective, we recommend using local variables for the `target` and `time_window.rolling.count`, as they are also necessary for the helper.
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.ServiceLevel;
     * import com.pulumi.newrelic.ServiceLevelArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsValidEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsBadEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveTimeWindowArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveTimeWindowRollingArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooTarget = 99.9;
     * 
     *         final var fooPeriod = 28;
     * 
     *         var foo = new ServiceLevel("foo", ServiceLevelArgs.builder()
     *             .guid("MXxBUE18QVBQTElDQVRJT058MQ")
     *             .name("Latency")
     *             .description("Proportion of requests that are served faster than a threshold.")
     *             .events(ServiceLevelEventsArgs.builder()
     *                 .accountId("12345678")
     *                 .validEvents(ServiceLevelEventsValidEventsArgs.builder()
     *                     .from("Transaction")
     *                     .where("appName = 'Example application' AND (transactionType='Web')")
     *                     .build())
     *                 .badEvents(ServiceLevelEventsBadEventsArgs.builder()
     *                     .from("Transaction")
     *                     .where("appName = 'Example application' AND (transactionType= 'Web') AND duration > 0.1")
     *                     .build())
     *                 .build())
     *             .objective(ServiceLevelObjectiveArgs.builder()
     *                 .target(fooTarget)
     *                 .timeWindow(ServiceLevelObjectiveTimeWindowArgs.builder()
     *                     .rolling(ServiceLevelObjectiveTimeWindowRollingArgs.builder()
     *                         .count(fooPeriod)
     *                         .unit("DAY")
     *                         .build())
     *                     .build())
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * Then use the helper to obtain the necessary fields to set up an alert on that Service Level.
     * Note that the Service Level was set up using bad events, that&#39;s why `isBadEvents` is set to `true`.
     * If the Service Level was configured with good events that would be unnecessary as the field defaults to `false`.
     * 
     * Here is an example of a `slowBurn` alert.
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetServiceLevelAlertHelperArgs;
     * import com.pulumi.newrelic.NrqlAlertCondition;
     * import com.pulumi.newrelic.NrqlAlertConditionArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionNrqlArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionCriticalArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooSlowBurn = NewrelicFunctions.getServiceLevelAlertHelper(GetServiceLevelAlertHelperArgs.builder()
     *             .alertType("slow_burn")
     *             .sliGuid(foo.sliGuid())
     *             .sloTarget(fooTarget)
     *             .sloPeriod(fooPeriod)
     *             .isBadEvents(true)
     *             .build());
     * 
     *         var yourCondition = new NrqlAlertCondition("yourCondition", NrqlAlertConditionArgs.builder()
     *             .accountId("12345678")
     *             .policyId("67890")
     *             .type("static")
     *             .name("Slow burn alert")
     *             .enabled(true)
     *             .violationTimeLimitSeconds(259200)
     *             .nrql(NrqlAlertConditionNrqlArgs.builder()
     *                 .query(fooSlowBurn.nrql())
     *                 .build())
     *             .critical(NrqlAlertConditionCriticalArgs.builder()
     *                 .operator("above_or_equals")
     *                 .threshold(fooSlowBurn.threshold())
     *                 .thresholdDuration(900)
     *                 .thresholdOccurrences("at_least_once")
     *                 .build())
     *             .fillOption("none")
     *             .aggregationWindow(fooSlowBurn.evaluationPeriod())
     *             .aggregationMethod("event_flow")
     *             .aggregationDelay("120")
     *             .slideBy(900)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * Here is an example of a custom alert:
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetServiceLevelAlertHelperArgs;
     * import com.pulumi.newrelic.NrqlAlertCondition;
     * import com.pulumi.newrelic.NrqlAlertConditionArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionNrqlArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionCriticalArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooCustom = NewrelicFunctions.getServiceLevelAlertHelper(GetServiceLevelAlertHelperArgs.builder()
     *             .alertType("custom")
     *             .sliGuid(foo.sliGuid())
     *             .sloTarget(fooTarget)
     *             .sloPeriod(fooPeriod)
     *             .customToleratedBudgetConsumption(4)
     *             .customEvaluationPeriod(5400)
     *             .isBadEvents(true)
     *             .build());
     * 
     *         var yourCondition = new NrqlAlertCondition("yourCondition", NrqlAlertConditionArgs.builder()
     *             .accountId("12345678")
     *             .policyId("67890")
     *             .type("static")
     *             .name("Custom burn alert")
     *             .enabled(true)
     *             .violationTimeLimitSeconds(259200)
     *             .nrql(NrqlAlertConditionNrqlArgs.builder()
     *                 .query(fooCustom.nrql())
     *                 .build())
     *             .critical(NrqlAlertConditionCriticalArgs.builder()
     *                 .operator("above_or_equals")
     *                 .threshold(fooCustom.threshold())
     *                 .thresholdDuration(900)
     *                 .thresholdOccurrences("at_least_once")
     *                 .build())
     *             .fillOption("none")
     *             .aggregationWindow(fooCustom.evaluationPeriod())
     *             .aggregationMethod("event_flow")
     *             .aggregationDelay("120")
     *             .slideBy(60)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetServiceLevelAlertHelperResult> getServiceLevelAlertHelperPlain(GetServiceLevelAlertHelperPlainArgs args) {
        return getServiceLevelAlertHelperPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to obtain the necessary fields to set up alerts on your service levels. It can be used for a `custom` alertType in order to set up an alert with custom tolerated budget consumption and custom evaluation period or for recommended ones like `fastBurn` or `slowBurn`. For more information check [the documentation](https://docs.newrelic.com/docs/service-level-management/alerts-slm/).
     * 
     * ## Example Usage
     * 
     * Firstly set up your service level objective, we recommend using local variables for the `target` and `time_window.rolling.count`, as they are also necessary for the helper.
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.ServiceLevel;
     * import com.pulumi.newrelic.ServiceLevelArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsValidEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsBadEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveTimeWindowArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveTimeWindowRollingArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooTarget = 99.9;
     * 
     *         final var fooPeriod = 28;
     * 
     *         var foo = new ServiceLevel("foo", ServiceLevelArgs.builder()
     *             .guid("MXxBUE18QVBQTElDQVRJT058MQ")
     *             .name("Latency")
     *             .description("Proportion of requests that are served faster than a threshold.")
     *             .events(ServiceLevelEventsArgs.builder()
     *                 .accountId("12345678")
     *                 .validEvents(ServiceLevelEventsValidEventsArgs.builder()
     *                     .from("Transaction")
     *                     .where("appName = 'Example application' AND (transactionType='Web')")
     *                     .build())
     *                 .badEvents(ServiceLevelEventsBadEventsArgs.builder()
     *                     .from("Transaction")
     *                     .where("appName = 'Example application' AND (transactionType= 'Web') AND duration > 0.1")
     *                     .build())
     *                 .build())
     *             .objective(ServiceLevelObjectiveArgs.builder()
     *                 .target(fooTarget)
     *                 .timeWindow(ServiceLevelObjectiveTimeWindowArgs.builder()
     *                     .rolling(ServiceLevelObjectiveTimeWindowRollingArgs.builder()
     *                         .count(fooPeriod)
     *                         .unit("DAY")
     *                         .build())
     *                     .build())
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * Then use the helper to obtain the necessary fields to set up an alert on that Service Level.
     * Note that the Service Level was set up using bad events, that&#39;s why `isBadEvents` is set to `true`.
     * If the Service Level was configured with good events that would be unnecessary as the field defaults to `false`.
     * 
     * Here is an example of a `slowBurn` alert.
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetServiceLevelAlertHelperArgs;
     * import com.pulumi.newrelic.NrqlAlertCondition;
     * import com.pulumi.newrelic.NrqlAlertConditionArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionNrqlArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionCriticalArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooSlowBurn = NewrelicFunctions.getServiceLevelAlertHelper(GetServiceLevelAlertHelperArgs.builder()
     *             .alertType("slow_burn")
     *             .sliGuid(foo.sliGuid())
     *             .sloTarget(fooTarget)
     *             .sloPeriod(fooPeriod)
     *             .isBadEvents(true)
     *             .build());
     * 
     *         var yourCondition = new NrqlAlertCondition("yourCondition", NrqlAlertConditionArgs.builder()
     *             .accountId("12345678")
     *             .policyId("67890")
     *             .type("static")
     *             .name("Slow burn alert")
     *             .enabled(true)
     *             .violationTimeLimitSeconds(259200)
     *             .nrql(NrqlAlertConditionNrqlArgs.builder()
     *                 .query(fooSlowBurn.nrql())
     *                 .build())
     *             .critical(NrqlAlertConditionCriticalArgs.builder()
     *                 .operator("above_or_equals")
     *                 .threshold(fooSlowBurn.threshold())
     *                 .thresholdDuration(900)
     *                 .thresholdOccurrences("at_least_once")
     *                 .build())
     *             .fillOption("none")
     *             .aggregationWindow(fooSlowBurn.evaluationPeriod())
     *             .aggregationMethod("event_flow")
     *             .aggregationDelay("120")
     *             .slideBy(900)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * Here is an example of a custom alert:
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetServiceLevelAlertHelperArgs;
     * import com.pulumi.newrelic.NrqlAlertCondition;
     * import com.pulumi.newrelic.NrqlAlertConditionArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionNrqlArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionCriticalArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooCustom = NewrelicFunctions.getServiceLevelAlertHelper(GetServiceLevelAlertHelperArgs.builder()
     *             .alertType("custom")
     *             .sliGuid(foo.sliGuid())
     *             .sloTarget(fooTarget)
     *             .sloPeriod(fooPeriod)
     *             .customToleratedBudgetConsumption(4)
     *             .customEvaluationPeriod(5400)
     *             .isBadEvents(true)
     *             .build());
     * 
     *         var yourCondition = new NrqlAlertCondition("yourCondition", NrqlAlertConditionArgs.builder()
     *             .accountId("12345678")
     *             .policyId("67890")
     *             .type("static")
     *             .name("Custom burn alert")
     *             .enabled(true)
     *             .violationTimeLimitSeconds(259200)
     *             .nrql(NrqlAlertConditionNrqlArgs.builder()
     *                 .query(fooCustom.nrql())
     *                 .build())
     *             .critical(NrqlAlertConditionCriticalArgs.builder()
     *                 .operator("above_or_equals")
     *                 .threshold(fooCustom.threshold())
     *                 .thresholdDuration(900)
     *                 .thresholdOccurrences("at_least_once")
     *                 .build())
     *             .fillOption("none")
     *             .aggregationWindow(fooCustom.evaluationPeriod())
     *             .aggregationMethod("event_flow")
     *             .aggregationDelay("120")
     *             .slideBy(60)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetServiceLevelAlertHelperResult> getServiceLevelAlertHelper(GetServiceLevelAlertHelperArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getServiceLevelAlertHelper:getServiceLevelAlertHelper", TypeShape.of(GetServiceLevelAlertHelperResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to obtain the necessary fields to set up alerts on your service levels. It can be used for a `custom` alertType in order to set up an alert with custom tolerated budget consumption and custom evaluation period or for recommended ones like `fastBurn` or `slowBurn`. For more information check [the documentation](https://docs.newrelic.com/docs/service-level-management/alerts-slm/).
     * 
     * ## Example Usage
     * 
     * Firstly set up your service level objective, we recommend using local variables for the `target` and `time_window.rolling.count`, as they are also necessary for the helper.
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.ServiceLevel;
     * import com.pulumi.newrelic.ServiceLevelArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsValidEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsBadEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveTimeWindowArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveTimeWindowRollingArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooTarget = 99.9;
     * 
     *         final var fooPeriod = 28;
     * 
     *         var foo = new ServiceLevel("foo", ServiceLevelArgs.builder()
     *             .guid("MXxBUE18QVBQTElDQVRJT058MQ")
     *             .name("Latency")
     *             .description("Proportion of requests that are served faster than a threshold.")
     *             .events(ServiceLevelEventsArgs.builder()
     *                 .accountId("12345678")
     *                 .validEvents(ServiceLevelEventsValidEventsArgs.builder()
     *                     .from("Transaction")
     *                     .where("appName = 'Example application' AND (transactionType='Web')")
     *                     .build())
     *                 .badEvents(ServiceLevelEventsBadEventsArgs.builder()
     *                     .from("Transaction")
     *                     .where("appName = 'Example application' AND (transactionType= 'Web') AND duration > 0.1")
     *                     .build())
     *                 .build())
     *             .objective(ServiceLevelObjectiveArgs.builder()
     *                 .target(fooTarget)
     *                 .timeWindow(ServiceLevelObjectiveTimeWindowArgs.builder()
     *                     .rolling(ServiceLevelObjectiveTimeWindowRollingArgs.builder()
     *                         .count(fooPeriod)
     *                         .unit("DAY")
     *                         .build())
     *                     .build())
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * Then use the helper to obtain the necessary fields to set up an alert on that Service Level.
     * Note that the Service Level was set up using bad events, that&#39;s why `isBadEvents` is set to `true`.
     * If the Service Level was configured with good events that would be unnecessary as the field defaults to `false`.
     * 
     * Here is an example of a `slowBurn` alert.
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetServiceLevelAlertHelperArgs;
     * import com.pulumi.newrelic.NrqlAlertCondition;
     * import com.pulumi.newrelic.NrqlAlertConditionArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionNrqlArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionCriticalArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooSlowBurn = NewrelicFunctions.getServiceLevelAlertHelper(GetServiceLevelAlertHelperArgs.builder()
     *             .alertType("slow_burn")
     *             .sliGuid(foo.sliGuid())
     *             .sloTarget(fooTarget)
     *             .sloPeriod(fooPeriod)
     *             .isBadEvents(true)
     *             .build());
     * 
     *         var yourCondition = new NrqlAlertCondition("yourCondition", NrqlAlertConditionArgs.builder()
     *             .accountId("12345678")
     *             .policyId("67890")
     *             .type("static")
     *             .name("Slow burn alert")
     *             .enabled(true)
     *             .violationTimeLimitSeconds(259200)
     *             .nrql(NrqlAlertConditionNrqlArgs.builder()
     *                 .query(fooSlowBurn.nrql())
     *                 .build())
     *             .critical(NrqlAlertConditionCriticalArgs.builder()
     *                 .operator("above_or_equals")
     *                 .threshold(fooSlowBurn.threshold())
     *                 .thresholdDuration(900)
     *                 .thresholdOccurrences("at_least_once")
     *                 .build())
     *             .fillOption("none")
     *             .aggregationWindow(fooSlowBurn.evaluationPeriod())
     *             .aggregationMethod("event_flow")
     *             .aggregationDelay("120")
     *             .slideBy(900)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * Here is an example of a custom alert:
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetServiceLevelAlertHelperArgs;
     * import com.pulumi.newrelic.NrqlAlertCondition;
     * import com.pulumi.newrelic.NrqlAlertConditionArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionNrqlArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionCriticalArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooCustom = NewrelicFunctions.getServiceLevelAlertHelper(GetServiceLevelAlertHelperArgs.builder()
     *             .alertType("custom")
     *             .sliGuid(foo.sliGuid())
     *             .sloTarget(fooTarget)
     *             .sloPeriod(fooPeriod)
     *             .customToleratedBudgetConsumption(4)
     *             .customEvaluationPeriod(5400)
     *             .isBadEvents(true)
     *             .build());
     * 
     *         var yourCondition = new NrqlAlertCondition("yourCondition", NrqlAlertConditionArgs.builder()
     *             .accountId("12345678")
     *             .policyId("67890")
     *             .type("static")
     *             .name("Custom burn alert")
     *             .enabled(true)
     *             .violationTimeLimitSeconds(259200)
     *             .nrql(NrqlAlertConditionNrqlArgs.builder()
     *                 .query(fooCustom.nrql())
     *                 .build())
     *             .critical(NrqlAlertConditionCriticalArgs.builder()
     *                 .operator("above_or_equals")
     *                 .threshold(fooCustom.threshold())
     *                 .thresholdDuration(900)
     *                 .thresholdOccurrences("at_least_once")
     *                 .build())
     *             .fillOption("none")
     *             .aggregationWindow(fooCustom.evaluationPeriod())
     *             .aggregationMethod("event_flow")
     *             .aggregationDelay("120")
     *             .slideBy(60)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetServiceLevelAlertHelperResult> getServiceLevelAlertHelper(GetServiceLevelAlertHelperArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getServiceLevelAlertHelper:getServiceLevelAlertHelper", TypeShape.of(GetServiceLevelAlertHelperResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to obtain the necessary fields to set up alerts on your service levels. It can be used for a `custom` alertType in order to set up an alert with custom tolerated budget consumption and custom evaluation period or for recommended ones like `fastBurn` or `slowBurn`. For more information check [the documentation](https://docs.newrelic.com/docs/service-level-management/alerts-slm/).
     * 
     * ## Example Usage
     * 
     * Firstly set up your service level objective, we recommend using local variables for the `target` and `time_window.rolling.count`, as they are also necessary for the helper.
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.ServiceLevel;
     * import com.pulumi.newrelic.ServiceLevelArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsValidEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsBadEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveTimeWindowArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveTimeWindowRollingArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooTarget = 99.9;
     * 
     *         final var fooPeriod = 28;
     * 
     *         var foo = new ServiceLevel("foo", ServiceLevelArgs.builder()
     *             .guid("MXxBUE18QVBQTElDQVRJT058MQ")
     *             .name("Latency")
     *             .description("Proportion of requests that are served faster than a threshold.")
     *             .events(ServiceLevelEventsArgs.builder()
     *                 .accountId("12345678")
     *                 .validEvents(ServiceLevelEventsValidEventsArgs.builder()
     *                     .from("Transaction")
     *                     .where("appName = 'Example application' AND (transactionType='Web')")
     *                     .build())
     *                 .badEvents(ServiceLevelEventsBadEventsArgs.builder()
     *                     .from("Transaction")
     *                     .where("appName = 'Example application' AND (transactionType= 'Web') AND duration > 0.1")
     *                     .build())
     *                 .build())
     *             .objective(ServiceLevelObjectiveArgs.builder()
     *                 .target(fooTarget)
     *                 .timeWindow(ServiceLevelObjectiveTimeWindowArgs.builder()
     *                     .rolling(ServiceLevelObjectiveTimeWindowRollingArgs.builder()
     *                         .count(fooPeriod)
     *                         .unit("DAY")
     *                         .build())
     *                     .build())
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * Then use the helper to obtain the necessary fields to set up an alert on that Service Level.
     * Note that the Service Level was set up using bad events, that&#39;s why `isBadEvents` is set to `true`.
     * If the Service Level was configured with good events that would be unnecessary as the field defaults to `false`.
     * 
     * Here is an example of a `slowBurn` alert.
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetServiceLevelAlertHelperArgs;
     * import com.pulumi.newrelic.NrqlAlertCondition;
     * import com.pulumi.newrelic.NrqlAlertConditionArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionNrqlArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionCriticalArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooSlowBurn = NewrelicFunctions.getServiceLevelAlertHelper(GetServiceLevelAlertHelperArgs.builder()
     *             .alertType("slow_burn")
     *             .sliGuid(foo.sliGuid())
     *             .sloTarget(fooTarget)
     *             .sloPeriod(fooPeriod)
     *             .isBadEvents(true)
     *             .build());
     * 
     *         var yourCondition = new NrqlAlertCondition("yourCondition", NrqlAlertConditionArgs.builder()
     *             .accountId("12345678")
     *             .policyId("67890")
     *             .type("static")
     *             .name("Slow burn alert")
     *             .enabled(true)
     *             .violationTimeLimitSeconds(259200)
     *             .nrql(NrqlAlertConditionNrqlArgs.builder()
     *                 .query(fooSlowBurn.nrql())
     *                 .build())
     *             .critical(NrqlAlertConditionCriticalArgs.builder()
     *                 .operator("above_or_equals")
     *                 .threshold(fooSlowBurn.threshold())
     *                 .thresholdDuration(900)
     *                 .thresholdOccurrences("at_least_once")
     *                 .build())
     *             .fillOption("none")
     *             .aggregationWindow(fooSlowBurn.evaluationPeriod())
     *             .aggregationMethod("event_flow")
     *             .aggregationDelay("120")
     *             .slideBy(900)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     * Here is an example of a custom alert:
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetServiceLevelAlertHelperArgs;
     * import com.pulumi.newrelic.NrqlAlertCondition;
     * import com.pulumi.newrelic.NrqlAlertConditionArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionNrqlArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionCriticalArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooCustom = NewrelicFunctions.getServiceLevelAlertHelper(GetServiceLevelAlertHelperArgs.builder()
     *             .alertType("custom")
     *             .sliGuid(foo.sliGuid())
     *             .sloTarget(fooTarget)
     *             .sloPeriod(fooPeriod)
     *             .customToleratedBudgetConsumption(4)
     *             .customEvaluationPeriod(5400)
     *             .isBadEvents(true)
     *             .build());
     * 
     *         var yourCondition = new NrqlAlertCondition("yourCondition", NrqlAlertConditionArgs.builder()
     *             .accountId("12345678")
     *             .policyId("67890")
     *             .type("static")
     *             .name("Custom burn alert")
     *             .enabled(true)
     *             .violationTimeLimitSeconds(259200)
     *             .nrql(NrqlAlertConditionNrqlArgs.builder()
     *                 .query(fooCustom.nrql())
     *                 .build())
     *             .critical(NrqlAlertConditionCriticalArgs.builder()
     *                 .operator("above_or_equals")
     *                 .threshold(fooCustom.threshold())
     *                 .thresholdDuration(900)
     *                 .thresholdOccurrences("at_least_once")
     *                 .build())
     *             .fillOption("none")
     *             .aggregationWindow(fooCustom.evaluationPeriod())
     *             .aggregationMethod("event_flow")
     *             .aggregationDelay("120")
     *             .slideBy(60)
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetServiceLevelAlertHelperResult> getServiceLevelAlertHelperPlain(GetServiceLevelAlertHelperPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getServiceLevelAlertHelper:getServiceLevelAlertHelper", TypeShape.of(GetServiceLevelAlertHelperResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to validate a grok pattern.  More information on Terraform&#39;s data sources can be found here.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetTestGrokPatternArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getTestGrokPattern(GetTestGrokPatternArgs.builder()
     *             .grok("%{IP:host_ip}")
     *             .logLines(            
     *                 "host_ip: 43.3.120.2",
     *                 "bytes_received: 2048")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetTestGrokPatternResult> getTestGrokPattern(GetTestGrokPatternArgs args) {
        return getTestGrokPattern(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to validate a grok pattern.  More information on Terraform&#39;s data sources can be found here.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetTestGrokPatternArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getTestGrokPattern(GetTestGrokPatternArgs.builder()
     *             .grok("%{IP:host_ip}")
     *             .logLines(            
     *                 "host_ip: 43.3.120.2",
     *                 "bytes_received: 2048")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetTestGrokPatternResult> getTestGrokPatternPlain(GetTestGrokPatternPlainArgs args) {
        return getTestGrokPatternPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to validate a grok pattern.  More information on Terraform&#39;s data sources can be found here.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetTestGrokPatternArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getTestGrokPattern(GetTestGrokPatternArgs.builder()
     *             .grok("%{IP:host_ip}")
     *             .logLines(            
     *                 "host_ip: 43.3.120.2",
     *                 "bytes_received: 2048")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetTestGrokPatternResult> getTestGrokPattern(GetTestGrokPatternArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getTestGrokPattern:getTestGrokPattern", TypeShape.of(GetTestGrokPatternResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to validate a grok pattern.  More information on Terraform&#39;s data sources can be found here.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetTestGrokPatternArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getTestGrokPattern(GetTestGrokPatternArgs.builder()
     *             .grok("%{IP:host_ip}")
     *             .logLines(            
     *                 "host_ip: 43.3.120.2",
     *                 "bytes_received: 2048")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static Output<GetTestGrokPatternResult> getTestGrokPattern(GetTestGrokPatternArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getTestGrokPattern:getTestGrokPattern", TypeShape.of(GetTestGrokPatternResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to validate a grok pattern.  More information on Terraform&#39;s data sources can be found here.
     * 
     * ## Example Usage
     * 
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetTestGrokPatternArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getTestGrokPattern(GetTestGrokPatternArgs.builder()
     *             .grok("%{IP:host_ip}")
     *             .logLines(            
     *                 "host_ip: 43.3.120.2",
     *                 "bytes_received: 2048")
     *             .build());
     * 
     *     }
     * }
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetTestGrokPatternResult> getTestGrokPatternPlain(GetTestGrokPatternPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getTestGrokPattern:getTestGrokPattern", TypeShape.of(GetTestGrokPatternResult.class), args, Utilities.withVersion(options));
    }
    /**
     * The `newrelic.User` data source helps search for a user by their name and/or email ID, and accordingly, fetch the ID of the matching user.
     * 
     * ## Example Usage
     * 
     * The below example illustrates fetching a the ID of a user (and other arguments) using the ID of the authentication domain the user belongs to, as well as a name and/or email ID, which can be used as criteria to search for a user who matches these specified parameters.
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import com.pulumi.newrelic.inputs.GetUserArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App }{{@code
     *     public static void main(String[] args) }{{@code
     *         Pulumi.run(App::stack);
     *     }}{@code
     * 
     *     public static void stack(Context ctx) }{{@code
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name("Test Authentication Domain")
     *             .build());
     * 
     *         final var userOne = NewrelicFunctions.getUser(GetUserArgs.builder()
     *             .authenticationDomainId(foo.id())
     *             .name("Test User")
     *             .build());
     * 
     *         final var userTwo = NewrelicFunctions.getUser(GetUserArgs.builder()
     *             .authenticationDomainId(foo.id())
     *             .emailId("test_user}{@literal @}{@code random.com")
     *             .build());
     * 
     *     }}{@code
     * }}{@code
     * }
     * </pre>
     * 
     */
    public static Output<GetUserResult> getUser(GetUserArgs args) {
        return getUser(args, InvokeOptions.Empty);
    }
    /**
     * The `newrelic.User` data source helps search for a user by their name and/or email ID, and accordingly, fetch the ID of the matching user.
     * 
     * ## Example Usage
     * 
     * The below example illustrates fetching a the ID of a user (and other arguments) using the ID of the authentication domain the user belongs to, as well as a name and/or email ID, which can be used as criteria to search for a user who matches these specified parameters.
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import com.pulumi.newrelic.inputs.GetUserArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App }{{@code
     *     public static void main(String[] args) }{{@code
     *         Pulumi.run(App::stack);
     *     }}{@code
     * 
     *     public static void stack(Context ctx) }{{@code
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name("Test Authentication Domain")
     *             .build());
     * 
     *         final var userOne = NewrelicFunctions.getUser(GetUserArgs.builder()
     *             .authenticationDomainId(foo.id())
     *             .name("Test User")
     *             .build());
     * 
     *         final var userTwo = NewrelicFunctions.getUser(GetUserArgs.builder()
     *             .authenticationDomainId(foo.id())
     *             .emailId("test_user}{@literal @}{@code random.com")
     *             .build());
     * 
     *     }}{@code
     * }}{@code
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetUserResult> getUserPlain(GetUserPlainArgs args) {
        return getUserPlain(args, InvokeOptions.Empty);
    }
    /**
     * The `newrelic.User` data source helps search for a user by their name and/or email ID, and accordingly, fetch the ID of the matching user.
     * 
     * ## Example Usage
     * 
     * The below example illustrates fetching a the ID of a user (and other arguments) using the ID of the authentication domain the user belongs to, as well as a name and/or email ID, which can be used as criteria to search for a user who matches these specified parameters.
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import com.pulumi.newrelic.inputs.GetUserArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App }{{@code
     *     public static void main(String[] args) }{{@code
     *         Pulumi.run(App::stack);
     *     }}{@code
     * 
     *     public static void stack(Context ctx) }{{@code
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name("Test Authentication Domain")
     *             .build());
     * 
     *         final var userOne = NewrelicFunctions.getUser(GetUserArgs.builder()
     *             .authenticationDomainId(foo.id())
     *             .name("Test User")
     *             .build());
     * 
     *         final var userTwo = NewrelicFunctions.getUser(GetUserArgs.builder()
     *             .authenticationDomainId(foo.id())
     *             .emailId("test_user}{@literal @}{@code random.com")
     *             .build());
     * 
     *     }}{@code
     * }}{@code
     * }
     * </pre>
     * 
     */
    public static Output<GetUserResult> getUser(GetUserArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getUser:getUser", TypeShape.of(GetUserResult.class), args, Utilities.withVersion(options));
    }
    /**
     * The `newrelic.User` data source helps search for a user by their name and/or email ID, and accordingly, fetch the ID of the matching user.
     * 
     * ## Example Usage
     * 
     * The below example illustrates fetching a the ID of a user (and other arguments) using the ID of the authentication domain the user belongs to, as well as a name and/or email ID, which can be used as criteria to search for a user who matches these specified parameters.
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import com.pulumi.newrelic.inputs.GetUserArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App }{{@code
     *     public static void main(String[] args) }{{@code
     *         Pulumi.run(App::stack);
     *     }}{@code
     * 
     *     public static void stack(Context ctx) }{{@code
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name("Test Authentication Domain")
     *             .build());
     * 
     *         final var userOne = NewrelicFunctions.getUser(GetUserArgs.builder()
     *             .authenticationDomainId(foo.id())
     *             .name("Test User")
     *             .build());
     * 
     *         final var userTwo = NewrelicFunctions.getUser(GetUserArgs.builder()
     *             .authenticationDomainId(foo.id())
     *             .emailId("test_user}{@literal @}{@code random.com")
     *             .build());
     * 
     *     }}{@code
     * }}{@code
     * }
     * </pre>
     * 
     */
    public static Output<GetUserResult> getUser(GetUserArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getUser:getUser", TypeShape.of(GetUserResult.class), args, Utilities.withVersion(options));
    }
    /**
     * The `newrelic.User` data source helps search for a user by their name and/or email ID, and accordingly, fetch the ID of the matching user.
     * 
     * ## Example Usage
     * 
     * The below example illustrates fetching a the ID of a user (and other arguments) using the ID of the authentication domain the user belongs to, as well as a name and/or email ID, which can be used as criteria to search for a user who matches these specified parameters.
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import com.pulumi.newrelic.inputs.GetUserArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App }{{@code
     *     public static void main(String[] args) }{{@code
     *         Pulumi.run(App::stack);
     *     }}{@code
     * 
     *     public static void stack(Context ctx) }{{@code
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name("Test Authentication Domain")
     *             .build());
     * 
     *         final var userOne = NewrelicFunctions.getUser(GetUserArgs.builder()
     *             .authenticationDomainId(foo.id())
     *             .name("Test User")
     *             .build());
     * 
     *         final var userTwo = NewrelicFunctions.getUser(GetUserArgs.builder()
     *             .authenticationDomainId(foo.id())
     *             .emailId("test_user}{@literal @}{@code random.com")
     *             .build());
     * 
     *     }}{@code
     * }}{@code
     * }
     * </pre>
     * 
     */
    public static CompletableFuture<GetUserResult> getUserPlain(GetUserPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getUser:getUser", TypeShape.of(GetUserResult.class), args, Utilities.withVersion(options));
    }
}
