// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.newrelic;

import com.pulumi.core.Output;
import com.pulumi.core.TypeShape;
import com.pulumi.deployment.Deployment;
import com.pulumi.deployment.InvokeOptions;
import com.pulumi.newrelic.Utilities;
import com.pulumi.newrelic.inputs.GetAccountArgs;
import com.pulumi.newrelic.inputs.GetAccountPlainArgs;
import com.pulumi.newrelic.inputs.GetAlertChannelArgs;
import com.pulumi.newrelic.inputs.GetAlertChannelPlainArgs;
import com.pulumi.newrelic.inputs.GetAlertPolicyArgs;
import com.pulumi.newrelic.inputs.GetAlertPolicyPlainArgs;
import com.pulumi.newrelic.inputs.GetApplicationArgs;
import com.pulumi.newrelic.inputs.GetApplicationPlainArgs;
import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
import com.pulumi.newrelic.inputs.GetAuthenticationDomainPlainArgs;
import com.pulumi.newrelic.inputs.GetCloudAccountArgs;
import com.pulumi.newrelic.inputs.GetCloudAccountPlainArgs;
import com.pulumi.newrelic.inputs.GetEntityArgs;
import com.pulumi.newrelic.inputs.GetEntityPlainArgs;
import com.pulumi.newrelic.inputs.GetGroupArgs;
import com.pulumi.newrelic.inputs.GetGroupPlainArgs;
import com.pulumi.newrelic.inputs.GetKeyTransactionArgs;
import com.pulumi.newrelic.inputs.GetKeyTransactionPlainArgs;
import com.pulumi.newrelic.inputs.GetNotificationDestinationArgs;
import com.pulumi.newrelic.inputs.GetNotificationDestinationPlainArgs;
import com.pulumi.newrelic.inputs.GetObfuscationExpressionArgs;
import com.pulumi.newrelic.inputs.GetObfuscationExpressionPlainArgs;
import com.pulumi.newrelic.inputs.GetServiceLevelAlertHelperArgs;
import com.pulumi.newrelic.inputs.GetServiceLevelAlertHelperPlainArgs;
import com.pulumi.newrelic.inputs.GetTestGrokPatternArgs;
import com.pulumi.newrelic.inputs.GetTestGrokPatternPlainArgs;
import com.pulumi.newrelic.inputs.GetUserArgs;
import com.pulumi.newrelic.inputs.GetUserPlainArgs;
import com.pulumi.newrelic.outputs.GetAccountResult;
import com.pulumi.newrelic.outputs.GetAlertChannelResult;
import com.pulumi.newrelic.outputs.GetAlertPolicyResult;
import com.pulumi.newrelic.outputs.GetApplicationResult;
import com.pulumi.newrelic.outputs.GetAuthenticationDomainResult;
import com.pulumi.newrelic.outputs.GetCloudAccountResult;
import com.pulumi.newrelic.outputs.GetEntityResult;
import com.pulumi.newrelic.outputs.GetGroupResult;
import com.pulumi.newrelic.outputs.GetKeyTransactionResult;
import com.pulumi.newrelic.outputs.GetNotificationDestinationResult;
import com.pulumi.newrelic.outputs.GetObfuscationExpressionResult;
import com.pulumi.newrelic.outputs.GetServiceLevelAlertHelperResult;
import com.pulumi.newrelic.outputs.GetTestGrokPatternResult;
import com.pulumi.newrelic.outputs.GetUserResult;
import java.util.concurrent.CompletableFuture;

public final class NewrelicFunctions {
    /**
     * Use this data source to get information about a specific account in New Relic.
     * Accounts can be located by ID or name.  At most one of the two attributes can
     * be provided. If neither are provided, the provider&#39;s `account_id` will be used.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var acc = NewrelicFunctions.getAccount(GetAccountArgs.builder()
     *             .scope(&#34;global&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetAccountResult> getAccount() {
        return getAccount(GetAccountArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific account in New Relic.
     * Accounts can be located by ID or name.  At most one of the two attributes can
     * be provided. If neither are provided, the provider&#39;s `account_id` will be used.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var acc = NewrelicFunctions.getAccount(GetAccountArgs.builder()
     *             .scope(&#34;global&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetAccountResult> getAccountPlain() {
        return getAccountPlain(GetAccountPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific account in New Relic.
     * Accounts can be located by ID or name.  At most one of the two attributes can
     * be provided. If neither are provided, the provider&#39;s `account_id` will be used.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var acc = NewrelicFunctions.getAccount(GetAccountArgs.builder()
     *             .scope(&#34;global&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetAccountResult> getAccount(GetAccountArgs args) {
        return getAccount(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific account in New Relic.
     * Accounts can be located by ID or name.  At most one of the two attributes can
     * be provided. If neither are provided, the provider&#39;s `account_id` will be used.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var acc = NewrelicFunctions.getAccount(GetAccountArgs.builder()
     *             .scope(&#34;global&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetAccountResult> getAccountPlain(GetAccountPlainArgs args) {
        return getAccountPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific account in New Relic.
     * Accounts can be located by ID or name.  At most one of the two attributes can
     * be provided. If neither are provided, the provider&#39;s `account_id` will be used.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var acc = NewrelicFunctions.getAccount(GetAccountArgs.builder()
     *             .scope(&#34;global&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetAccountResult> getAccount(GetAccountArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getAccount:getAccount", TypeShape.of(GetAccountResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific account in New Relic.
     * Accounts can be located by ID or name.  At most one of the two attributes can
     * be provided. If neither are provided, the provider&#39;s `account_id` will be used.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var acc = NewrelicFunctions.getAccount(GetAccountArgs.builder()
     *             .scope(&#34;global&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetAccountResult> getAccountPlain(GetAccountPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getAccount:getAccount", TypeShape.of(GetAccountResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific alert channel in New Relic that already exists.
     * 
     * &gt; **WARNING:** The `newrelic.AlertChannel` data source is deprecated and will be removed in the next major release.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAlertChannelArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertPolicyChannel;
     * import com.pulumi.newrelic.AlertPolicyChannelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getAlertChannel(GetAlertChannelArgs.builder()
     *             .name(&#34;foo@example.com&#34;)
     *             .build());
     * 
     *         // Resource
     *         var fooAlertPolicy = new AlertPolicy(&#34;fooAlertPolicy&#34;, AlertPolicyArgs.builder()        
     *             .name(&#34;foo&#34;)
     *             .build());
     * 
     *         // Using the data source and resource together
     *         var fooAlertPolicyChannel = new AlertPolicyChannel(&#34;fooAlertPolicyChannel&#34;, AlertPolicyChannelArgs.builder()        
     *             .policyId(fooAlertPolicy.id())
     *             .channelId(foo.applyValue(getAlertChannelResult -&gt; getAlertChannelResult.id()))
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetAlertChannelResult> getAlertChannel(GetAlertChannelArgs args) {
        return getAlertChannel(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific alert channel in New Relic that already exists.
     * 
     * &gt; **WARNING:** The `newrelic.AlertChannel` data source is deprecated and will be removed in the next major release.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAlertChannelArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertPolicyChannel;
     * import com.pulumi.newrelic.AlertPolicyChannelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getAlertChannel(GetAlertChannelArgs.builder()
     *             .name(&#34;foo@example.com&#34;)
     *             .build());
     * 
     *         // Resource
     *         var fooAlertPolicy = new AlertPolicy(&#34;fooAlertPolicy&#34;, AlertPolicyArgs.builder()        
     *             .name(&#34;foo&#34;)
     *             .build());
     * 
     *         // Using the data source and resource together
     *         var fooAlertPolicyChannel = new AlertPolicyChannel(&#34;fooAlertPolicyChannel&#34;, AlertPolicyChannelArgs.builder()        
     *             .policyId(fooAlertPolicy.id())
     *             .channelId(foo.applyValue(getAlertChannelResult -&gt; getAlertChannelResult.id()))
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetAlertChannelResult> getAlertChannelPlain(GetAlertChannelPlainArgs args) {
        return getAlertChannelPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific alert channel in New Relic that already exists.
     * 
     * &gt; **WARNING:** The `newrelic.AlertChannel` data source is deprecated and will be removed in the next major release.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAlertChannelArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertPolicyChannel;
     * import com.pulumi.newrelic.AlertPolicyChannelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getAlertChannel(GetAlertChannelArgs.builder()
     *             .name(&#34;foo@example.com&#34;)
     *             .build());
     * 
     *         // Resource
     *         var fooAlertPolicy = new AlertPolicy(&#34;fooAlertPolicy&#34;, AlertPolicyArgs.builder()        
     *             .name(&#34;foo&#34;)
     *             .build());
     * 
     *         // Using the data source and resource together
     *         var fooAlertPolicyChannel = new AlertPolicyChannel(&#34;fooAlertPolicyChannel&#34;, AlertPolicyChannelArgs.builder()        
     *             .policyId(fooAlertPolicy.id())
     *             .channelId(foo.applyValue(getAlertChannelResult -&gt; getAlertChannelResult.id()))
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetAlertChannelResult> getAlertChannel(GetAlertChannelArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getAlertChannel:getAlertChannel", TypeShape.of(GetAlertChannelResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific alert channel in New Relic that already exists.
     * 
     * &gt; **WARNING:** The `newrelic.AlertChannel` data source is deprecated and will be removed in the next major release.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAlertChannelArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertPolicyChannel;
     * import com.pulumi.newrelic.AlertPolicyChannelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getAlertChannel(GetAlertChannelArgs.builder()
     *             .name(&#34;foo@example.com&#34;)
     *             .build());
     * 
     *         // Resource
     *         var fooAlertPolicy = new AlertPolicy(&#34;fooAlertPolicy&#34;, AlertPolicyArgs.builder()        
     *             .name(&#34;foo&#34;)
     *             .build());
     * 
     *         // Using the data source and resource together
     *         var fooAlertPolicyChannel = new AlertPolicyChannel(&#34;fooAlertPolicyChannel&#34;, AlertPolicyChannelArgs.builder()        
     *             .policyId(fooAlertPolicy.id())
     *             .channelId(foo.applyValue(getAlertChannelResult -&gt; getAlertChannelResult.id()))
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetAlertChannelResult> getAlertChannelPlain(GetAlertChannelPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getAlertChannel:getAlertChannel", TypeShape.of(GetAlertChannelResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific alert policy in New Relic that already exists.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAlertChannelArgs;
     * import com.pulumi.newrelic.inputs.GetAlertPolicyArgs;
     * import com.pulumi.newrelic.AlertPolicyChannel;
     * import com.pulumi.newrelic.AlertPolicyChannelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAlertChannel(GetAlertChannelArgs.builder()
     *             .name(&#34;foo@example.com&#34;)
     *             .build());
     * 
     *         final var fooGetAlertPolicy = NewrelicFunctions.getAlertPolicy(GetAlertPolicyArgs.builder()
     *             .name(&#34;foo policy&#34;)
     *             .build());
     * 
     *         var fooAlertPolicyChannel = new AlertPolicyChannel(&#34;fooAlertPolicyChannel&#34;, AlertPolicyChannelArgs.builder()        
     *             .policyId(fooGetAlertPolicy.applyValue(getAlertPolicyResult -&gt; getAlertPolicyResult.id()))
     *             .channelId(foo.applyValue(getAlertChannelResult -&gt; getAlertChannelResult.id()))
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetAlertPolicyResult> getAlertPolicy(GetAlertPolicyArgs args) {
        return getAlertPolicy(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific alert policy in New Relic that already exists.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAlertChannelArgs;
     * import com.pulumi.newrelic.inputs.GetAlertPolicyArgs;
     * import com.pulumi.newrelic.AlertPolicyChannel;
     * import com.pulumi.newrelic.AlertPolicyChannelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAlertChannel(GetAlertChannelArgs.builder()
     *             .name(&#34;foo@example.com&#34;)
     *             .build());
     * 
     *         final var fooGetAlertPolicy = NewrelicFunctions.getAlertPolicy(GetAlertPolicyArgs.builder()
     *             .name(&#34;foo policy&#34;)
     *             .build());
     * 
     *         var fooAlertPolicyChannel = new AlertPolicyChannel(&#34;fooAlertPolicyChannel&#34;, AlertPolicyChannelArgs.builder()        
     *             .policyId(fooGetAlertPolicy.applyValue(getAlertPolicyResult -&gt; getAlertPolicyResult.id()))
     *             .channelId(foo.applyValue(getAlertChannelResult -&gt; getAlertChannelResult.id()))
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetAlertPolicyResult> getAlertPolicyPlain(GetAlertPolicyPlainArgs args) {
        return getAlertPolicyPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific alert policy in New Relic that already exists.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAlertChannelArgs;
     * import com.pulumi.newrelic.inputs.GetAlertPolicyArgs;
     * import com.pulumi.newrelic.AlertPolicyChannel;
     * import com.pulumi.newrelic.AlertPolicyChannelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAlertChannel(GetAlertChannelArgs.builder()
     *             .name(&#34;foo@example.com&#34;)
     *             .build());
     * 
     *         final var fooGetAlertPolicy = NewrelicFunctions.getAlertPolicy(GetAlertPolicyArgs.builder()
     *             .name(&#34;foo policy&#34;)
     *             .build());
     * 
     *         var fooAlertPolicyChannel = new AlertPolicyChannel(&#34;fooAlertPolicyChannel&#34;, AlertPolicyChannelArgs.builder()        
     *             .policyId(fooGetAlertPolicy.applyValue(getAlertPolicyResult -&gt; getAlertPolicyResult.id()))
     *             .channelId(foo.applyValue(getAlertChannelResult -&gt; getAlertChannelResult.id()))
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetAlertPolicyResult> getAlertPolicy(GetAlertPolicyArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getAlertPolicy:getAlertPolicy", TypeShape.of(GetAlertPolicyResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific alert policy in New Relic that already exists.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAlertChannelArgs;
     * import com.pulumi.newrelic.inputs.GetAlertPolicyArgs;
     * import com.pulumi.newrelic.AlertPolicyChannel;
     * import com.pulumi.newrelic.AlertPolicyChannelArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAlertChannel(GetAlertChannelArgs.builder()
     *             .name(&#34;foo@example.com&#34;)
     *             .build());
     * 
     *         final var fooGetAlertPolicy = NewrelicFunctions.getAlertPolicy(GetAlertPolicyArgs.builder()
     *             .name(&#34;foo policy&#34;)
     *             .build());
     * 
     *         var fooAlertPolicyChannel = new AlertPolicyChannel(&#34;fooAlertPolicyChannel&#34;, AlertPolicyChannelArgs.builder()        
     *             .policyId(fooGetAlertPolicy.applyValue(getAlertPolicyResult -&gt; getAlertPolicyResult.id()))
     *             .channelId(foo.applyValue(getAlertChannelResult -&gt; getAlertChannelResult.id()))
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetAlertPolicyResult> getAlertPolicyPlain(GetAlertPolicyPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getAlertPolicy:getAlertPolicy", TypeShape.of(GetAlertPolicyResult.class), args, Utilities.withVersion(options));
    }
    /**
     * #### DEPRECATED! Use at your own risk. Use the `newrelic.getEntity` data source instead. This feature may be removed in the next major release
     * 
     * Use this data source to get information about a specific application in New Relic that already exists.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetApplicationArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertCondition;
     * import com.pulumi.newrelic.AlertConditionArgs;
     * import com.pulumi.newrelic.inputs.AlertConditionTermArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getApplication(GetApplicationArgs.builder()
     *             .name(&#34;my-app&#34;)
     *             .build());
     * 
     *         var foo = new AlertPolicy(&#34;foo&#34;, AlertPolicyArgs.builder()        
     *             .name(&#34;foo&#34;)
     *             .build());
     * 
     *         var fooAlertCondition = new AlertCondition(&#34;fooAlertCondition&#34;, AlertConditionArgs.builder()        
     *             .policyId(foo.id())
     *             .name(&#34;foo&#34;)
     *             .type(&#34;apm_app_metric&#34;)
     *             .entities(app.applyValue(getApplicationResult -&gt; getApplicationResult.id()))
     *             .metric(&#34;apdex&#34;)
     *             .runbookUrl(&#34;https://www.example.com&#34;)
     *             .terms(AlertConditionTermArgs.builder()
     *                 .duration(5)
     *                 .operator(&#34;below&#34;)
     *                 .priority(&#34;critical&#34;)
     *                 .threshold(&#34;0.75&#34;)
     *                 .timeFunction(&#34;all&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetApplicationResult> getApplication(GetApplicationArgs args) {
        return getApplication(args, InvokeOptions.Empty);
    }
    /**
     * #### DEPRECATED! Use at your own risk. Use the `newrelic.getEntity` data source instead. This feature may be removed in the next major release
     * 
     * Use this data source to get information about a specific application in New Relic that already exists.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetApplicationArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertCondition;
     * import com.pulumi.newrelic.AlertConditionArgs;
     * import com.pulumi.newrelic.inputs.AlertConditionTermArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getApplication(GetApplicationArgs.builder()
     *             .name(&#34;my-app&#34;)
     *             .build());
     * 
     *         var foo = new AlertPolicy(&#34;foo&#34;, AlertPolicyArgs.builder()        
     *             .name(&#34;foo&#34;)
     *             .build());
     * 
     *         var fooAlertCondition = new AlertCondition(&#34;fooAlertCondition&#34;, AlertConditionArgs.builder()        
     *             .policyId(foo.id())
     *             .name(&#34;foo&#34;)
     *             .type(&#34;apm_app_metric&#34;)
     *             .entities(app.applyValue(getApplicationResult -&gt; getApplicationResult.id()))
     *             .metric(&#34;apdex&#34;)
     *             .runbookUrl(&#34;https://www.example.com&#34;)
     *             .terms(AlertConditionTermArgs.builder()
     *                 .duration(5)
     *                 .operator(&#34;below&#34;)
     *                 .priority(&#34;critical&#34;)
     *                 .threshold(&#34;0.75&#34;)
     *                 .timeFunction(&#34;all&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetApplicationResult> getApplicationPlain(GetApplicationPlainArgs args) {
        return getApplicationPlain(args, InvokeOptions.Empty);
    }
    /**
     * #### DEPRECATED! Use at your own risk. Use the `newrelic.getEntity` data source instead. This feature may be removed in the next major release
     * 
     * Use this data source to get information about a specific application in New Relic that already exists.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetApplicationArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertCondition;
     * import com.pulumi.newrelic.AlertConditionArgs;
     * import com.pulumi.newrelic.inputs.AlertConditionTermArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getApplication(GetApplicationArgs.builder()
     *             .name(&#34;my-app&#34;)
     *             .build());
     * 
     *         var foo = new AlertPolicy(&#34;foo&#34;, AlertPolicyArgs.builder()        
     *             .name(&#34;foo&#34;)
     *             .build());
     * 
     *         var fooAlertCondition = new AlertCondition(&#34;fooAlertCondition&#34;, AlertConditionArgs.builder()        
     *             .policyId(foo.id())
     *             .name(&#34;foo&#34;)
     *             .type(&#34;apm_app_metric&#34;)
     *             .entities(app.applyValue(getApplicationResult -&gt; getApplicationResult.id()))
     *             .metric(&#34;apdex&#34;)
     *             .runbookUrl(&#34;https://www.example.com&#34;)
     *             .terms(AlertConditionTermArgs.builder()
     *                 .duration(5)
     *                 .operator(&#34;below&#34;)
     *                 .priority(&#34;critical&#34;)
     *                 .threshold(&#34;0.75&#34;)
     *                 .timeFunction(&#34;all&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetApplicationResult> getApplication(GetApplicationArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getApplication:getApplication", TypeShape.of(GetApplicationResult.class), args, Utilities.withVersion(options));
    }
    /**
     * #### DEPRECATED! Use at your own risk. Use the `newrelic.getEntity` data source instead. This feature may be removed in the next major release
     * 
     * Use this data source to get information about a specific application in New Relic that already exists.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetApplicationArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertCondition;
     * import com.pulumi.newrelic.AlertConditionArgs;
     * import com.pulumi.newrelic.inputs.AlertConditionTermArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getApplication(GetApplicationArgs.builder()
     *             .name(&#34;my-app&#34;)
     *             .build());
     * 
     *         var foo = new AlertPolicy(&#34;foo&#34;, AlertPolicyArgs.builder()        
     *             .name(&#34;foo&#34;)
     *             .build());
     * 
     *         var fooAlertCondition = new AlertCondition(&#34;fooAlertCondition&#34;, AlertConditionArgs.builder()        
     *             .policyId(foo.id())
     *             .name(&#34;foo&#34;)
     *             .type(&#34;apm_app_metric&#34;)
     *             .entities(app.applyValue(getApplicationResult -&gt; getApplicationResult.id()))
     *             .metric(&#34;apdex&#34;)
     *             .runbookUrl(&#34;https://www.example.com&#34;)
     *             .terms(AlertConditionTermArgs.builder()
     *                 .duration(5)
     *                 .operator(&#34;below&#34;)
     *                 .priority(&#34;critical&#34;)
     *                 .threshold(&#34;0.75&#34;)
     *                 .timeFunction(&#34;all&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetApplicationResult> getApplicationPlain(GetApplicationPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getApplication:getApplication", TypeShape.of(GetApplicationResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to fetch the ID of an authentication domain belonging to your account, matching the specified name.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name(&#34;Test Authentication Domain&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;foo&#34;, foo.applyValue(getAuthenticationDomainResult -&gt; getAuthenticationDomainResult.id()));
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetAuthenticationDomainResult> getAuthenticationDomain(GetAuthenticationDomainArgs args) {
        return getAuthenticationDomain(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to fetch the ID of an authentication domain belonging to your account, matching the specified name.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name(&#34;Test Authentication Domain&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;foo&#34;, foo.applyValue(getAuthenticationDomainResult -&gt; getAuthenticationDomainResult.id()));
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetAuthenticationDomainResult> getAuthenticationDomainPlain(GetAuthenticationDomainPlainArgs args) {
        return getAuthenticationDomainPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to fetch the ID of an authentication domain belonging to your account, matching the specified name.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name(&#34;Test Authentication Domain&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;foo&#34;, foo.applyValue(getAuthenticationDomainResult -&gt; getAuthenticationDomainResult.id()));
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetAuthenticationDomainResult> getAuthenticationDomain(GetAuthenticationDomainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getAuthenticationDomain:getAuthenticationDomain", TypeShape.of(GetAuthenticationDomainResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to fetch the ID of an authentication domain belonging to your account, matching the specified name.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name(&#34;Test Authentication Domain&#34;)
     *             .build());
     * 
     *         ctx.export(&#34;foo&#34;, foo.applyValue(getAuthenticationDomainResult -&gt; getAuthenticationDomainResult.id()));
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetAuthenticationDomainResult> getAuthenticationDomainPlain(GetAuthenticationDomainPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getAuthenticationDomain:getAuthenticationDomain", TypeShape.of(GetAuthenticationDomainResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific cloud account linked to New Relic.
     * Accounts can be located by a combination of New Relic Account ID, name and cloud provider (aws, gcp, azure, etc). Name and cloud provider are required attributes. If no account_id is specified on the resource the provider level account_id will be used.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetCloudAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var account = NewrelicFunctions.getCloudAccount(GetCloudAccountArgs.builder()
     *             .accountId(12345)
     *             .cloudProvider(&#34;aws&#34;)
     *             .name(&#34;my aws account&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetCloudAccountResult> getCloudAccount(GetCloudAccountArgs args) {
        return getCloudAccount(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific cloud account linked to New Relic.
     * Accounts can be located by a combination of New Relic Account ID, name and cloud provider (aws, gcp, azure, etc). Name and cloud provider are required attributes. If no account_id is specified on the resource the provider level account_id will be used.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetCloudAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var account = NewrelicFunctions.getCloudAccount(GetCloudAccountArgs.builder()
     *             .accountId(12345)
     *             .cloudProvider(&#34;aws&#34;)
     *             .name(&#34;my aws account&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetCloudAccountResult> getCloudAccountPlain(GetCloudAccountPlainArgs args) {
        return getCloudAccountPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific cloud account linked to New Relic.
     * Accounts can be located by a combination of New Relic Account ID, name and cloud provider (aws, gcp, azure, etc). Name and cloud provider are required attributes. If no account_id is specified on the resource the provider level account_id will be used.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetCloudAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var account = NewrelicFunctions.getCloudAccount(GetCloudAccountArgs.builder()
     *             .accountId(12345)
     *             .cloudProvider(&#34;aws&#34;)
     *             .name(&#34;my aws account&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetCloudAccountResult> getCloudAccount(GetCloudAccountArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getCloudAccount:getCloudAccount", TypeShape.of(GetCloudAccountResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific cloud account linked to New Relic.
     * Accounts can be located by a combination of New Relic Account ID, name and cloud provider (aws, gcp, azure, etc). Name and cloud provider are required attributes. If no account_id is specified on the resource the provider level account_id will be used.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetCloudAccountArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var account = NewrelicFunctions.getCloudAccount(GetCloudAccountArgs.builder()
     *             .accountId(12345)
     *             .cloudProvider(&#34;aws&#34;)
     *             .name(&#34;my aws account&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetCloudAccountResult> getCloudAccountPlain(GetCloudAccountPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getCloudAccount:getCloudAccount", TypeShape.of(GetCloudAccountResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific entity in New Relic One that already exists.
     * 
     * ### Example: Filter By Account ID
     * 
     * The default behaviour of this data source is to retrieve entities matching the specified parameters (such as `name`, `domain`, `type`) from NerdGraph with the credentials specified in the configuration of the provider (account ID and API Key), filter them by the account ID specified in the configuration of the provider, and return the first match.
     * 
     * This would mean, if no entity with the specified search parameters is found associated with the account ID in the configuration of the provider, i.e. `NEW_RELIC_ACCOUNT_ID`, an error is thrown, stating that no matching entity has been found.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // The entity returned by this configuration would have to 
     *         // belong to the account_id specified in the provider 
     *         // configuration, i.e. NEW_RELIC_ACCOUNT_ID.
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name(&#34;my-app&#34;)
     *             .domain(&#34;APM&#34;)
     *             .type(&#34;APPLICATION&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * However, in order to cater to scenarios in which it could be necessary to retrieve an entity belonging to a subaccount using the account ID and API Key of the parent account (for instance, when entities with identical names are present in both the parent account and subaccounts, since matching entities from subaccounts too are returned by NerdGraph), the `account_id` attribute of this data source may be availed. This ensures that the account ID in the configuration of the provider, used to filter entities returned by the API is now overridden by the `account_id` specified in the configuration; i.e., in the below example, the data source would now return an entity matching the specified `name`, belonging to the account with the ID `account_id`.
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // The entity returned by this configuration, unlike in 
     *         // the above example, would have to belong to the account_id 
     *         // specified in the configuration below, i.e. 654321.
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name(&#34;my-app&#34;)
     *             .accountId(654321)
     *             .domain(&#34;APM&#34;)
     *             .type(&#34;APPLICATION&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * The following example explains a use case along the lines of the aforementioned; using the `account_id` argument in the data source to allow the filtering criteria to be the `account_id` specified (of the subaccount), and not the account ID in the provider configuration.
     * 
     * In simpler terms, when entities are queried from the parent account, entities with matching names are returned from subaccounts too, hence, specifying the `account_id` of the subaccount in the configuration allows the entity returned to belong to the subaccount with `account_id`.
     * ### Query for an OTEL entity
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name(&#34;my-otel-app&#34;)
     *             .domain(&#34;EXT&#34;)
     *             .type(&#34;SERVICE&#34;)
     *             .tags(GetEntityTagArgs.builder()
     *                 .key(&#34;accountID&#34;)
     *                 .value(&#34;12345&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ### Query for an entity by type (AWS Lambda entity in this example)
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name(&#34;my_lambda_trace&#34;)
     *             .type(&#34;AWSLAMBDAFUNCTION&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetEntityResult> getEntity(GetEntityArgs args) {
        return getEntity(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific entity in New Relic One that already exists.
     * 
     * ### Example: Filter By Account ID
     * 
     * The default behaviour of this data source is to retrieve entities matching the specified parameters (such as `name`, `domain`, `type`) from NerdGraph with the credentials specified in the configuration of the provider (account ID and API Key), filter them by the account ID specified in the configuration of the provider, and return the first match.
     * 
     * This would mean, if no entity with the specified search parameters is found associated with the account ID in the configuration of the provider, i.e. `NEW_RELIC_ACCOUNT_ID`, an error is thrown, stating that no matching entity has been found.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // The entity returned by this configuration would have to 
     *         // belong to the account_id specified in the provider 
     *         // configuration, i.e. NEW_RELIC_ACCOUNT_ID.
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name(&#34;my-app&#34;)
     *             .domain(&#34;APM&#34;)
     *             .type(&#34;APPLICATION&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * However, in order to cater to scenarios in which it could be necessary to retrieve an entity belonging to a subaccount using the account ID and API Key of the parent account (for instance, when entities with identical names are present in both the parent account and subaccounts, since matching entities from subaccounts too are returned by NerdGraph), the `account_id` attribute of this data source may be availed. This ensures that the account ID in the configuration of the provider, used to filter entities returned by the API is now overridden by the `account_id` specified in the configuration; i.e., in the below example, the data source would now return an entity matching the specified `name`, belonging to the account with the ID `account_id`.
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // The entity returned by this configuration, unlike in 
     *         // the above example, would have to belong to the account_id 
     *         // specified in the configuration below, i.e. 654321.
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name(&#34;my-app&#34;)
     *             .accountId(654321)
     *             .domain(&#34;APM&#34;)
     *             .type(&#34;APPLICATION&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * The following example explains a use case along the lines of the aforementioned; using the `account_id` argument in the data source to allow the filtering criteria to be the `account_id` specified (of the subaccount), and not the account ID in the provider configuration.
     * 
     * In simpler terms, when entities are queried from the parent account, entities with matching names are returned from subaccounts too, hence, specifying the `account_id` of the subaccount in the configuration allows the entity returned to belong to the subaccount with `account_id`.
     * ### Query for an OTEL entity
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name(&#34;my-otel-app&#34;)
     *             .domain(&#34;EXT&#34;)
     *             .type(&#34;SERVICE&#34;)
     *             .tags(GetEntityTagArgs.builder()
     *                 .key(&#34;accountID&#34;)
     *                 .value(&#34;12345&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ### Query for an entity by type (AWS Lambda entity in this example)
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name(&#34;my_lambda_trace&#34;)
     *             .type(&#34;AWSLAMBDAFUNCTION&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetEntityResult> getEntityPlain(GetEntityPlainArgs args) {
        return getEntityPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific entity in New Relic One that already exists.
     * 
     * ### Example: Filter By Account ID
     * 
     * The default behaviour of this data source is to retrieve entities matching the specified parameters (such as `name`, `domain`, `type`) from NerdGraph with the credentials specified in the configuration of the provider (account ID and API Key), filter them by the account ID specified in the configuration of the provider, and return the first match.
     * 
     * This would mean, if no entity with the specified search parameters is found associated with the account ID in the configuration of the provider, i.e. `NEW_RELIC_ACCOUNT_ID`, an error is thrown, stating that no matching entity has been found.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // The entity returned by this configuration would have to 
     *         // belong to the account_id specified in the provider 
     *         // configuration, i.e. NEW_RELIC_ACCOUNT_ID.
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name(&#34;my-app&#34;)
     *             .domain(&#34;APM&#34;)
     *             .type(&#34;APPLICATION&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * However, in order to cater to scenarios in which it could be necessary to retrieve an entity belonging to a subaccount using the account ID and API Key of the parent account (for instance, when entities with identical names are present in both the parent account and subaccounts, since matching entities from subaccounts too are returned by NerdGraph), the `account_id` attribute of this data source may be availed. This ensures that the account ID in the configuration of the provider, used to filter entities returned by the API is now overridden by the `account_id` specified in the configuration; i.e., in the below example, the data source would now return an entity matching the specified `name`, belonging to the account with the ID `account_id`.
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // The entity returned by this configuration, unlike in 
     *         // the above example, would have to belong to the account_id 
     *         // specified in the configuration below, i.e. 654321.
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name(&#34;my-app&#34;)
     *             .accountId(654321)
     *             .domain(&#34;APM&#34;)
     *             .type(&#34;APPLICATION&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * The following example explains a use case along the lines of the aforementioned; using the `account_id` argument in the data source to allow the filtering criteria to be the `account_id` specified (of the subaccount), and not the account ID in the provider configuration.
     * 
     * In simpler terms, when entities are queried from the parent account, entities with matching names are returned from subaccounts too, hence, specifying the `account_id` of the subaccount in the configuration allows the entity returned to belong to the subaccount with `account_id`.
     * ### Query for an OTEL entity
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name(&#34;my-otel-app&#34;)
     *             .domain(&#34;EXT&#34;)
     *             .type(&#34;SERVICE&#34;)
     *             .tags(GetEntityTagArgs.builder()
     *                 .key(&#34;accountID&#34;)
     *                 .value(&#34;12345&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ### Query for an entity by type (AWS Lambda entity in this example)
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name(&#34;my_lambda_trace&#34;)
     *             .type(&#34;AWSLAMBDAFUNCTION&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetEntityResult> getEntity(GetEntityArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getEntity:getEntity", TypeShape.of(GetEntityResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific entity in New Relic One that already exists.
     * 
     * ### Example: Filter By Account ID
     * 
     * The default behaviour of this data source is to retrieve entities matching the specified parameters (such as `name`, `domain`, `type`) from NerdGraph with the credentials specified in the configuration of the provider (account ID and API Key), filter them by the account ID specified in the configuration of the provider, and return the first match.
     * 
     * This would mean, if no entity with the specified search parameters is found associated with the account ID in the configuration of the provider, i.e. `NEW_RELIC_ACCOUNT_ID`, an error is thrown, stating that no matching entity has been found.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // The entity returned by this configuration would have to 
     *         // belong to the account_id specified in the provider 
     *         // configuration, i.e. NEW_RELIC_ACCOUNT_ID.
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name(&#34;my-app&#34;)
     *             .domain(&#34;APM&#34;)
     *             .type(&#34;APPLICATION&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * However, in order to cater to scenarios in which it could be necessary to retrieve an entity belonging to a subaccount using the account ID and API Key of the parent account (for instance, when entities with identical names are present in both the parent account and subaccounts, since matching entities from subaccounts too are returned by NerdGraph), the `account_id` attribute of this data source may be availed. This ensures that the account ID in the configuration of the provider, used to filter entities returned by the API is now overridden by the `account_id` specified in the configuration; i.e., in the below example, the data source would now return an entity matching the specified `name`, belonging to the account with the ID `account_id`.
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // The entity returned by this configuration, unlike in 
     *         // the above example, would have to belong to the account_id 
     *         // specified in the configuration below, i.e. 654321.
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name(&#34;my-app&#34;)
     *             .accountId(654321)
     *             .domain(&#34;APM&#34;)
     *             .type(&#34;APPLICATION&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * The following example explains a use case along the lines of the aforementioned; using the `account_id` argument in the data source to allow the filtering criteria to be the `account_id` specified (of the subaccount), and not the account ID in the provider configuration.
     * 
     * In simpler terms, when entities are queried from the parent account, entities with matching names are returned from subaccounts too, hence, specifying the `account_id` of the subaccount in the configuration allows the entity returned to belong to the subaccount with `account_id`.
     * ### Query for an OTEL entity
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name(&#34;my-otel-app&#34;)
     *             .domain(&#34;EXT&#34;)
     *             .type(&#34;SERVICE&#34;)
     *             .tags(GetEntityTagArgs.builder()
     *                 .key(&#34;accountID&#34;)
     *                 .value(&#34;12345&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * ### Query for an entity by type (AWS Lambda entity in this example)
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetEntityArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var app = NewrelicFunctions.getEntity(GetEntityArgs.builder()
     *             .name(&#34;my_lambda_trace&#34;)
     *             .type(&#34;AWSLAMBDAFUNCTION&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetEntityResult> getEntityPlain(GetEntityPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getEntity:getEntity", TypeShape.of(GetEntityResult.class), args, Utilities.withVersion(options));
    }
    /**
     * The `newrelic.Group` data source helps search for a group by its name and retrieve the ID of the matching group and other associated attributes.
     * 
     * ## Example Usage
     * 
     * The below example illustrates fetching the ID of a group (and IDs of users who belong to the group, if any) using the required arguments.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import com.pulumi.newrelic.inputs.GetGroupArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name(&#34;Test Authentication Domain&#34;)
     *             .build());
     * 
     *         final var fooGetGroup = NewrelicFunctions.getGroup(GetGroupArgs.builder()
     *             .authenticationDomainId(foo.applyValue(getAuthenticationDomainResult -&gt; getAuthenticationDomainResult.id()))
     *             .name(&#34;Test Group&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetGroupResult> getGroup(GetGroupArgs args) {
        return getGroup(args, InvokeOptions.Empty);
    }
    /**
     * The `newrelic.Group` data source helps search for a group by its name and retrieve the ID of the matching group and other associated attributes.
     * 
     * ## Example Usage
     * 
     * The below example illustrates fetching the ID of a group (and IDs of users who belong to the group, if any) using the required arguments.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import com.pulumi.newrelic.inputs.GetGroupArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name(&#34;Test Authentication Domain&#34;)
     *             .build());
     * 
     *         final var fooGetGroup = NewrelicFunctions.getGroup(GetGroupArgs.builder()
     *             .authenticationDomainId(foo.applyValue(getAuthenticationDomainResult -&gt; getAuthenticationDomainResult.id()))
     *             .name(&#34;Test Group&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetGroupResult> getGroupPlain(GetGroupPlainArgs args) {
        return getGroupPlain(args, InvokeOptions.Empty);
    }
    /**
     * The `newrelic.Group` data source helps search for a group by its name and retrieve the ID of the matching group and other associated attributes.
     * 
     * ## Example Usage
     * 
     * The below example illustrates fetching the ID of a group (and IDs of users who belong to the group, if any) using the required arguments.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import com.pulumi.newrelic.inputs.GetGroupArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name(&#34;Test Authentication Domain&#34;)
     *             .build());
     * 
     *         final var fooGetGroup = NewrelicFunctions.getGroup(GetGroupArgs.builder()
     *             .authenticationDomainId(foo.applyValue(getAuthenticationDomainResult -&gt; getAuthenticationDomainResult.id()))
     *             .name(&#34;Test Group&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetGroupResult> getGroup(GetGroupArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getGroup:getGroup", TypeShape.of(GetGroupResult.class), args, Utilities.withVersion(options));
    }
    /**
     * The `newrelic.Group` data source helps search for a group by its name and retrieve the ID of the matching group and other associated attributes.
     * 
     * ## Example Usage
     * 
     * The below example illustrates fetching the ID of a group (and IDs of users who belong to the group, if any) using the required arguments.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import com.pulumi.newrelic.inputs.GetGroupArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name(&#34;Test Authentication Domain&#34;)
     *             .build());
     * 
     *         final var fooGetGroup = NewrelicFunctions.getGroup(GetGroupArgs.builder()
     *             .authenticationDomainId(foo.applyValue(getAuthenticationDomainResult -&gt; getAuthenticationDomainResult.id()))
     *             .name(&#34;Test Group&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetGroupResult> getGroupPlain(GetGroupPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getGroup:getGroup", TypeShape.of(GetGroupResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific key transaction in New Relic that already exists.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetKeyTransactionArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertCondition;
     * import com.pulumi.newrelic.AlertConditionArgs;
     * import com.pulumi.newrelic.inputs.AlertConditionTermArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var txn = NewrelicFunctions.getKeyTransaction(GetKeyTransactionArgs.builder()
     *             .name(&#34;txn&#34;)
     *             .build());
     * 
     *         var foo = new AlertPolicy(&#34;foo&#34;, AlertPolicyArgs.builder()        
     *             .name(&#34;foo&#34;)
     *             .build());
     * 
     *         var fooAlertCondition = new AlertCondition(&#34;fooAlertCondition&#34;, AlertConditionArgs.builder()        
     *             .policyId(foo.id())
     *             .name(&#34;foo&#34;)
     *             .type(&#34;apm_kt_metric&#34;)
     *             .entities(txn.applyValue(getKeyTransactionResult -&gt; getKeyTransactionResult.id()))
     *             .metric(&#34;error_percentage&#34;)
     *             .runbookUrl(&#34;https://www.example.com&#34;)
     *             .terms(AlertConditionTermArgs.builder()
     *                 .duration(5)
     *                 .operator(&#34;below&#34;)
     *                 .priority(&#34;critical&#34;)
     *                 .threshold(&#34;0.75&#34;)
     *                 .timeFunction(&#34;all&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetKeyTransactionResult> getKeyTransaction(GetKeyTransactionArgs args) {
        return getKeyTransaction(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific key transaction in New Relic that already exists.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetKeyTransactionArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertCondition;
     * import com.pulumi.newrelic.AlertConditionArgs;
     * import com.pulumi.newrelic.inputs.AlertConditionTermArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var txn = NewrelicFunctions.getKeyTransaction(GetKeyTransactionArgs.builder()
     *             .name(&#34;txn&#34;)
     *             .build());
     * 
     *         var foo = new AlertPolicy(&#34;foo&#34;, AlertPolicyArgs.builder()        
     *             .name(&#34;foo&#34;)
     *             .build());
     * 
     *         var fooAlertCondition = new AlertCondition(&#34;fooAlertCondition&#34;, AlertConditionArgs.builder()        
     *             .policyId(foo.id())
     *             .name(&#34;foo&#34;)
     *             .type(&#34;apm_kt_metric&#34;)
     *             .entities(txn.applyValue(getKeyTransactionResult -&gt; getKeyTransactionResult.id()))
     *             .metric(&#34;error_percentage&#34;)
     *             .runbookUrl(&#34;https://www.example.com&#34;)
     *             .terms(AlertConditionTermArgs.builder()
     *                 .duration(5)
     *                 .operator(&#34;below&#34;)
     *                 .priority(&#34;critical&#34;)
     *                 .threshold(&#34;0.75&#34;)
     *                 .timeFunction(&#34;all&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetKeyTransactionResult> getKeyTransactionPlain(GetKeyTransactionPlainArgs args) {
        return getKeyTransactionPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific key transaction in New Relic that already exists.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetKeyTransactionArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertCondition;
     * import com.pulumi.newrelic.AlertConditionArgs;
     * import com.pulumi.newrelic.inputs.AlertConditionTermArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var txn = NewrelicFunctions.getKeyTransaction(GetKeyTransactionArgs.builder()
     *             .name(&#34;txn&#34;)
     *             .build());
     * 
     *         var foo = new AlertPolicy(&#34;foo&#34;, AlertPolicyArgs.builder()        
     *             .name(&#34;foo&#34;)
     *             .build());
     * 
     *         var fooAlertCondition = new AlertCondition(&#34;fooAlertCondition&#34;, AlertConditionArgs.builder()        
     *             .policyId(foo.id())
     *             .name(&#34;foo&#34;)
     *             .type(&#34;apm_kt_metric&#34;)
     *             .entities(txn.applyValue(getKeyTransactionResult -&gt; getKeyTransactionResult.id()))
     *             .metric(&#34;error_percentage&#34;)
     *             .runbookUrl(&#34;https://www.example.com&#34;)
     *             .terms(AlertConditionTermArgs.builder()
     *                 .duration(5)
     *                 .operator(&#34;below&#34;)
     *                 .priority(&#34;critical&#34;)
     *                 .threshold(&#34;0.75&#34;)
     *                 .timeFunction(&#34;all&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetKeyTransactionResult> getKeyTransaction(GetKeyTransactionArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getKeyTransaction:getKeyTransaction", TypeShape.of(GetKeyTransactionResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific key transaction in New Relic that already exists.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetKeyTransactionArgs;
     * import com.pulumi.newrelic.AlertPolicy;
     * import com.pulumi.newrelic.AlertPolicyArgs;
     * import com.pulumi.newrelic.AlertCondition;
     * import com.pulumi.newrelic.AlertConditionArgs;
     * import com.pulumi.newrelic.inputs.AlertConditionTermArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var txn = NewrelicFunctions.getKeyTransaction(GetKeyTransactionArgs.builder()
     *             .name(&#34;txn&#34;)
     *             .build());
     * 
     *         var foo = new AlertPolicy(&#34;foo&#34;, AlertPolicyArgs.builder()        
     *             .name(&#34;foo&#34;)
     *             .build());
     * 
     *         var fooAlertCondition = new AlertCondition(&#34;fooAlertCondition&#34;, AlertConditionArgs.builder()        
     *             .policyId(foo.id())
     *             .name(&#34;foo&#34;)
     *             .type(&#34;apm_kt_metric&#34;)
     *             .entities(txn.applyValue(getKeyTransactionResult -&gt; getKeyTransactionResult.id()))
     *             .metric(&#34;error_percentage&#34;)
     *             .runbookUrl(&#34;https://www.example.com&#34;)
     *             .terms(AlertConditionTermArgs.builder()
     *                 .duration(5)
     *                 .operator(&#34;below&#34;)
     *                 .priority(&#34;critical&#34;)
     *                 .threshold(&#34;0.75&#34;)
     *                 .timeFunction(&#34;all&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetKeyTransactionResult> getKeyTransactionPlain(GetKeyTransactionPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getKeyTransaction:getKeyTransaction", TypeShape.of(GetKeyTransactionResult.class), args, Utilities.withVersion(options));
    }
    public static Output<GetNotificationDestinationResult> getNotificationDestination() {
        return getNotificationDestination(GetNotificationDestinationArgs.Empty, InvokeOptions.Empty);
    }
    public static CompletableFuture<GetNotificationDestinationResult> getNotificationDestinationPlain() {
        return getNotificationDestinationPlain(GetNotificationDestinationPlainArgs.Empty, InvokeOptions.Empty);
    }
    public static Output<GetNotificationDestinationResult> getNotificationDestination(GetNotificationDestinationArgs args) {
        return getNotificationDestination(args, InvokeOptions.Empty);
    }
    public static CompletableFuture<GetNotificationDestinationResult> getNotificationDestinationPlain(GetNotificationDestinationPlainArgs args) {
        return getNotificationDestinationPlain(args, InvokeOptions.Empty);
    }
    public static Output<GetNotificationDestinationResult> getNotificationDestination(GetNotificationDestinationArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getNotificationDestination:getNotificationDestination", TypeShape.of(GetNotificationDestinationResult.class), args, Utilities.withVersion(options));
    }
    public static CompletableFuture<GetNotificationDestinationResult> getNotificationDestinationPlain(GetNotificationDestinationPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getNotificationDestination:getNotificationDestination", TypeShape.of(GetNotificationDestinationResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific Obfuscation Expression in New Relic that already exists.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetObfuscationExpressionArgs;
     * import com.pulumi.newrelic.ObfuscationRule;
     * import com.pulumi.newrelic.ObfuscationRuleArgs;
     * import com.pulumi.newrelic.inputs.ObfuscationRuleActionArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var expression = NewrelicFunctions.getObfuscationExpression(GetObfuscationExpressionArgs.builder()
     *             .accountId(123456)
     *             .name(&#34;The expression&#34;)
     *             .build());
     * 
     *         var rule = new ObfuscationRule(&#34;rule&#34;, ObfuscationRuleArgs.builder()        
     *             .name(&#34;ruleName&#34;)
     *             .description(&#34;description of the rule&#34;)
     *             .filter(&#34;hostStatus=running&#34;)
     *             .enabled(true)
     *             .actions(ObfuscationRuleActionArgs.builder()
     *                 .attributes(&#34;message&#34;)
     *                 .expressionId(expression.applyValue(getObfuscationExpressionResult -&gt; getObfuscationExpressionResult.id()))
     *                 .method(&#34;MASK&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetObfuscationExpressionResult> getObfuscationExpression(GetObfuscationExpressionArgs args) {
        return getObfuscationExpression(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific Obfuscation Expression in New Relic that already exists.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetObfuscationExpressionArgs;
     * import com.pulumi.newrelic.ObfuscationRule;
     * import com.pulumi.newrelic.ObfuscationRuleArgs;
     * import com.pulumi.newrelic.inputs.ObfuscationRuleActionArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var expression = NewrelicFunctions.getObfuscationExpression(GetObfuscationExpressionArgs.builder()
     *             .accountId(123456)
     *             .name(&#34;The expression&#34;)
     *             .build());
     * 
     *         var rule = new ObfuscationRule(&#34;rule&#34;, ObfuscationRuleArgs.builder()        
     *             .name(&#34;ruleName&#34;)
     *             .description(&#34;description of the rule&#34;)
     *             .filter(&#34;hostStatus=running&#34;)
     *             .enabled(true)
     *             .actions(ObfuscationRuleActionArgs.builder()
     *                 .attributes(&#34;message&#34;)
     *                 .expressionId(expression.applyValue(getObfuscationExpressionResult -&gt; getObfuscationExpressionResult.id()))
     *                 .method(&#34;MASK&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetObfuscationExpressionResult> getObfuscationExpressionPlain(GetObfuscationExpressionPlainArgs args) {
        return getObfuscationExpressionPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to get information about a specific Obfuscation Expression in New Relic that already exists.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetObfuscationExpressionArgs;
     * import com.pulumi.newrelic.ObfuscationRule;
     * import com.pulumi.newrelic.ObfuscationRuleArgs;
     * import com.pulumi.newrelic.inputs.ObfuscationRuleActionArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var expression = NewrelicFunctions.getObfuscationExpression(GetObfuscationExpressionArgs.builder()
     *             .accountId(123456)
     *             .name(&#34;The expression&#34;)
     *             .build());
     * 
     *         var rule = new ObfuscationRule(&#34;rule&#34;, ObfuscationRuleArgs.builder()        
     *             .name(&#34;ruleName&#34;)
     *             .description(&#34;description of the rule&#34;)
     *             .filter(&#34;hostStatus=running&#34;)
     *             .enabled(true)
     *             .actions(ObfuscationRuleActionArgs.builder()
     *                 .attributes(&#34;message&#34;)
     *                 .expressionId(expression.applyValue(getObfuscationExpressionResult -&gt; getObfuscationExpressionResult.id()))
     *                 .method(&#34;MASK&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetObfuscationExpressionResult> getObfuscationExpression(GetObfuscationExpressionArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getObfuscationExpression:getObfuscationExpression", TypeShape.of(GetObfuscationExpressionResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to get information about a specific Obfuscation Expression in New Relic that already exists.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetObfuscationExpressionArgs;
     * import com.pulumi.newrelic.ObfuscationRule;
     * import com.pulumi.newrelic.ObfuscationRuleArgs;
     * import com.pulumi.newrelic.inputs.ObfuscationRuleActionArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var expression = NewrelicFunctions.getObfuscationExpression(GetObfuscationExpressionArgs.builder()
     *             .accountId(123456)
     *             .name(&#34;The expression&#34;)
     *             .build());
     * 
     *         var rule = new ObfuscationRule(&#34;rule&#34;, ObfuscationRuleArgs.builder()        
     *             .name(&#34;ruleName&#34;)
     *             .description(&#34;description of the rule&#34;)
     *             .filter(&#34;hostStatus=running&#34;)
     *             .enabled(true)
     *             .actions(ObfuscationRuleActionArgs.builder()
     *                 .attributes(&#34;message&#34;)
     *                 .expressionId(expression.applyValue(getObfuscationExpressionResult -&gt; getObfuscationExpressionResult.id()))
     *                 .method(&#34;MASK&#34;)
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetObfuscationExpressionResult> getObfuscationExpressionPlain(GetObfuscationExpressionPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getObfuscationExpression:getObfuscationExpression", TypeShape.of(GetObfuscationExpressionResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to obtain the necessary fields to set up alerts on your service levels. It can be used for a `custom` alert_type in order to set up an alert with custom tolerated budget consumption and custom evaluation period or for recommended ones like `fast_burn` or `slow_burn`. For more information check [the documentation](https://docs.newrelic.com/docs/service-level-management/alerts-slm/).
     * 
     * ## Example Usage
     * 
     * Firstly set up your service level objective, we recommend using local variables for the `target` and `time_window.rolling.count`, as they are also necessary for the helper.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.ServiceLevel;
     * import com.pulumi.newrelic.ServiceLevelArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsValidEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsBadEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveTimeWindowArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveTimeWindowRollingArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooTarget = 99.9;
     * 
     *         final var fooPeriod = 28;
     * 
     *         var foo = new ServiceLevel(&#34;foo&#34;, ServiceLevelArgs.builder()        
     *             .guid(&#34;MXxBUE18QVBQTElDQVRJT058MQ&#34;)
     *             .name(&#34;Latency&#34;)
     *             .description(&#34;Proportion of requests that are served faster than a threshold.&#34;)
     *             .events(ServiceLevelEventsArgs.builder()
     *                 .accountId(12345678)
     *                 .validEvents(ServiceLevelEventsValidEventsArgs.builder()
     *                     .from(&#34;Transaction&#34;)
     *                     .where(&#34;appName = &#39;Example application&#39; AND (transactionType=&#39;Web&#39;)&#34;)
     *                     .build())
     *                 .badEvents(ServiceLevelEventsBadEventsArgs.builder()
     *                     .from(&#34;Transaction&#34;)
     *                     .where(&#34;appName = &#39;Example application&#39; AND (transactionType= &#39;Web&#39;) AND duration &gt; 0.1&#34;)
     *                     .build())
     *                 .build())
     *             .objective(ServiceLevelObjectiveArgs.builder()
     *                 .target(fooTarget)
     *                 .timeWindow(ServiceLevelObjectiveTimeWindowArgs.builder()
     *                     .rolling(ServiceLevelObjectiveTimeWindowRollingArgs.builder()
     *                         .count(fooPeriod)
     *                         .unit(&#34;DAY&#34;)
     *                         .build())
     *                     .build())
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * Then use the helper to obtain the necessary fields to set up an alert on that Service Level.
     * Note that the Service Level was set up using bad events, that&#39;s why `is_bad_events` is set to `true`.
     * If the Service Level was configured with good events that would be unnecessary as the field defaults to `false`.
     * 
     * Here is an example of a `slow_burn` alert.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetServiceLevelAlertHelperArgs;
     * import com.pulumi.newrelic.NrqlAlertCondition;
     * import com.pulumi.newrelic.NrqlAlertConditionArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionNrqlArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionCriticalArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooSlowBurn = NewrelicFunctions.getServiceLevelAlertHelper(GetServiceLevelAlertHelperArgs.builder()
     *             .alertType(&#34;slow_burn&#34;)
     *             .sliGuid(foo.sliGuid())
     *             .sloTarget(fooTarget)
     *             .sloPeriod(fooPeriod)
     *             .isBadEvents(true)
     *             .build());
     * 
     *         var yourCondition = new NrqlAlertCondition(&#34;yourCondition&#34;, NrqlAlertConditionArgs.builder()        
     *             .accountId(12345678)
     *             .policyId(67890)
     *             .type(&#34;static&#34;)
     *             .name(&#34;Slow burn alert&#34;)
     *             .enabled(true)
     *             .violationTimeLimitSeconds(259200)
     *             .nrql(NrqlAlertConditionNrqlArgs.builder()
     *                 .query(fooSlowBurn.applyValue(getServiceLevelAlertHelperResult -&gt; getServiceLevelAlertHelperResult.nrql()))
     *                 .build())
     *             .critical(NrqlAlertConditionCriticalArgs.builder()
     *                 .operator(&#34;above_or_equals&#34;)
     *                 .threshold(fooSlowBurn.applyValue(getServiceLevelAlertHelperResult -&gt; getServiceLevelAlertHelperResult.threshold()))
     *                 .thresholdDuration(900)
     *                 .thresholdOccurrences(&#34;at_least_once&#34;)
     *                 .build())
     *             .fillOption(&#34;none&#34;)
     *             .aggregationWindow(fooSlowBurn.applyValue(getServiceLevelAlertHelperResult -&gt; getServiceLevelAlertHelperResult.evaluationPeriod()))
     *             .aggregationMethod(&#34;event_flow&#34;)
     *             .aggregationDelay(120)
     *             .slideBy(900)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Here is an example of a custom alert:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetServiceLevelAlertHelperArgs;
     * import com.pulumi.newrelic.NrqlAlertCondition;
     * import com.pulumi.newrelic.NrqlAlertConditionArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionNrqlArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionCriticalArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooCustom = NewrelicFunctions.getServiceLevelAlertHelper(GetServiceLevelAlertHelperArgs.builder()
     *             .alertType(&#34;custom&#34;)
     *             .sliGuid(foo.sliGuid())
     *             .sloTarget(fooTarget)
     *             .sloPeriod(fooPeriod)
     *             .customToleratedBudgetConsumption(4)
     *             .customEvaluationPeriod(5400)
     *             .isBadEvents(true)
     *             .build());
     * 
     *         var yourCondition = new NrqlAlertCondition(&#34;yourCondition&#34;, NrqlAlertConditionArgs.builder()        
     *             .accountId(12345678)
     *             .policyId(67890)
     *             .type(&#34;static&#34;)
     *             .name(&#34;Custom burn alert&#34;)
     *             .enabled(true)
     *             .violationTimeLimitSeconds(259200)
     *             .nrql(NrqlAlertConditionNrqlArgs.builder()
     *                 .query(fooCustom.applyValue(getServiceLevelAlertHelperResult -&gt; getServiceLevelAlertHelperResult.nrql()))
     *                 .build())
     *             .critical(NrqlAlertConditionCriticalArgs.builder()
     *                 .operator(&#34;above_or_equals&#34;)
     *                 .threshold(fooCustom.applyValue(getServiceLevelAlertHelperResult -&gt; getServiceLevelAlertHelperResult.threshold()))
     *                 .thresholdDuration(900)
     *                 .thresholdOccurrences(&#34;at_least_once&#34;)
     *                 .build())
     *             .fillOption(&#34;none&#34;)
     *             .aggregationWindow(fooCustom.applyValue(getServiceLevelAlertHelperResult -&gt; getServiceLevelAlertHelperResult.evaluationPeriod()))
     *             .aggregationMethod(&#34;event_flow&#34;)
     *             .aggregationDelay(120)
     *             .slideBy(60)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetServiceLevelAlertHelperResult> getServiceLevelAlertHelper(GetServiceLevelAlertHelperArgs args) {
        return getServiceLevelAlertHelper(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to obtain the necessary fields to set up alerts on your service levels. It can be used for a `custom` alert_type in order to set up an alert with custom tolerated budget consumption and custom evaluation period or for recommended ones like `fast_burn` or `slow_burn`. For more information check [the documentation](https://docs.newrelic.com/docs/service-level-management/alerts-slm/).
     * 
     * ## Example Usage
     * 
     * Firstly set up your service level objective, we recommend using local variables for the `target` and `time_window.rolling.count`, as they are also necessary for the helper.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.ServiceLevel;
     * import com.pulumi.newrelic.ServiceLevelArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsValidEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsBadEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveTimeWindowArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveTimeWindowRollingArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooTarget = 99.9;
     * 
     *         final var fooPeriod = 28;
     * 
     *         var foo = new ServiceLevel(&#34;foo&#34;, ServiceLevelArgs.builder()        
     *             .guid(&#34;MXxBUE18QVBQTElDQVRJT058MQ&#34;)
     *             .name(&#34;Latency&#34;)
     *             .description(&#34;Proportion of requests that are served faster than a threshold.&#34;)
     *             .events(ServiceLevelEventsArgs.builder()
     *                 .accountId(12345678)
     *                 .validEvents(ServiceLevelEventsValidEventsArgs.builder()
     *                     .from(&#34;Transaction&#34;)
     *                     .where(&#34;appName = &#39;Example application&#39; AND (transactionType=&#39;Web&#39;)&#34;)
     *                     .build())
     *                 .badEvents(ServiceLevelEventsBadEventsArgs.builder()
     *                     .from(&#34;Transaction&#34;)
     *                     .where(&#34;appName = &#39;Example application&#39; AND (transactionType= &#39;Web&#39;) AND duration &gt; 0.1&#34;)
     *                     .build())
     *                 .build())
     *             .objective(ServiceLevelObjectiveArgs.builder()
     *                 .target(fooTarget)
     *                 .timeWindow(ServiceLevelObjectiveTimeWindowArgs.builder()
     *                     .rolling(ServiceLevelObjectiveTimeWindowRollingArgs.builder()
     *                         .count(fooPeriod)
     *                         .unit(&#34;DAY&#34;)
     *                         .build())
     *                     .build())
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * Then use the helper to obtain the necessary fields to set up an alert on that Service Level.
     * Note that the Service Level was set up using bad events, that&#39;s why `is_bad_events` is set to `true`.
     * If the Service Level was configured with good events that would be unnecessary as the field defaults to `false`.
     * 
     * Here is an example of a `slow_burn` alert.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetServiceLevelAlertHelperArgs;
     * import com.pulumi.newrelic.NrqlAlertCondition;
     * import com.pulumi.newrelic.NrqlAlertConditionArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionNrqlArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionCriticalArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooSlowBurn = NewrelicFunctions.getServiceLevelAlertHelper(GetServiceLevelAlertHelperArgs.builder()
     *             .alertType(&#34;slow_burn&#34;)
     *             .sliGuid(foo.sliGuid())
     *             .sloTarget(fooTarget)
     *             .sloPeriod(fooPeriod)
     *             .isBadEvents(true)
     *             .build());
     * 
     *         var yourCondition = new NrqlAlertCondition(&#34;yourCondition&#34;, NrqlAlertConditionArgs.builder()        
     *             .accountId(12345678)
     *             .policyId(67890)
     *             .type(&#34;static&#34;)
     *             .name(&#34;Slow burn alert&#34;)
     *             .enabled(true)
     *             .violationTimeLimitSeconds(259200)
     *             .nrql(NrqlAlertConditionNrqlArgs.builder()
     *                 .query(fooSlowBurn.applyValue(getServiceLevelAlertHelperResult -&gt; getServiceLevelAlertHelperResult.nrql()))
     *                 .build())
     *             .critical(NrqlAlertConditionCriticalArgs.builder()
     *                 .operator(&#34;above_or_equals&#34;)
     *                 .threshold(fooSlowBurn.applyValue(getServiceLevelAlertHelperResult -&gt; getServiceLevelAlertHelperResult.threshold()))
     *                 .thresholdDuration(900)
     *                 .thresholdOccurrences(&#34;at_least_once&#34;)
     *                 .build())
     *             .fillOption(&#34;none&#34;)
     *             .aggregationWindow(fooSlowBurn.applyValue(getServiceLevelAlertHelperResult -&gt; getServiceLevelAlertHelperResult.evaluationPeriod()))
     *             .aggregationMethod(&#34;event_flow&#34;)
     *             .aggregationDelay(120)
     *             .slideBy(900)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Here is an example of a custom alert:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetServiceLevelAlertHelperArgs;
     * import com.pulumi.newrelic.NrqlAlertCondition;
     * import com.pulumi.newrelic.NrqlAlertConditionArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionNrqlArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionCriticalArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooCustom = NewrelicFunctions.getServiceLevelAlertHelper(GetServiceLevelAlertHelperArgs.builder()
     *             .alertType(&#34;custom&#34;)
     *             .sliGuid(foo.sliGuid())
     *             .sloTarget(fooTarget)
     *             .sloPeriod(fooPeriod)
     *             .customToleratedBudgetConsumption(4)
     *             .customEvaluationPeriod(5400)
     *             .isBadEvents(true)
     *             .build());
     * 
     *         var yourCondition = new NrqlAlertCondition(&#34;yourCondition&#34;, NrqlAlertConditionArgs.builder()        
     *             .accountId(12345678)
     *             .policyId(67890)
     *             .type(&#34;static&#34;)
     *             .name(&#34;Custom burn alert&#34;)
     *             .enabled(true)
     *             .violationTimeLimitSeconds(259200)
     *             .nrql(NrqlAlertConditionNrqlArgs.builder()
     *                 .query(fooCustom.applyValue(getServiceLevelAlertHelperResult -&gt; getServiceLevelAlertHelperResult.nrql()))
     *                 .build())
     *             .critical(NrqlAlertConditionCriticalArgs.builder()
     *                 .operator(&#34;above_or_equals&#34;)
     *                 .threshold(fooCustom.applyValue(getServiceLevelAlertHelperResult -&gt; getServiceLevelAlertHelperResult.threshold()))
     *                 .thresholdDuration(900)
     *                 .thresholdOccurrences(&#34;at_least_once&#34;)
     *                 .build())
     *             .fillOption(&#34;none&#34;)
     *             .aggregationWindow(fooCustom.applyValue(getServiceLevelAlertHelperResult -&gt; getServiceLevelAlertHelperResult.evaluationPeriod()))
     *             .aggregationMethod(&#34;event_flow&#34;)
     *             .aggregationDelay(120)
     *             .slideBy(60)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetServiceLevelAlertHelperResult> getServiceLevelAlertHelperPlain(GetServiceLevelAlertHelperPlainArgs args) {
        return getServiceLevelAlertHelperPlain(args, InvokeOptions.Empty);
    }
    /**
     * Use this data source to obtain the necessary fields to set up alerts on your service levels. It can be used for a `custom` alert_type in order to set up an alert with custom tolerated budget consumption and custom evaluation period or for recommended ones like `fast_burn` or `slow_burn`. For more information check [the documentation](https://docs.newrelic.com/docs/service-level-management/alerts-slm/).
     * 
     * ## Example Usage
     * 
     * Firstly set up your service level objective, we recommend using local variables for the `target` and `time_window.rolling.count`, as they are also necessary for the helper.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.ServiceLevel;
     * import com.pulumi.newrelic.ServiceLevelArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsValidEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsBadEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveTimeWindowArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveTimeWindowRollingArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooTarget = 99.9;
     * 
     *         final var fooPeriod = 28;
     * 
     *         var foo = new ServiceLevel(&#34;foo&#34;, ServiceLevelArgs.builder()        
     *             .guid(&#34;MXxBUE18QVBQTElDQVRJT058MQ&#34;)
     *             .name(&#34;Latency&#34;)
     *             .description(&#34;Proportion of requests that are served faster than a threshold.&#34;)
     *             .events(ServiceLevelEventsArgs.builder()
     *                 .accountId(12345678)
     *                 .validEvents(ServiceLevelEventsValidEventsArgs.builder()
     *                     .from(&#34;Transaction&#34;)
     *                     .where(&#34;appName = &#39;Example application&#39; AND (transactionType=&#39;Web&#39;)&#34;)
     *                     .build())
     *                 .badEvents(ServiceLevelEventsBadEventsArgs.builder()
     *                     .from(&#34;Transaction&#34;)
     *                     .where(&#34;appName = &#39;Example application&#39; AND (transactionType= &#39;Web&#39;) AND duration &gt; 0.1&#34;)
     *                     .build())
     *                 .build())
     *             .objective(ServiceLevelObjectiveArgs.builder()
     *                 .target(fooTarget)
     *                 .timeWindow(ServiceLevelObjectiveTimeWindowArgs.builder()
     *                     .rolling(ServiceLevelObjectiveTimeWindowRollingArgs.builder()
     *                         .count(fooPeriod)
     *                         .unit(&#34;DAY&#34;)
     *                         .build())
     *                     .build())
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * Then use the helper to obtain the necessary fields to set up an alert on that Service Level.
     * Note that the Service Level was set up using bad events, that&#39;s why `is_bad_events` is set to `true`.
     * If the Service Level was configured with good events that would be unnecessary as the field defaults to `false`.
     * 
     * Here is an example of a `slow_burn` alert.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetServiceLevelAlertHelperArgs;
     * import com.pulumi.newrelic.NrqlAlertCondition;
     * import com.pulumi.newrelic.NrqlAlertConditionArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionNrqlArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionCriticalArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooSlowBurn = NewrelicFunctions.getServiceLevelAlertHelper(GetServiceLevelAlertHelperArgs.builder()
     *             .alertType(&#34;slow_burn&#34;)
     *             .sliGuid(foo.sliGuid())
     *             .sloTarget(fooTarget)
     *             .sloPeriod(fooPeriod)
     *             .isBadEvents(true)
     *             .build());
     * 
     *         var yourCondition = new NrqlAlertCondition(&#34;yourCondition&#34;, NrqlAlertConditionArgs.builder()        
     *             .accountId(12345678)
     *             .policyId(67890)
     *             .type(&#34;static&#34;)
     *             .name(&#34;Slow burn alert&#34;)
     *             .enabled(true)
     *             .violationTimeLimitSeconds(259200)
     *             .nrql(NrqlAlertConditionNrqlArgs.builder()
     *                 .query(fooSlowBurn.applyValue(getServiceLevelAlertHelperResult -&gt; getServiceLevelAlertHelperResult.nrql()))
     *                 .build())
     *             .critical(NrqlAlertConditionCriticalArgs.builder()
     *                 .operator(&#34;above_or_equals&#34;)
     *                 .threshold(fooSlowBurn.applyValue(getServiceLevelAlertHelperResult -&gt; getServiceLevelAlertHelperResult.threshold()))
     *                 .thresholdDuration(900)
     *                 .thresholdOccurrences(&#34;at_least_once&#34;)
     *                 .build())
     *             .fillOption(&#34;none&#34;)
     *             .aggregationWindow(fooSlowBurn.applyValue(getServiceLevelAlertHelperResult -&gt; getServiceLevelAlertHelperResult.evaluationPeriod()))
     *             .aggregationMethod(&#34;event_flow&#34;)
     *             .aggregationDelay(120)
     *             .slideBy(900)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Here is an example of a custom alert:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetServiceLevelAlertHelperArgs;
     * import com.pulumi.newrelic.NrqlAlertCondition;
     * import com.pulumi.newrelic.NrqlAlertConditionArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionNrqlArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionCriticalArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooCustom = NewrelicFunctions.getServiceLevelAlertHelper(GetServiceLevelAlertHelperArgs.builder()
     *             .alertType(&#34;custom&#34;)
     *             .sliGuid(foo.sliGuid())
     *             .sloTarget(fooTarget)
     *             .sloPeriod(fooPeriod)
     *             .customToleratedBudgetConsumption(4)
     *             .customEvaluationPeriod(5400)
     *             .isBadEvents(true)
     *             .build());
     * 
     *         var yourCondition = new NrqlAlertCondition(&#34;yourCondition&#34;, NrqlAlertConditionArgs.builder()        
     *             .accountId(12345678)
     *             .policyId(67890)
     *             .type(&#34;static&#34;)
     *             .name(&#34;Custom burn alert&#34;)
     *             .enabled(true)
     *             .violationTimeLimitSeconds(259200)
     *             .nrql(NrqlAlertConditionNrqlArgs.builder()
     *                 .query(fooCustom.applyValue(getServiceLevelAlertHelperResult -&gt; getServiceLevelAlertHelperResult.nrql()))
     *                 .build())
     *             .critical(NrqlAlertConditionCriticalArgs.builder()
     *                 .operator(&#34;above_or_equals&#34;)
     *                 .threshold(fooCustom.applyValue(getServiceLevelAlertHelperResult -&gt; getServiceLevelAlertHelperResult.threshold()))
     *                 .thresholdDuration(900)
     *                 .thresholdOccurrences(&#34;at_least_once&#34;)
     *                 .build())
     *             .fillOption(&#34;none&#34;)
     *             .aggregationWindow(fooCustom.applyValue(getServiceLevelAlertHelperResult -&gt; getServiceLevelAlertHelperResult.evaluationPeriod()))
     *             .aggregationMethod(&#34;event_flow&#34;)
     *             .aggregationDelay(120)
     *             .slideBy(60)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetServiceLevelAlertHelperResult> getServiceLevelAlertHelper(GetServiceLevelAlertHelperArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getServiceLevelAlertHelper:getServiceLevelAlertHelper", TypeShape.of(GetServiceLevelAlertHelperResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Use this data source to obtain the necessary fields to set up alerts on your service levels. It can be used for a `custom` alert_type in order to set up an alert with custom tolerated budget consumption and custom evaluation period or for recommended ones like `fast_burn` or `slow_burn`. For more information check [the documentation](https://docs.newrelic.com/docs/service-level-management/alerts-slm/).
     * 
     * ## Example Usage
     * 
     * Firstly set up your service level objective, we recommend using local variables for the `target` and `time_window.rolling.count`, as they are also necessary for the helper.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.ServiceLevel;
     * import com.pulumi.newrelic.ServiceLevelArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsValidEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelEventsBadEventsArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveTimeWindowArgs;
     * import com.pulumi.newrelic.inputs.ServiceLevelObjectiveTimeWindowRollingArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooTarget = 99.9;
     * 
     *         final var fooPeriod = 28;
     * 
     *         var foo = new ServiceLevel(&#34;foo&#34;, ServiceLevelArgs.builder()        
     *             .guid(&#34;MXxBUE18QVBQTElDQVRJT058MQ&#34;)
     *             .name(&#34;Latency&#34;)
     *             .description(&#34;Proportion of requests that are served faster than a threshold.&#34;)
     *             .events(ServiceLevelEventsArgs.builder()
     *                 .accountId(12345678)
     *                 .validEvents(ServiceLevelEventsValidEventsArgs.builder()
     *                     .from(&#34;Transaction&#34;)
     *                     .where(&#34;appName = &#39;Example application&#39; AND (transactionType=&#39;Web&#39;)&#34;)
     *                     .build())
     *                 .badEvents(ServiceLevelEventsBadEventsArgs.builder()
     *                     .from(&#34;Transaction&#34;)
     *                     .where(&#34;appName = &#39;Example application&#39; AND (transactionType= &#39;Web&#39;) AND duration &gt; 0.1&#34;)
     *                     .build())
     *                 .build())
     *             .objective(ServiceLevelObjectiveArgs.builder()
     *                 .target(fooTarget)
     *                 .timeWindow(ServiceLevelObjectiveTimeWindowArgs.builder()
     *                     .rolling(ServiceLevelObjectiveTimeWindowRollingArgs.builder()
     *                         .count(fooPeriod)
     *                         .unit(&#34;DAY&#34;)
     *                         .build())
     *                     .build())
     *                 .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * Then use the helper to obtain the necessary fields to set up an alert on that Service Level.
     * Note that the Service Level was set up using bad events, that&#39;s why `is_bad_events` is set to `true`.
     * If the Service Level was configured with good events that would be unnecessary as the field defaults to `false`.
     * 
     * Here is an example of a `slow_burn` alert.
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetServiceLevelAlertHelperArgs;
     * import com.pulumi.newrelic.NrqlAlertCondition;
     * import com.pulumi.newrelic.NrqlAlertConditionArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionNrqlArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionCriticalArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooSlowBurn = NewrelicFunctions.getServiceLevelAlertHelper(GetServiceLevelAlertHelperArgs.builder()
     *             .alertType(&#34;slow_burn&#34;)
     *             .sliGuid(foo.sliGuid())
     *             .sloTarget(fooTarget)
     *             .sloPeriod(fooPeriod)
     *             .isBadEvents(true)
     *             .build());
     * 
     *         var yourCondition = new NrqlAlertCondition(&#34;yourCondition&#34;, NrqlAlertConditionArgs.builder()        
     *             .accountId(12345678)
     *             .policyId(67890)
     *             .type(&#34;static&#34;)
     *             .name(&#34;Slow burn alert&#34;)
     *             .enabled(true)
     *             .violationTimeLimitSeconds(259200)
     *             .nrql(NrqlAlertConditionNrqlArgs.builder()
     *                 .query(fooSlowBurn.applyValue(getServiceLevelAlertHelperResult -&gt; getServiceLevelAlertHelperResult.nrql()))
     *                 .build())
     *             .critical(NrqlAlertConditionCriticalArgs.builder()
     *                 .operator(&#34;above_or_equals&#34;)
     *                 .threshold(fooSlowBurn.applyValue(getServiceLevelAlertHelperResult -&gt; getServiceLevelAlertHelperResult.threshold()))
     *                 .thresholdDuration(900)
     *                 .thresholdOccurrences(&#34;at_least_once&#34;)
     *                 .build())
     *             .fillOption(&#34;none&#34;)
     *             .aggregationWindow(fooSlowBurn.applyValue(getServiceLevelAlertHelperResult -&gt; getServiceLevelAlertHelperResult.evaluationPeriod()))
     *             .aggregationMethod(&#34;event_flow&#34;)
     *             .aggregationDelay(120)
     *             .slideBy(900)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     * Here is an example of a custom alert:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetServiceLevelAlertHelperArgs;
     * import com.pulumi.newrelic.NrqlAlertCondition;
     * import com.pulumi.newrelic.NrqlAlertConditionArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionNrqlArgs;
     * import com.pulumi.newrelic.inputs.NrqlAlertConditionCriticalArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var fooCustom = NewrelicFunctions.getServiceLevelAlertHelper(GetServiceLevelAlertHelperArgs.builder()
     *             .alertType(&#34;custom&#34;)
     *             .sliGuid(foo.sliGuid())
     *             .sloTarget(fooTarget)
     *             .sloPeriod(fooPeriod)
     *             .customToleratedBudgetConsumption(4)
     *             .customEvaluationPeriod(5400)
     *             .isBadEvents(true)
     *             .build());
     * 
     *         var yourCondition = new NrqlAlertCondition(&#34;yourCondition&#34;, NrqlAlertConditionArgs.builder()        
     *             .accountId(12345678)
     *             .policyId(67890)
     *             .type(&#34;static&#34;)
     *             .name(&#34;Custom burn alert&#34;)
     *             .enabled(true)
     *             .violationTimeLimitSeconds(259200)
     *             .nrql(NrqlAlertConditionNrqlArgs.builder()
     *                 .query(fooCustom.applyValue(getServiceLevelAlertHelperResult -&gt; getServiceLevelAlertHelperResult.nrql()))
     *                 .build())
     *             .critical(NrqlAlertConditionCriticalArgs.builder()
     *                 .operator(&#34;above_or_equals&#34;)
     *                 .threshold(fooCustom.applyValue(getServiceLevelAlertHelperResult -&gt; getServiceLevelAlertHelperResult.threshold()))
     *                 .thresholdDuration(900)
     *                 .thresholdOccurrences(&#34;at_least_once&#34;)
     *                 .build())
     *             .fillOption(&#34;none&#34;)
     *             .aggregationWindow(fooCustom.applyValue(getServiceLevelAlertHelperResult -&gt; getServiceLevelAlertHelperResult.evaluationPeriod()))
     *             .aggregationMethod(&#34;event_flow&#34;)
     *             .aggregationDelay(120)
     *             .slideBy(60)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetServiceLevelAlertHelperResult> getServiceLevelAlertHelperPlain(GetServiceLevelAlertHelperPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getServiceLevelAlertHelper:getServiceLevelAlertHelper", TypeShape.of(GetServiceLevelAlertHelperResult.class), args, Utilities.withVersion(options));
    }
    /**
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetTestGrokPatternArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getTestGrokPattern(GetTestGrokPatternArgs.builder()
     *             .grok(&#34;%{IP:host_ip}&#34;)
     *             .logLines(            
     *                 &#34;host_ip: 43.3.120.2&#34;,
     *                 &#34;bytes_received: 2048&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetTestGrokPatternResult> getTestGrokPattern(GetTestGrokPatternArgs args) {
        return getTestGrokPattern(args, InvokeOptions.Empty);
    }
    /**
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetTestGrokPatternArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getTestGrokPattern(GetTestGrokPatternArgs.builder()
     *             .grok(&#34;%{IP:host_ip}&#34;)
     *             .logLines(            
     *                 &#34;host_ip: 43.3.120.2&#34;,
     *                 &#34;bytes_received: 2048&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetTestGrokPatternResult> getTestGrokPatternPlain(GetTestGrokPatternPlainArgs args) {
        return getTestGrokPatternPlain(args, InvokeOptions.Empty);
    }
    /**
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetTestGrokPatternArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getTestGrokPattern(GetTestGrokPatternArgs.builder()
     *             .grok(&#34;%{IP:host_ip}&#34;)
     *             .logLines(            
     *                 &#34;host_ip: 43.3.120.2&#34;,
     *                 &#34;bytes_received: 2048&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetTestGrokPatternResult> getTestGrokPattern(GetTestGrokPatternArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getTestGrokPattern:getTestGrokPattern", TypeShape.of(GetTestGrokPatternResult.class), args, Utilities.withVersion(options));
    }
    /**
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetTestGrokPatternArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         // Data source
     *         final var foo = NewrelicFunctions.getTestGrokPattern(GetTestGrokPatternArgs.builder()
     *             .grok(&#34;%{IP:host_ip}&#34;)
     *             .logLines(            
     *                 &#34;host_ip: 43.3.120.2&#34;,
     *                 &#34;bytes_received: 2048&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetTestGrokPatternResult> getTestGrokPatternPlain(GetTestGrokPatternPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getTestGrokPattern:getTestGrokPattern", TypeShape.of(GetTestGrokPatternResult.class), args, Utilities.withVersion(options));
    }
    /**
     * The `newrelic.User` data source helps search for a user by their name and/or email ID, and accordingly, fetch the ID of the matching user.
     * 
     * ## Example Usage
     * 
     * The below example illustrates fetching a the ID of a user (and other arguments) using the ID of the authentication domain the user belongs to, as well as a name and/or email ID, which can be used as criteria to search for a user who matches these specified parameters.
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import com.pulumi.newrelic.inputs.GetUserArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name(&#34;Test Authentication Domain&#34;)
     *             .build());
     * 
     *         final var userOne = NewrelicFunctions.getUser(GetUserArgs.builder()
     *             .authenticationDomainId(foo.applyValue(getAuthenticationDomainResult -&gt; getAuthenticationDomainResult.id()))
     *             .name(&#34;Test User&#34;)
     *             .build());
     * 
     *         final var userTwo = NewrelicFunctions.getUser(GetUserArgs.builder()
     *             .authenticationDomainId(foo.applyValue(getAuthenticationDomainResult -&gt; getAuthenticationDomainResult.id()))
     *             .emailId(&#34;test_user@random.com&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetUserResult> getUser(GetUserArgs args) {
        return getUser(args, InvokeOptions.Empty);
    }
    /**
     * The `newrelic.User` data source helps search for a user by their name and/or email ID, and accordingly, fetch the ID of the matching user.
     * 
     * ## Example Usage
     * 
     * The below example illustrates fetching a the ID of a user (and other arguments) using the ID of the authentication domain the user belongs to, as well as a name and/or email ID, which can be used as criteria to search for a user who matches these specified parameters.
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import com.pulumi.newrelic.inputs.GetUserArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name(&#34;Test Authentication Domain&#34;)
     *             .build());
     * 
     *         final var userOne = NewrelicFunctions.getUser(GetUserArgs.builder()
     *             .authenticationDomainId(foo.applyValue(getAuthenticationDomainResult -&gt; getAuthenticationDomainResult.id()))
     *             .name(&#34;Test User&#34;)
     *             .build());
     * 
     *         final var userTwo = NewrelicFunctions.getUser(GetUserArgs.builder()
     *             .authenticationDomainId(foo.applyValue(getAuthenticationDomainResult -&gt; getAuthenticationDomainResult.id()))
     *             .emailId(&#34;test_user@random.com&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetUserResult> getUserPlain(GetUserPlainArgs args) {
        return getUserPlain(args, InvokeOptions.Empty);
    }
    /**
     * The `newrelic.User` data source helps search for a user by their name and/or email ID, and accordingly, fetch the ID of the matching user.
     * 
     * ## Example Usage
     * 
     * The below example illustrates fetching a the ID of a user (and other arguments) using the ID of the authentication domain the user belongs to, as well as a name and/or email ID, which can be used as criteria to search for a user who matches these specified parameters.
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import com.pulumi.newrelic.inputs.GetUserArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name(&#34;Test Authentication Domain&#34;)
     *             .build());
     * 
     *         final var userOne = NewrelicFunctions.getUser(GetUserArgs.builder()
     *             .authenticationDomainId(foo.applyValue(getAuthenticationDomainResult -&gt; getAuthenticationDomainResult.id()))
     *             .name(&#34;Test User&#34;)
     *             .build());
     * 
     *         final var userTwo = NewrelicFunctions.getUser(GetUserArgs.builder()
     *             .authenticationDomainId(foo.applyValue(getAuthenticationDomainResult -&gt; getAuthenticationDomainResult.id()))
     *             .emailId(&#34;test_user@random.com&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetUserResult> getUser(GetUserArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("newrelic:index/getUser:getUser", TypeShape.of(GetUserResult.class), args, Utilities.withVersion(options));
    }
    /**
     * The `newrelic.User` data source helps search for a user by their name and/or email ID, and accordingly, fetch the ID of the matching user.
     * 
     * ## Example Usage
     * 
     * The below example illustrates fetching a the ID of a user (and other arguments) using the ID of the authentication domain the user belongs to, as well as a name and/or email ID, which can be used as criteria to search for a user who matches these specified parameters.
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.newrelic.NewrelicFunctions;
     * import com.pulumi.newrelic.inputs.GetAuthenticationDomainArgs;
     * import com.pulumi.newrelic.inputs.GetUserArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var foo = NewrelicFunctions.getAuthenticationDomain(GetAuthenticationDomainArgs.builder()
     *             .name(&#34;Test Authentication Domain&#34;)
     *             .build());
     * 
     *         final var userOne = NewrelicFunctions.getUser(GetUserArgs.builder()
     *             .authenticationDomainId(foo.applyValue(getAuthenticationDomainResult -&gt; getAuthenticationDomainResult.id()))
     *             .name(&#34;Test User&#34;)
     *             .build());
     * 
     *         final var userTwo = NewrelicFunctions.getUser(GetUserArgs.builder()
     *             .authenticationDomainId(foo.applyValue(getAuthenticationDomainResult -&gt; getAuthenticationDomainResult.id()))
     *             .emailId(&#34;test_user@random.com&#34;)
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetUserResult> getUserPlain(GetUserPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("newrelic:index/getUser:getUser", TypeShape.of(GetUserResult.class), args, Utilities.withVersion(options));
    }
}
