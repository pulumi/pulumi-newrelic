// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * Use this resource to create and manage compound alert conditions in New Relic. Compound conditions allow you to combine multiple alert conditions using logical expressions (AND, OR, NOT) to create more sophisticated alerting logic.
 *
 * ## Example Usage
 *
 * ### Basic Compound Condition (AND)
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as newrelic from "@pulumi/newrelic";
 *
 * const example = new newrelic.AlertPolicy("example", {name: "my-policy"});
 * // Create component NRQL conditions
 * const highResponseTime = new newrelic.NrqlAlertCondition("high_response_time", {
 *     policyId: example.id,
 *     name: "High Response Time",
 *     enabled: true,
 *     nrql: {
 *         query: "SELECT average(duration) FROM Transaction WHERE appName = 'MyApp'",
 *     },
 *     critical: {
 *         operator: "above",
 *         threshold: 5,
 *         thresholdDuration: 300,
 *         thresholdOccurrences: "all",
 *     },
 *     violationTimeLimitSeconds: 3600,
 * });
 * const highErrorRate = new newrelic.NrqlAlertCondition("high_error_rate", {
 *     policyId: example.id,
 *     name: "High Error Rate",
 *     enabled: true,
 *     nrql: {
 *         query: "SELECT percentage(count(*), WHERE error IS true) FROM Transaction WHERE appName = 'MyApp'",
 *     },
 *     critical: {
 *         operator: "above",
 *         threshold: 5,
 *         thresholdDuration: 300,
 *         thresholdOccurrences: "all",
 *     },
 *     violationTimeLimitSeconds: 3600,
 * });
 * // Create alert compound condition combining both
 * const criticalServiceHealth = new newrelic.AlertCompoundCondition("critical_service_health", {
 *     policyId: example.id,
 *     name: "Critical Service Health",
 *     enabled: true,
 *     triggerExpression: "A AND B",
 *     runbookUrl: "https://example.com/runbooks/critical-health",
 *     thresholdDuration: 120,
 *     componentConditions: [
 *         {
 *             id: highResponseTime.id,
 *             alias: "A",
 *         },
 *         {
 *             id: highErrorRate.id,
 *             alias: "B",
 *         },
 *     ],
 *     facetMatchingBehavior: "FACETS_IGNORED",
 * });
 * ```
 *
 * ### Complex Condition with Three Components
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as newrelic from "@pulumi/newrelic";
 *
 * const highCpu = new newrelic.NrqlAlertCondition("high_cpu", {
 *     policyId: example.id,
 *     name: "High CPU",
 *     enabled: true,
 *     nrql: {
 *         query: "SELECT average(cpuPercent) FROM SystemSample WHERE hostname = 'myhost'",
 *     },
 *     critical: {
 *         operator: "above",
 *         threshold: 80,
 *         thresholdDuration: 300,
 *         thresholdOccurrences: "all",
 *     },
 *     violationTimeLimitSeconds: 3600,
 * });
 * const highMemory = new newrelic.NrqlAlertCondition("high_memory", {
 *     policyId: example.id,
 *     name: "High Memory",
 *     enabled: true,
 *     nrql: {
 *         query: "SELECT average(memoryUsedPercent) FROM SystemSample WHERE hostname = 'myhost'",
 *     },
 *     critical: {
 *         operator: "above",
 *         threshold: 85,
 *         thresholdDuration: 300,
 *         thresholdOccurrences: "all",
 *     },
 *     violationTimeLimitSeconds: 3600,
 * });
 * const diskFull = new newrelic.NrqlAlertCondition("disk_full", {
 *     policyId: example.id,
 *     name: "Disk Full",
 *     enabled: true,
 *     nrql: {
 *         query: "SELECT average(diskUsedPercent) FROM SystemSample WHERE hostname = 'myhost'",
 *     },
 *     critical: {
 *         operator: "above",
 *         threshold: 90,
 *         thresholdDuration: 300,
 *         thresholdOccurrences: "all",
 *     },
 *     violationTimeLimitSeconds: 3600,
 * });
 * const complex = new newrelic.AlertCompoundCondition("complex", {
 *     policyId: example.id,
 *     name: "Complex Infrastructure Alert",
 *     enabled: true,
 *     triggerExpression: "(A AND B) OR C",
 *     componentConditions: [
 *         {
 *             id: highCpu.id,
 *             alias: "A",
 *         },
 *         {
 *             id: highMemory.id,
 *             alias: "B",
 *         },
 *         {
 *             id: diskFull.id,
 *             alias: "C",
 *         },
 *     ],
 * });
 * ```
 *
 * ### With Facet Matching
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as newrelic from "@pulumi/newrelic";
 *
 * const highThroughputPerHost = new newrelic.NrqlAlertCondition("high_throughput_per_host", {
 *     policyId: example.id,
 *     name: "High Throughput Per Host",
 *     enabled: true,
 *     nrql: {
 *         query: "SELECT rate(count(*), 1 minute) FROM Transaction FACET host",
 *     },
 *     critical: {
 *         operator: "above",
 *         threshold: 1000,
 *         thresholdDuration: 300,
 *         thresholdOccurrences: "all",
 *     },
 *     violationTimeLimitSeconds: 3600,
 * });
 * const highErrorRatePerHost = new newrelic.NrqlAlertCondition("high_error_rate_per_host", {
 *     policyId: example.id,
 *     name: "High Error Rate Per Host",
 *     enabled: true,
 *     nrql: {
 *         query: "SELECT percentage(count(*), WHERE error IS true) FROM Transaction FACET host",
 *     },
 *     critical: {
 *         operator: "above",
 *         threshold: 5,
 *         thresholdDuration: 300,
 *         thresholdOccurrences: "all",
 *     },
 *     violationTimeLimitSeconds: 3600,
 * });
 * const withFacets = new newrelic.AlertCompoundCondition("with_facets", {
 *     policyId: example.id,
 *     name: "Host-Specific Alert",
 *     enabled: true,
 *     triggerExpression: "A AND B",
 *     facetMatchingBehavior: "FACETS_MATCH",
 *     componentConditions: [
 *         {
 *             id: highThroughputPerHost.id,
 *             alias: "A",
 *         },
 *         {
 *             id: highErrorRatePerHost.id,
 *             alias: "B",
 *         },
 *     ],
 * });
 * ```
 *
 * ## Additional Information
 *
 * ### Understanding Trigger Expressions
 *
 * Trigger expressions define the logical conditions under which your alert compound condition will activate. Valid operators are:
 *
 * - **AND** - Both conditions must be true
 * - **OR** - Either condition must be true
 * - **NOT** - Negates a condition
 * - **Parentheses** - Group conditions for complex logic
 *
 * Examples:
 *
 * - `"A AND B"` - Activate when both A and B are in violation
 * - `"A OR B"` - Activate when either A or B is in violation
 * - `"A AND NOT B"` - Activate when A is in violation but B is not
 * - `"(A AND B) OR C"` - Activate when both A and B are in violation, OR when C is in violation
 * - `"A AND (B OR C) AND NOT D"` - Activate when A is in violation AND either B or C is in violation AND D is not in violation
 *
 * ### Facet Matching Behavior
 *
 * When your component NRQL conditions use FACET clauses:
 *
 * - **FACETS_IGNORED** (Default) - Facets are not taken into consideration when determining when the compound alert condition activates. If component conditions have violations (on any facet), the compound alert condition will activate based on the trigger expression.
 * - **FACETS_MATCH** - The compound alert condition will activate only when shared facets have matching values. For example, if condition A fires for `host="server-1"` and condition B fires for `host="server-2"`, the compound alert condition will NOT activate because the facet values don't match.
 *
 * ### Threshold Duration
 *
 * The `thresholdDuration` parameter controls how long the trigger expression must remain true before the compound alert condition will activate.
 *
 * ## Import
 *
 * Compound alert conditions can be imported using the condition ID, e.g.
 */
export class AlertCompoundCondition extends pulumi.CustomResource {
    /**
     * Get an existing AlertCompoundCondition resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: AlertCompoundConditionState, opts?: pulumi.CustomResourceOptions): AlertCompoundCondition {
        return new AlertCompoundCondition(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'newrelic:index/alertCompoundCondition:AlertCompoundCondition';

    /**
     * Returns true if the given object is an instance of AlertCompoundCondition.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is AlertCompoundCondition {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === AlertCompoundCondition.__pulumiType;
    }

    /**
     * The New Relic account ID for managing your compound alert conditions. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
     */
    declare public readonly accountId: pulumi.Output<string>;
    /**
     * The list of conditions to be combined. Each component condition must be enabled. Must include at least 2. See Component Conditions below for details.
     */
    declare public readonly componentConditions: pulumi.Output<outputs.AlertCompoundConditionComponentCondition[]>;
    /**
     * Whether or not the compound alert condition is enabled. Defaults to `true`.
     */
    declare public readonly enabled: pulumi.Output<boolean>;
    /**
     * How the compound condition will take into account the component conditions' facets during evaluation. Valid values are:
     * - `FACETS_IGNORED` - (Default) Facets are not taken into consideration when determining when the compound alert condition activates
     * - `FACETS_MATCH` - The compound alert condition will activate only when shared facets have matching values
     */
    declare public readonly facetMatchingBehavior: pulumi.Output<string>;
    /**
     * The title of the compound alert condition.
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * The ID of the policy where this alert compound condition should be used.
     */
    declare public readonly policyId: pulumi.Output<string>;
    /**
     * Runbook URL to display in notifications.
     */
    declare public readonly runbookUrl: pulumi.Output<string | undefined>;
    /**
     * The duration, in seconds, that the trigger expression must be true before the compound alert condition will activate. Between 30-86400 seconds.
     */
    declare public readonly thresholdDuration: pulumi.Output<number>;
    /**
     * Expression that defines how component condition evaluations are combined. Valid operators are 'AND', 'OR', 'NOT'. For more complex expressions, use parentheses. Use the aliases from `componentConditions` to build expressions like `"A AND B"`, `"A OR B"`, `"(A AND B) OR C"`, or `"A AND (B OR C) AND NOT (D AND E)"`.
     */
    declare public readonly triggerExpression: pulumi.Output<string>;

    /**
     * Create a AlertCompoundCondition resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: AlertCompoundConditionArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: AlertCompoundConditionArgs | AlertCompoundConditionState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as AlertCompoundConditionState | undefined;
            resourceInputs["accountId"] = state?.accountId;
            resourceInputs["componentConditions"] = state?.componentConditions;
            resourceInputs["enabled"] = state?.enabled;
            resourceInputs["facetMatchingBehavior"] = state?.facetMatchingBehavior;
            resourceInputs["name"] = state?.name;
            resourceInputs["policyId"] = state?.policyId;
            resourceInputs["runbookUrl"] = state?.runbookUrl;
            resourceInputs["thresholdDuration"] = state?.thresholdDuration;
            resourceInputs["triggerExpression"] = state?.triggerExpression;
        } else {
            const args = argsOrState as AlertCompoundConditionArgs | undefined;
            if (args?.componentConditions === undefined && !opts.urn) {
                throw new Error("Missing required property 'componentConditions'");
            }
            if (args?.enabled === undefined && !opts.urn) {
                throw new Error("Missing required property 'enabled'");
            }
            if (args?.policyId === undefined && !opts.urn) {
                throw new Error("Missing required property 'policyId'");
            }
            if (args?.triggerExpression === undefined && !opts.urn) {
                throw new Error("Missing required property 'triggerExpression'");
            }
            resourceInputs["accountId"] = args?.accountId;
            resourceInputs["componentConditions"] = args?.componentConditions;
            resourceInputs["enabled"] = args?.enabled;
            resourceInputs["facetMatchingBehavior"] = args?.facetMatchingBehavior;
            resourceInputs["name"] = args?.name;
            resourceInputs["policyId"] = args?.policyId;
            resourceInputs["runbookUrl"] = args?.runbookUrl;
            resourceInputs["thresholdDuration"] = args?.thresholdDuration;
            resourceInputs["triggerExpression"] = args?.triggerExpression;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(AlertCompoundCondition.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering AlertCompoundCondition resources.
 */
export interface AlertCompoundConditionState {
    /**
     * The New Relic account ID for managing your compound alert conditions. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
     */
    accountId?: pulumi.Input<string>;
    /**
     * The list of conditions to be combined. Each component condition must be enabled. Must include at least 2. See Component Conditions below for details.
     */
    componentConditions?: pulumi.Input<pulumi.Input<inputs.AlertCompoundConditionComponentCondition>[]>;
    /**
     * Whether or not the compound alert condition is enabled. Defaults to `true`.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * How the compound condition will take into account the component conditions' facets during evaluation. Valid values are:
     * - `FACETS_IGNORED` - (Default) Facets are not taken into consideration when determining when the compound alert condition activates
     * - `FACETS_MATCH` - The compound alert condition will activate only when shared facets have matching values
     */
    facetMatchingBehavior?: pulumi.Input<string>;
    /**
     * The title of the compound alert condition.
     */
    name?: pulumi.Input<string>;
    /**
     * The ID of the policy where this alert compound condition should be used.
     */
    policyId?: pulumi.Input<string>;
    /**
     * Runbook URL to display in notifications.
     */
    runbookUrl?: pulumi.Input<string>;
    /**
     * The duration, in seconds, that the trigger expression must be true before the compound alert condition will activate. Between 30-86400 seconds.
     */
    thresholdDuration?: pulumi.Input<number>;
    /**
     * Expression that defines how component condition evaluations are combined. Valid operators are 'AND', 'OR', 'NOT'. For more complex expressions, use parentheses. Use the aliases from `componentConditions` to build expressions like `"A AND B"`, `"A OR B"`, `"(A AND B) OR C"`, or `"A AND (B OR C) AND NOT (D AND E)"`.
     */
    triggerExpression?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a AlertCompoundCondition resource.
 */
export interface AlertCompoundConditionArgs {
    /**
     * The New Relic account ID for managing your compound alert conditions. Defaults to the account ID set in your environment variable `NEW_RELIC_ACCOUNT_ID`.
     */
    accountId?: pulumi.Input<string>;
    /**
     * The list of conditions to be combined. Each component condition must be enabled. Must include at least 2. See Component Conditions below for details.
     */
    componentConditions: pulumi.Input<pulumi.Input<inputs.AlertCompoundConditionComponentCondition>[]>;
    /**
     * Whether or not the compound alert condition is enabled. Defaults to `true`.
     */
    enabled: pulumi.Input<boolean>;
    /**
     * How the compound condition will take into account the component conditions' facets during evaluation. Valid values are:
     * - `FACETS_IGNORED` - (Default) Facets are not taken into consideration when determining when the compound alert condition activates
     * - `FACETS_MATCH` - The compound alert condition will activate only when shared facets have matching values
     */
    facetMatchingBehavior?: pulumi.Input<string>;
    /**
     * The title of the compound alert condition.
     */
    name?: pulumi.Input<string>;
    /**
     * The ID of the policy where this alert compound condition should be used.
     */
    policyId: pulumi.Input<string>;
    /**
     * Runbook URL to display in notifications.
     */
    runbookUrl?: pulumi.Input<string>;
    /**
     * The duration, in seconds, that the trigger expression must be true before the compound alert condition will activate. Between 30-86400 seconds.
     */
    thresholdDuration?: pulumi.Input<number>;
    /**
     * Expression that defines how component condition evaluations are combined. Valid operators are 'AND', 'OR', 'NOT'. For more complex expressions, use parentheses. Use the aliases from `componentConditions` to build expressions like `"A AND B"`, `"A OR B"`, `"(A AND B) OR C"`, or `"A AND (B OR C) AND NOT (D AND E)"`.
     */
    triggerExpression: pulumi.Input<string>;
}
